diff --git a/.github/workflows/atlas.yml b/.github/workflows/atlas.yml.DISABLED
similarity index 100%
rename from .github/workflows/atlas.yml
rename to .github/workflows/atlas.yml.DISABLED
diff --git a/.github/workflows/dependencies-review.yml b/.github/workflows/dependencies-review.yml.DISABLED
similarity index 100%
rename from .github/workflows/dependencies-review.yml
rename to .github/workflows/dependencies-review.yml.DISABLED
diff --git a/.github/workflows/labeler.yml b/.github/workflows/labeler.yml
index 2f40ea5d36..fbeab78701 100644
--- a/.github/workflows/labeler.yml
+++ b/.github/workflows/labeler.yml
@@ -6,6 +6,6 @@ jobs:
   labeler:
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/labeler@main
+      - uses: actions/labeler@v4 # v5 is broken, ref https://github.com/actions/labeler/issues/712. Do not bump.
         with:
-          repo-token: "${{ secrets.GITHUB_TOKEN }}"
\ No newline at end of file
+          repo-token: "${{ secrets.GITHUB_TOKEN }}"
diff --git a/.github/workflows/linkchecker.yml b/.github/workflows/linkchecker.yml.DISABLED
similarity index 100%
rename from .github/workflows/linkchecker.yml
rename to .github/workflows/linkchecker.yml.DISABLED
diff --git a/.github/workflows/stale.yml b/.github/workflows/stale.yml.DISABLED
similarity index 100%
rename from .github/workflows/stale.yml
rename to .github/workflows/stale.yml.DISABLED
diff --git a/.mergify.yml b/.mergify.yml
index 107930132e..1a0a96ed0d 100644
--- a/.mergify.yml
+++ b/.mergify.yml
@@ -1,50 +1,33 @@
 queue_rules:
   - name: default
     conditions:
-      - "#approved-reviews-by>1"
+      - base~=^Agoric
+
 
 pull_request_rules:
-  - name: automerge to main with label automerge and branch protection passing
+  - name: automerge to Agoric* with label automerge and branch protection passing
     conditions:
-      - "#approved-reviews-by>1"
-      - base=main
-      - label=A:automerge
+      - "#approved-reviews-by>0"
+      - base~=^Agoric
+      - label=automerge
     actions:
       queue:
         name: default
-        method: squash
-        commit_message_template: |
-          {{ title }} (#{{ number }})
-          {{ body }}
-  - name: backport patches to v0.46.x branch
-    conditions:
-      - base=main
-      - label=backport/0.46.x
-    actions:
-      backport:
-        branches:
-          - release/v0.46.x
-  - name: backport patches to v0.45.x branch
-    conditions:
-      - base=main
-      - label=backport/0.45.x
-    actions:
-      backport:
-        branches:
-          - release/v0.45.x
-  - name: backport patches to v0.44.x branch
+        method: merge
+      # commit_message: title+body
+  - name: backport patches to Agoric branch
     conditions:
-      - base=main
-      - label=backport/0.44.x
+      - base=Agoric-ag0
+      - label=backport/Agoric
     actions:
       backport:
         branches:
-          - release/v0.44.x
-  - name: backport patches to v0.42.x branch
+          - Agoric
+  - name: backport patches to Agoric-ag0 branch
     conditions:
-      - base=main
-      - label=backport/0.42.x (Stargate)
+      - base=Agoric
+      - label=backport/Agoric-ag0
     actions:
       backport:
         branches:
-          - release/v0.42.x
+          - Agoric-ag0
diff --git a/Agoric-branch-notes.md b/Agoric-branch-notes.md
new file mode 100644
index 0000000000..630b4e9882
--- /dev/null
+++ b/Agoric-branch-notes.md
@@ -0,0 +1,25 @@
+We have:
+
+- `Agoric` - the head of this branch should be eventually used by the
+  [agoric-sdk](https://github.com/Agoric/agoric-sdk).
+- [ag0](https://github.com/Agoric/ag0) [Agoric mainnet](https://agoric.com)
+  phase 0's [gaiad-equivalent](https://github.com/cosmos/gaia)
+- `Agoric-ag0` - should be identical to
+  [cosmos/cosmos-sdk](https://github.com/cosmos/cosmos-sdk) + changes needed by
+  `ag0`
+
+For new features:
+
+- Create a new development branch off of `Agoric` or `Agoric-ag0`
+- Test, review, merge PR with `automerge` label for mergify.io
+- Add `backport/ag0` label or `backport/Agoric` to have mergify port the PR to
+  the other branch
+
+Upon new cosmos-sdk releases:
+
+- Say we now have `cosmos/cosmos-sdk@v0.43.0-rc0`
+- Merge `upstream/v0.43.0-rc0` into `Agoric`, create tag `v0.43.0-rc0.agoric`
+- Push tag to origin
+- Use that tag in the `agoric-sdk/go.mod` in the `replace` directive for `cosmos-sdk`
+- build `agoric-sdk` and do any manual tests locally
+- submit a PR against `agoric-sdk` for CI tests to run, then merge
diff --git a/CHANGELOG-Agoric.md b/CHANGELOG-Agoric.md
new file mode 100644
index 0000000000..96de6f6d22
--- /dev/null
+++ b/CHANGELOG-Agoric.md
@@ -0,0 +1,128 @@
+<!--
+Guiding Principles:
+
+Changelogs are for humans, not machines.
+There should be an entry for every single version.
+The same types of changes should be grouped.
+Versions and sections should be linkable.
+The latest version comes first.
+The release date of each version is displayed.
+Mention whether you follow Semantic Versioning.
+
+Usage:
+
+Change log entries are to be added to the Unreleased section under the
+appropriate stanza (see below). Each entry should ideally include a tag and
+the Github issue reference in the following format:
+
+* (<tag>) \#<issue-number> message
+
+The issue numbers will later be link-ified during the release process so you do
+not have to worry about including a link manually, but you can if you wish.
+
+Types of changes (Stanzas):
+
+"Features" for new features.
+"Improvements" for changes in existing functionality.
+"Deprecated" for soon-to-be removed features.
+"Bug Fixes" for any bug fixes.
+"Client Breaking" for breaking Protobuf, gRPC and REST routes used by end-users.
+"CLI Breaking" for breaking CLI commands.
+"API Breaking" for breaking exported APIs used by developers building on SDK.
+"State Machine Breaking" for any changes that result in a different AppState given same genesisState and txList.
+Ref: https://keepachangelog.com/en/1.0.0/
+-->
+
+# Changelog (Agoric fork)
+
+## Unreleased
+
+### Improvements
+
+* (auth) [#407](https://github.com/agoric-labs/cosmos-sdk/pull/407) Configurable fee collector module account in DeductFeeDecorator.
+
+### API Breaking
+
+* (auth, bank) Agoric/agoric-sdk#8989 Remove deprecated lien support
+
+## `v0.46.16-alpha.agoric.2.4` - 2024-04-19
+
+### Improvements
+
+* (server) [#419](https://github.com/agoric-labs/cosmos-sdk/pull/419) More unit tests for flag vs toml precedence for ABCI client type.
+
+## `v0.46.16-alpha.agoric.2.3` - 2024-04-17
+
+### Improvements
+
+* (baseapp) [#415](https://github.com/agoric-labs/cosmos-sdk/pull/415) Unit tests and documentation for event history.
+* (server) [#416](https://github.com/agoric-labs/cosmos-sdk/pull/416) Config entry to select ABCI client type.
+
+### Bug Fixes
+
+* (baseapp) [#415](https://github.com/agoric-labs/cosmos-sdk/pull/415) Avoid duplicates in event history.
+
+## `v0.46.16-alpha.agoric.2.2` - 2024-04-12
+
+### Improvements
+
+* (server) [#409](https://github.com/agoric-labs/cosmos-sdk/pull/409) Flag to select ABCI client type.
+* (deps) [#412](https://github.com/agoric-labs/cosmos-sdk/pull/412) Bump iavl to v0.19.7
+
+### Bug Fixes
+
+* (baseapp) [#413](https://github.com/agoric-labs/cosmos-sdk/pull/413) Ignore events from simulated transactions
+
+## `v0.46.16-alpha.agoric.2.1` - 2024-03-08
+
+### Improvements
+
+* (auth) #??? Configurable fee collector module account in DeductFeeDecorator. (backport #407)
+
+## `v0.46.16-alpha.agoric.2` - 2024-02-08
+
+* Agoric/agoric-sdk#8871 Have `tx gov submit-proposal` accept either new or legacy syntax
+
+### Bug Fixes
+
+* (crypto) [#19371](https://github.com/cosmos/cosmos-sdk/pull/19371) Avoid cli redundant log in stdout, log to stderr instead.
+
+## `v0.46.16-alpha.agoric.1` - 2024-02-05
+
+* Agoric/agoric-sdk#8224 Merge [cosmos/cosmos-sdk v0.46.16](https://github.com/cosmos/cosmos-sdk/releases/tag/v0.46.16)
+
+### Bug Fixes
+
+* Agoric/agoric-sdk#8719 MsgClawback returns the wrong Type
+
+## `v0.45.16-alpha.agoric.3` - 2023-12-04
+
+* (vesting) [#342](https://github.com/agoric-labs/cosmos-sdk/pull/342) recipient can return clawback vesting grant to funder
+
+## `v0.45.16-alpha.agoric.2` - 2023-11-08
+
+### Bug Fixes
+
+* (baseapp) [#337](https://github.com/agoric-labs/cosmos-sdk/pull/337) revert #305 which causes test failures in agoric-sdk
+
+## `v0.45.16-alpha.agoric.1` - 2023-09-22
+
+### Improvements
+
+* Agoric/agoric-sdk#8223 Merge [cosmos/cosmos-sdk v0.45.16](https://github.com/cosmos/cosmos-sdk/releases/tag/v0.45.16)
+* (vesting) [#303](https://github.com/agoric-labs/cosmos-sdk/pull/303) Improve vestcalc comments and documentation.
+
+### Bug Fixes
+
+* (snapshots) [#304](https://github.com/agoric-labs/cosmos-sdk/pull/304) raise the per snapshot item limit. Fixes [Agoric/agoric-sdk#8325](https://github.com/Agoric/agoric-sdk/issues/8325)
+* (baseapp) [#305](https://github.com/agoric-labs/cosmos-sdk/pull/305) Make sure we don't execute blocks beyond the halt height. Port of [cosmos/cosmos-sdk#16639](https://github.com/cosmos/cosmos-sdk/pull/16639)
+
+## `v0.45.11-alpha.agoric.2` - 2023-03-23
+
+### Improvements
+
+* (snapshot) [#13400](https://github.com/cosmos/cosmos-sdk/pull/13400) Fix snapshot checksum issue in golang 1.19.
+
+### API Breaking Changes
+
+* (store) [#11825](https://github.com/cosmos/cosmos-sdk/pull/11825)Â Make extension snapshotter interface safer to use, renamed the util function `WriteExtensionItem` to `WriteExtensionPayload`.
diff --git a/Makefile b/Makefile
index 464ed93248..040ec44aeb 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,8 @@ BINDIR ?= $(GOPATH)/bin
 BUILDDIR ?= $(CURDIR)/build
 SIMAPP = ./simapp
 MOCKS_DIR = $(CURDIR)/tests/mocks
-HTTPS_GIT := https://github.com/cosmos/cosmos-sdk.git
+PR_TARGET_REPO = https://github.com/agoric-labs/cosmos-sdk.git
+PR_TARGET_BRANCH = Agoric
 DOCKER := $(shell which docker)
 DOCKER_BUF := $(DOCKER) run --rm -v $(CURDIR):/workspace --workdir /workspace bufbuild/buf:1.0.0-rc8
 PROJECT_NAME = $(shell git remote get-url origin | xargs basename -s .git)
@@ -415,9 +416,9 @@ proto-lint:
 	@$(DOCKER_BUF) lint --error-format=json
 
 proto-check-breaking:
-	@$(DOCKER_BUF) breaking --against $(HTTPS_GIT)#branch=main
+	@$(DOCKER_BUF) breaking --against $(PR_TARGET_REPO)#branch=$(PR_TARGET_BRANCH)
 
-TM_URL              = https://raw.githubusercontent.com/cometbft/cometbft/v0.34.28/proto/tendermint
+TM_URL              = https://raw.githubusercontent.com/agoric-labs/cometbft/v0.34.30-alpha.agoric.1/proto/tendermint
 
 TM_CRYPTO_TYPES     = proto/tendermint/crypto
 TM_ABCI_TYPES       = proto/tendermint/abci
diff --git a/baseapp/abci.go b/baseapp/abci.go
index 7147d6d885..03cbc8afa6 100644
--- a/baseapp/abci.go
+++ b/baseapp/abci.go
@@ -203,7 +203,11 @@ func (app *BaseApp) EndBlock(req abci.RequestEndBlock) (res abci.ResponseEndBloc
 	}
 
 	if app.endBlocker != nil {
-		res = app.endBlocker(app.deliverState.ctx, req)
+		// [AGORIC] Propagate the event history.
+		enhancedEm := sdk.NewEventManagerWithHistory(app.deliverState.eventHistory)
+		enhancedCtx := app.deliverState.ctx.WithEventManager(enhancedEm)
+
+		res = app.endBlocker(enhancedCtx, req)
 		res.Events = sdk.MarkEventsToIndex(res.Events, app.indexEvents)
 	}
 
@@ -211,6 +215,8 @@ func (app *BaseApp) EndBlock(req abci.RequestEndBlock) (res abci.ResponseEndBloc
 		res.ConsensusParamUpdates = cp
 	}
 
+	app.deliverState.eventHistory = []abci.Event{}
+
 	// call the streaming service hooks with the EndBlock messages
 	for _, streamingListener := range app.abciListeners {
 		if err := streamingListener.ListenEndBlock(app.deliverState.ctx, req, res); err != nil {
@@ -262,6 +268,17 @@ func (app *BaseApp) CheckTx(req abci.RequestCheckTx) abci.ResponseCheckTx {
 // Regardless of tx execution outcome, the ResponseDeliverTx will contain relevant
 // gas execution context.
 func (app *BaseApp) DeliverTx(req abci.RequestDeliverTx) (res abci.ResponseDeliverTx) {
+	// [AGORIC] Remember event history for successful deliveries.
+	// deliverTxWithoutEventHistory is the upstream cosmos-sdk DeliverTx.
+	res = app.deliverTxWithoutEventHistory(req)
+	// When successful, remember event history.
+	if res.Code == sdkerrors.SuccessABCICode {
+		app.deliverState.eventHistory = append(app.deliverState.eventHistory, res.Events...)
+	}
+	return res
+}
+
+func (app *BaseApp) deliverTxWithoutEventHistory(req abci.RequestDeliverTx) (res abci.ResponseDeliverTx) {
 	gInfo := sdk.GasInfo{}
 	resultStr := "successful"
 
@@ -303,6 +320,22 @@ func (app *BaseApp) DeliverTx(req abci.RequestDeliverTx) (res abci.ResponseDeliv
 // against that height and gracefully halt if it matches the latest committed
 // height.
 func (app *BaseApp) Commit() abci.ResponseCommit {
+	// Upstream cosmos-sdk unconditionally calls SnapshotIfApplicable, like:
+	//    go app.snapshotManager.SnapshotIfApplicable(header.Height)
+	// We separate that into determination in CommitWithoutSnapshot
+	// and initiation (if applicable) here.
+	res, snapshotHeight := app.CommitWithoutSnapshot()
+	if snapshotHeight > 0 {
+		go app.snapshotManager.Snapshot(snapshotHeight)
+	}
+
+	return res
+}
+
+// CommitWithoutSnapshot is like Commit but instead of starting the snapshot goroutine
+// it returns a positive height to indicate that a snapshot is warranted.
+// It can be used by apps to synchronously manage snapshot logic, especially initiation.
+func (app *BaseApp) CommitWithoutSnapshot() (_res abci.ResponseCommit, snapshotHeight int64) {
 	header := app.deliverState.ctx.BlockHeader()
 	retainHeight := app.GetBlockRetentionHeight(header.Height)
 
@@ -353,9 +386,11 @@ func (app *BaseApp) Commit() abci.ResponseCommit {
 		app.halt()
 	}
 
-	go app.snapshotManager.SnapshotIfApplicable(header.Height)
+	if app.snapshotManager.ShouldTakeSnapshot(header.Height) {
+		snapshotHeight = header.Height
+	}
 
-	return res
+	return res, snapshotHeight
 }
 
 // halt attempts to gracefully shutdown the node via SIGINT and SIGTERM falling
@@ -380,6 +415,16 @@ func (app *BaseApp) halt() {
 	os.Exit(0)
 }
 
+// Snapshot takes a snapshot of the current state and prunes any old snapshottypes.
+// It should be started as a goroutine
+func (app *BaseApp) Snapshot(height int64) {
+	if app.snapshotManager == nil {
+		app.logger.Info("snapshot manager not configured")
+		return
+	}
+	app.snapshotManager.Snapshot(height)
+}
+
 // Query implements the ABCI interface. It delegates to CommitMultiStore if it
 // implements Queryable.
 func (app *BaseApp) Query(req abci.RequestQuery) (res abci.ResponseQuery) {
@@ -392,8 +437,19 @@ func (app *BaseApp) Query(req abci.RequestQuery) (res abci.ResponseQuery) {
 	}()
 
 	// when a client did not provide a query height, manually inject the latest
+	lastHeight := app.LastBlockHeight()
 	if req.Height == 0 {
-		req.Height = app.LastBlockHeight()
+		req.Height = lastHeight
+	}
+	if req.Height > lastHeight {
+		return sdkerrors.QueryResult(
+			sdkerrors.Wrapf(
+				sdkerrors.ErrInvalidHeight,
+				"given height %d is greater than latest height %d",
+				req.Height, lastHeight,
+			),
+			app.trace,
+		)
 	}
 
 	telemetry.IncrCounter(1, "query", "count")
diff --git a/baseapp/abci_test.go b/baseapp/abci_test.go
index cddd48af78..8ec3303de5 100644
--- a/baseapp/abci_test.go
+++ b/baseapp/abci_test.go
@@ -2,6 +2,7 @@ package baseapp
 
 import (
 	"encoding/json"
+	"fmt"
 	"testing"
 
 	"github.com/stretchr/testify/require"
@@ -167,6 +168,26 @@ func TestBaseAppCreateQueryContext(t *testing.T) {
 	}
 }
 
+func TestBaseAppCreateQueryContextRejectsFutureHeights(t *testing.T) {
+	t.Parallel()
+
+	logger := defaultLogger()
+	db := dbm.NewMemDB()
+	name := t.Name()
+	app := NewBaseApp(name, logger, db, nil)
+
+	proves := []bool{
+		false, true,
+	}
+	for _, prove := range proves {
+		t.Run(fmt.Sprintf("prove=%t", prove), func(t *testing.T) {
+			sctx, err := app.createQueryContext(30, true)
+			require.Error(t, err)
+			require.Equal(t, sctx, sdk.Context{})
+		})
+	}
+}
+
 type paramStore struct {
 	db *dbm.MemDB
 }
diff --git a/baseapp/baseapp.go b/baseapp/baseapp.go
index b42a56efca..a1cd67238e 100644
--- a/baseapp/baseapp.go
+++ b/baseapp/baseapp.go
@@ -28,6 +28,12 @@ const (
 	runTxModeDeliver                   // Deliver a transaction
 )
 
+// [AGORIC] Context keys for including TX hash and msg index.
+const (
+	TxHashContextKey   = sdk.ContextKey("tx-hash")
+	TxMsgIdxContextKey = sdk.ContextKey("tx-msg-idx")
+)
+
 var _ abci.Application = (*BaseApp)(nil)
 
 type (
@@ -427,8 +433,9 @@ func (app *BaseApp) IsSealed() bool { return app.sealed }
 func (app *BaseApp) setCheckState(header tmproto.Header) {
 	ms := app.cms.CacheMultiStore()
 	app.checkState = &state{
-		ms:  ms,
-		ctx: sdk.NewContext(ms, header, true, app.logger).WithMinGasPrices(app.minGasPrices),
+		ms:           ms,
+		ctx:          sdk.NewContext(ms, header, true, app.logger).WithMinGasPrices(app.minGasPrices),
+		eventHistory: []abci.Event{}, // [AGORIC]: start with an empty history.
 	}
 }
 
@@ -439,8 +446,9 @@ func (app *BaseApp) setCheckState(header tmproto.Header) {
 func (app *BaseApp) setDeliverState(header tmproto.Header) {
 	ms := app.cms.CacheMultiStore()
 	app.deliverState = &state{
-		ms:  ms,
-		ctx: sdk.NewContext(ms, header, false, app.logger),
+		ms:           ms,
+		ctx:          sdk.NewContext(ms, header, false, app.logger),
+		eventHistory: []abci.Event{}, // [AGORIC]: start with an empty history.
 	}
 }
 
@@ -599,6 +607,13 @@ func (app *BaseApp) getContextForTx(mode runTxMode, txBytes []byte) sdk.Context
 // cacheTxContext returns a new context based off of the provided context with
 // a branched multi-store.
 func (app *BaseApp) cacheTxContext(ctx sdk.Context, txBytes []byte) (sdk.Context, sdk.CacheMultiStore) {
+	// [AGORIC] Add Tx hash to the context if absent.
+	txHash, ok := ctx.Context().Value(TxHashContextKey).(string)
+	if !ok {
+		txHash = fmt.Sprintf("%X", tmhash.Sum(txBytes))
+		ctx = ctx.WithValue(TxHashContextKey, txHash)
+	}
+
 	ms := ctx.MultiStore()
 	// TODO: https://github.com/cosmos/cosmos-sdk/issues/2824
 	msCache := ms.CacheMultiStore()
@@ -606,7 +621,7 @@ func (app *BaseApp) cacheTxContext(ctx sdk.Context, txBytes []byte) (sdk.Context
 		msCache = msCache.SetTracingContext(
 			sdk.TraceContext(
 				map[string]interface{}{
-					"txHash": fmt.Sprintf("%X", tmhash.Sum(txBytes)),
+					"txHash": txHash,
 				},
 			),
 		).(sdk.CacheMultiStore)
@@ -783,9 +798,12 @@ func (app *BaseApp) runMsgs(ctx sdk.Context, msgs []sdk.Msg, mode runTxMode) (*s
 			err          error
 		)
 
+		// [AGORIC] Propagate the message index in the context.
+		msgCtx := ctx.WithValue(TxMsgIdxContextKey, i)
+
 		if handler := app.msgServiceRouter.Handler(msg); handler != nil {
 			// ADR 031 request type routing
-			msgResult, err = handler(ctx, msg)
+			msgResult, err = handler(msgCtx, msg)
 			eventMsgName = sdk.MsgTypeURL(msg)
 		} else if legacyMsg, ok := msg.(legacytx.LegacyMsg); ok {
 			// legacy sdk.Msg routing
@@ -795,12 +813,12 @@ func (app *BaseApp) runMsgs(ctx sdk.Context, msgs []sdk.Msg, mode runTxMode) (*s
 			// registered within the `msgServiceRouter` already.
 			msgRoute := legacyMsg.Route()
 			eventMsgName = legacyMsg.Type()
-			handler := app.router.Route(ctx, msgRoute)
+			handler := app.router.Route(msgCtx, msgRoute)
 			if handler == nil {
 				return nil, sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, "unrecognized message route: %s; message index: %d", msgRoute, i)
 			}
 
-			msgResult, err = handler(ctx, msg)
+			msgResult, err = handler(msgCtx, msg)
 		} else {
 			return nil, sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, "can't route message %+v", msg)
 		}
diff --git a/baseapp/baseapp_test.go b/baseapp/baseapp_test.go
index 99e4541b5e..0c9d5f9bbf 100644
--- a/baseapp/baseapp_test.go
+++ b/baseapp/baseapp_test.go
@@ -1128,6 +1128,75 @@ func TestSimulateTx(t *testing.T) {
 	}
 }
 
+func TestEventHistory(t *testing.T) {
+	// generates events in the ante
+	anteKey := []byte("ante-key")
+	anteOpt := func(bapp *BaseApp) { bapp.SetAnteHandler(anteHandlerTxTest(t, capKey1, anteKey)) }
+
+	deliverKey := []byte("deliver-key")
+	routerOpt := func(bapp *BaseApp) {
+		r := sdk.NewRoute(routeMsgCounter, handlerMsgCounter(t, capKey1, deliverKey))
+		bapp.Router().AddRoute(r)
+	}
+
+	// expand setupBaseApp() here so we can override the EndBlocker before app is sealed
+	app := newBaseApp(t.Name(), anteOpt, routerOpt)
+	require.Equal(t, t.Name(), app.Name())
+
+	app.MountStores(capKey1, capKey2)
+	app.SetParamStore(&paramStore{db: dbm.NewMemDB()})
+
+	var history []abci.Event
+	app.SetEndBlocker(func(ctx sdk.Context, req abci.RequestEndBlock) abci.ResponseEndBlock {
+		history = ctx.EventManager().GetABCIEventHistory()
+		return abci.ResponseEndBlock{}
+	})
+
+	// stores are mounted (seals the app)
+	err := app.LoadLatestVersion()
+	require.Nil(t, err)
+
+	app.InitChain(abci.RequestInitChain{})
+
+	// Create same codec used in txDecoder
+	cdc := codec.NewLegacyAmino()
+	registerTestCodec(cdc)
+
+	header := tmproto.Header{Height: int64(1)}
+	app.BeginBlock(abci.RequestBeginBlock{Header: header})
+
+	require.Zero(t, len(app.deliverState.eventHistory))
+
+	counter := int64(0)
+	tx := newTxCounter(counter, counter)
+	txBytes, err := cdc.Marshal(tx)
+	require.NoError(t, err)
+
+	// simulation returns events, but none in deliverState history
+	_, simResult, err := app.Simulate(txBytes)
+	require.NoError(t, err)
+	require.NotNil(t, simResult)
+	require.Zero(t, len(app.deliverState.eventHistory))
+	expectedEvents := simResult.Events
+	require.NotZero(t, len(expectedEvents))
+
+	// delivery results should be reflected in deliverState history
+	deliverResult := app.DeliverTx(abci.RequestDeliverTx{Tx: txBytes})
+	require.True(t, deliverResult.IsOK(), fmt.Sprintf("%v", deliverResult))
+	require.NotZero(t, len(app.deliverState.eventHistory))
+	// simResult events are not indexed, but should otherwise be the same as deliverResult events
+	for i, _ := range simResult.Events {
+		simResult.Events[i].Attributes[0].Index = true
+	}
+	require.Equal(t, expectedEvents, deliverResult.Events)
+	require.Equal(t, expectedEvents, app.deliverState.eventHistory)
+
+	// the deliverState event history should be passed to the end blocker in the context, then cleared
+	app.EndBlock(abci.RequestEndBlock{})
+	require.Zero(t, len(app.deliverState.eventHistory))
+	require.Equal(t, expectedEvents, history)
+}
+
 func TestRunInvalidTransaction(t *testing.T) {
 	anteOpt := func(bapp *BaseApp) {
 		bapp.SetAnteHandler(func(ctx sdk.Context, tx sdk.Tx, simulate bool) (newCtx sdk.Context, err error) {
diff --git a/baseapp/state.go b/baseapp/state.go
index addc89cb34..c06006ca5e 100644
--- a/baseapp/state.go
+++ b/baseapp/state.go
@@ -2,11 +2,17 @@ package baseapp
 
 import (
 	sdk "github.com/cosmos/cosmos-sdk/types"
+	abci "github.com/tendermint/tendermint/abci/types"
 )
 
 type state struct {
 	ms  sdk.CacheMultiStore
 	ctx sdk.Context
+	// eventHistory accumulates events returned by DeliverTx throughout a block.
+	// [AGORIC] The accumulated events are passed to the EndBlocker in its context's
+	// EventManager ABCI event history, and the state's eventHistory is then cleared.
+	// Not used for modes or states other than delivery.
+	eventHistory []abci.Event
 }
 
 // CacheMultiStore calls and returns a CacheMultiStore on the state's underling
diff --git a/cosmovisor/README-Agoric.md b/cosmovisor/README-Agoric.md
new file mode 100644
index 0000000000..cde9d232af
--- /dev/null
+++ b/cosmovisor/README-Agoric.md
@@ -0,0 +1,25 @@
+# Agoric enhancements to Cosmovisor
+
+This particular Cosmovisor accommodates download and building from URLs referencing one of:
+
+- as in upstream: single executable file
+- as in upstream: zip file extracted verbatim to `.`, with executable file found
+  at one of:
+  - `./bin/$DAEMON_NAME`
+  - `./$DAEMON_NAME`
+- new in this fork: zip file containing a single root directory, whose extracted
+  contents are moved to `.`, with executable file found at one of:
+  - `./bin/$DAEMON_NAME`
+  - `./$DAEMON_NAME`
+
+To install this fork of `cosmovisor`, run the following command:
+
+```
+go install github.com/agoric-sdk/cosmos-sdk/cosmovisor/cmd/cosmovisor@Agoric
+```
+
+Note that cosmovisor does not use the the version of cosmos-sdk that it is
+contained in. This is true of both the Cosmos and Agoric versions.
+
+Have fun,
+The team at [Agoric](https://github.com/Agoric).
diff --git a/cosmovisor/args.go b/cosmovisor/args.go
index c9a0d36a92..3d4c43e56e 100644
--- a/cosmovisor/args.go
+++ b/cosmovisor/args.go
@@ -11,7 +11,7 @@ import (
 	"strings"
 	"time"
 
-	cverrors "github.com/cosmos/cosmos-sdk/cosmovisor/errors"
+	cverrors "github.com/agoric-labs/cosmos-sdk/cosmovisor/errors"
 	upgradekeeper "github.com/cosmos/cosmos-sdk/x/upgrade/keeper"
 	upgradetypes "github.com/cosmos/cosmos-sdk/x/upgrade/types"
 	"github.com/rs/zerolog"
diff --git a/cosmovisor/args_test.go b/cosmovisor/args_test.go
index e2f0a956b9..be7ad1f8a3 100644
--- a/cosmovisor/args_test.go
+++ b/cosmovisor/args_test.go
@@ -14,7 +14,7 @@ import (
 	"github.com/stretchr/testify/require"
 	"github.com/stretchr/testify/suite"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor/errors"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor/errors"
 )
 
 type argsTestSuite struct {
diff --git a/cosmovisor/cmd/cosmovisor/help.go b/cosmovisor/cmd/cosmovisor/help.go
index 25f2ca6c17..e5b41780a7 100644
--- a/cosmovisor/cmd/cosmovisor/help.go
+++ b/cosmovisor/cmd/cosmovisor/help.go
@@ -3,7 +3,7 @@ package main
 import (
 	"fmt"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
 )
 
 // GetHelpText creates the help text multi-line string.
@@ -18,7 +18,7 @@ the proposal. Cosmovisor interprets that data to perform an update: switch a cur
 and restart the App.
 
 Configuration of Cosmovisor is done through environment variables, which are
-documented in: https://github.com/cosmos/cosmos-sdk/tree/main/cosmovisor/README.md`,
+documented in: https://github.com/agoric-labs/cosmos-sdk/tree/main/cosmovisor/README.md`,
 		cosmovisor.EnvName, cosmovisor.EnvHome,
 	)
 }
diff --git a/cosmovisor/cmd/cosmovisor/help_test.go b/cosmovisor/cmd/cosmovisor/help_test.go
index fad8adde81..23aaf1936b 100644
--- a/cosmovisor/cmd/cosmovisor/help_test.go
+++ b/cosmovisor/cmd/cosmovisor/help_test.go
@@ -8,7 +8,7 @@ import (
 	"github.com/stretchr/testify/require"
 	"github.com/stretchr/testify/suite"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
 )
 
 type HelpTestSuite struct {
@@ -92,7 +92,7 @@ func (s *HelpTestSuite) TestGetHelpText() {
 	expectedPieces := []string{
 		"Cosmosvisor",
 		cosmovisor.EnvName, cosmovisor.EnvHome,
-		"https://github.com/cosmos/cosmos-sdk/tree/main/cosmovisor/README.md",
+		"https://github.com/agoric-labs/cosmos-sdk/tree/main/cosmovisor/README.md",
 	}
 
 	actual := GetHelpText()
diff --git a/cosmovisor/cmd/cosmovisor/main.go b/cosmovisor/cmd/cosmovisor/main.go
index 628b7da4f7..04d4b6df97 100644
--- a/cosmovisor/cmd/cosmovisor/main.go
+++ b/cosmovisor/cmd/cosmovisor/main.go
@@ -4,8 +4,8 @@ import (
 	"context"
 	"os"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
-	cverrors "github.com/cosmos/cosmos-sdk/cosmovisor/errors"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
+	cverrors "github.com/agoric-labs/cosmos-sdk/cosmovisor/errors"
 )
 
 func main() {
diff --git a/cosmovisor/cmd/cosmovisor/run.go b/cosmovisor/cmd/cosmovisor/run.go
index f0917a3fc9..85a0ef2a0e 100644
--- a/cosmovisor/cmd/cosmovisor/run.go
+++ b/cosmovisor/cmd/cosmovisor/run.go
@@ -1,7 +1,7 @@
 package main
 
 import (
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
 	"github.com/rs/zerolog"
 	"github.com/spf13/cobra"
 )
diff --git a/cosmovisor/cmd/cosmovisor/version.go b/cosmovisor/cmd/cosmovisor/version.go
index de5005a721..9d672a880c 100644
--- a/cosmovisor/cmd/cosmovisor/version.go
+++ b/cosmovisor/cmd/cosmovisor/version.go
@@ -5,7 +5,7 @@ import (
 	"fmt"
 	"strings"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
 	"github.com/rs/zerolog"
 	"github.com/spf13/cobra"
 	tmcli "github.com/tendermint/tendermint/libs/cli"
diff --git a/cosmovisor/cmd/cosmovisor/version_test.go b/cosmovisor/cmd/cosmovisor/version_test.go
index f9dfa14014..ff7dc5a3f2 100644
--- a/cosmovisor/cmd/cosmovisor/version_test.go
+++ b/cosmovisor/cmd/cosmovisor/version_test.go
@@ -4,7 +4,7 @@ import (
 	"context"
 	"testing"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
 	"github.com/cosmos/cosmos-sdk/testutil"
 	"github.com/stretchr/testify/require"
 )
diff --git a/cosmovisor/go.mod b/cosmovisor/go.mod
index 1c3f2595da..b2cca1bc27 100644
--- a/cosmovisor/go.mod
+++ b/cosmovisor/go.mod
@@ -1,4 +1,4 @@
-module github.com/cosmos/cosmos-sdk/cosmovisor
+module github.com/agoric-labs/cosmos-sdk/cosmovisor
 
 go 1.18
 
diff --git a/cosmovisor/process_test.go b/cosmovisor/process_test.go
index 623634277b..b0845ad238 100644
--- a/cosmovisor/process_test.go
+++ b/cosmovisor/process_test.go
@@ -10,7 +10,7 @@ import (
 	"github.com/stretchr/testify/require"
 	"github.com/stretchr/testify/suite"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
 	upgradetypes "github.com/cosmos/cosmos-sdk/x/upgrade/types"
 )
 
diff --git a/cosmovisor/upgrade.go b/cosmovisor/upgrade.go
index 9667ffb5ed..f9b365f61f 100644
--- a/cosmovisor/upgrade.go
+++ b/cosmovisor/upgrade.go
@@ -61,26 +61,81 @@ func DownloadBinary(cfg *Config, info upgradetypes.Plan) error {
 	// download into the bin dir (works for one file)
 	binPath := cfg.UpgradeBin(info.Name)
 	err = getter.GetFile(binPath, url)
+	if err == nil {
+		return MarkExecutable(binPath)
+	}
 
 	// if this fails, let's see if it is a zipped directory
+	dirPath := cfg.UpgradeDir(info.Name)
+	err = getter.Get(dirPath, url)
 	if err != nil {
-		dirPath := cfg.UpgradeDir(info.Name)
-		err = getter.Get(dirPath, url)
-		if err != nil {
-			return err
+		return err
+	}
+	err = EnsureBinary(binPath)
+	if err == nil {
+		return nil // no need to MarkExecutable
+	}
+
+	// copy binary to binPath from dirPath if zipped directory
+	// doesn't contain bin directory to wrap the binary
+	err = copy.Copy(filepath.Join(dirPath, cfg.Name), binPath)
+	if err == nil {
+		return MarkExecutable(binPath)
+	}
+
+	// If there is only one entry in dirPath, then promote it to the upgradedir
+
+	// Clean up an empty bin directory.
+	_ = os.Remove(filepath.Join(dirPath, "bin"))
+
+	childName, err := GetOnlyChildName(dirPath)
+	if err != nil {
+		return err
+	}
+
+	// move aside the old dir and move the child to the old dir
+	tmpPath, err := os.MkdirTemp(filepath.Join(dirPath, ".."), "tmp*")
+	if err != nil {
+		return err
+	}
+	defer os.RemoveAll(tmpPath)
+	asidePath := filepath.Join(tmpPath, "old")
+	err = os.Rename(dirPath, asidePath)
+	if err != nil {
+		return err
+	}
+	err = os.Rename(filepath.Join(asidePath, childName), dirPath)
+	if err != nil {
+		return err
+	}
+	err = copy.Copy(filepath.Join(dirPath, cfg.Name), binPath)
+	if err == nil {
+		return MarkExecutable(binPath)
+	}
+	// future fallback attempts can be added here
+	return err
+}
+
+func GetOnlyChildName(path string) (string, error) {
+	dents, err := os.ReadDir(path)
+	if err != nil {
+		return "", err
+	}
+	childName := ""
+	for _, dent := range dents {
+		if dent.Name() == "." || dent.Name() == ".." {
+			continue
 		}
-		err = EnsureBinary(binPath)
-		// copy binary to binPath from dirPath if zipped directory don't contain bin directory to wrap the binary
-		if err != nil {
-			err = copy.Copy(filepath.Join(dirPath, cfg.Name), binPath)
-			if err != nil {
-				return err
-			}
+		if childName != "" {
+			return "", fmt.Errorf("more than one child entry in %s", path)
 		}
+		childName = dent.Name()
 	}
 
-	// if it is successful, let's ensure the binary is executable
-	return MarkExecutable(binPath)
+	if childName == "" {
+		return "", fmt.Errorf("no child entry in %s", path)
+	}
+	return childName, nil
 }
 
 // MarkExecutable will try to set the executable bits if not already set
diff --git a/cosmovisor/upgrade_test.go b/cosmovisor/upgrade_test.go
index 44a611222d..1665b756b3 100644
--- a/cosmovisor/upgrade_test.go
+++ b/cosmovisor/upgrade_test.go
@@ -17,7 +17,7 @@ import (
 	"github.com/stretchr/testify/require"
 	"github.com/stretchr/testify/suite"
 
-	"github.com/cosmos/cosmos-sdk/cosmovisor"
+	"github.com/agoric-labs/cosmos-sdk/cosmovisor"
 	upgradetypes "github.com/cosmos/cosmos-sdk/x/upgrade/types"
 )
 
diff --git a/crypto/keyring/keyring.go b/crypto/keyring/keyring.go
index 8d5c707f1a..91b1ca0f9a 100644
--- a/crypto/keyring/keyring.go
+++ b/crypto/keyring/keyring.go
@@ -719,6 +719,7 @@ func newRealPrompt(dir string, buf io.Reader) func(string) (string, error) {
 				continue
 			}
 
+			// nolint:gosec // ignore gosec G306: Expect WriteFile permissions to be 0600 or less
 			if err := os.WriteFile(dir+"/keyhash", passwordHash, 0o555); err != nil {
 				return "", err
 			}
@@ -855,7 +856,7 @@ func (ks keystore) MigrateAll() ([]*Record, error) {
 
 		rec, err := ks.migrate(key)
 		if err != nil {
-			fmt.Printf("migrate err for key %s: %q\n", key, err)
+			fmt.Fprintf(os.Stderr, "migrate err for key %s: %q\n", key, err)
 			continue
 		}
 
@@ -925,7 +926,7 @@ func (ks keystore) migrate(key string) (*Record, error) {
 		return nil, fmt.Errorf("unable to set keyring.Item, err: %w", err)
 	}
 
-	fmt.Printf("Successfully migrated key %s.\n", key)
+	fmt.Fprintf(os.Stderr, "Successfully migrated key %s.\n", key)
 
 	return k, nil
 }
diff --git a/docs/architecture/adr-049-state-sync-hooks.md b/docs/architecture/adr-049-state-sync-hooks.md
index e1616c2265..5cc2b684c4 100644
--- a/docs/architecture/adr-049-state-sync-hooks.md
+++ b/docs/architecture/adr-049-state-sync-hooks.md
@@ -3,10 +3,11 @@
 ## Changelog
 
 - Jan 19, 2022: Initial Draft
+- Apr 29, 2022: Safer extension snapshotter interface
 
 ## Status
 
-Draft, Under Implementation
+Implemented
 
 ## Abstract
 
@@ -107,11 +108,16 @@ func (m *Manager) RegisterExtensions(extensions ...types.ExtensionSnapshotter) e
 On top of the existing `Snapshotter` interface for the `multistore`, we add `ExtensionSnapshotter` interface for the extension snapshotters. Three more function signatures: `SnapshotFormat()`, `SupportedFormats()` and `SnapshotName()` are added to `ExtensionSnapshotter`.
 
 ```go
+// ExtensionPayloadReader read extension payloads,
+// it returns io.EOF when reached either end of stream or the extension boundaries.
+type ExtensionPayloadReader = func() ([]byte, error)
+
+// ExtensionPayloadWriter is a helper to write extension payloads to underlying stream.
+type ExtensionPayloadWriter = func([]byte) error
+
 // ExtensionSnapshotter is an extension Snapshotter that is appended to the snapshot stream.
 // ExtensionSnapshotter has an unique name and manages it's own internal formats.
 type ExtensionSnapshotter interface {
-	Snapshotter
-
 	// SnapshotName returns the name of snapshotter, it should be unique in the manager.
 	SnapshotName() string
 
@@ -120,6 +126,14 @@ type ExtensionSnapshotter interface {
 
 	// SupportedFormats returns a list of formats it can restore from.
 	SupportedFormats() []uint32
+
+	// SnapshotExtension writes extension payloads into the underlying protobuf stream.
+	SnapshotExtension(height uint64, payloadWriter ExtensionPayloadWriter) error
+
+	// RestoreExtension restores an extension state snapshot,
+	// the payload reader returns `io.EOF` when reached the extension boundaries.
+	RestoreExtension(height uint64, format uint32, payloadReader ExtensionPayloadReader) error
+
 }
 ```
 
diff --git a/go.mod b/go.mod
index 5659fe2c68..39e7adba01 100644
--- a/go.mod
+++ b/go.mod
@@ -51,21 +51,21 @@ require (
 	github.com/tendermint/tendermint v0.34.29
 	github.com/tendermint/tm-db v0.6.7
 	github.com/tidwall/btree v1.5.0
-	golang.org/x/crypto v0.7.0
+	golang.org/x/crypto v0.15.0
 	golang.org/x/exp v0.0.0-20230310171629-522b1b587ee0
-	google.golang.org/genproto v0.0.0-20230306155012-7f2fa6fef1f4
-	google.golang.org/grpc v1.54.0
-	google.golang.org/protobuf v1.30.0
+	google.golang.org/genproto/googleapis/api v0.0.0-20230711160842-782d3b101e98
+	google.golang.org/grpc v1.58.3
+	google.golang.org/protobuf v1.31.0
 	pgregory.net/rapid v0.4.7
 	sigs.k8s.io/yaml v1.3.0
 )
 
 require (
-	cloud.google.com/go v0.110.0 // indirect
-	cloud.google.com/go/compute v1.18.0 // indirect
+	cloud.google.com/go v0.110.4 // indirect
+	cloud.google.com/go/compute v1.21.0 // indirect
 	cloud.google.com/go/compute/metadata v0.2.3 // indirect
-	cloud.google.com/go/iam v0.12.0 // indirect
-	cloud.google.com/go/storage v1.28.1 // indirect
+	cloud.google.com/go/iam v1.1.1 // indirect
+	cloud.google.com/go/storage v1.30.1 // indirect
 	filippo.io/edwards25519 v1.0.0-rc.1 // indirect
 	github.com/99designs/go-keychain v0.0.0-20191008050251-8e49817e8af4 // indirect
 	github.com/ChainSafe/go-schnorrkel v1.0.0 // indirect
@@ -94,14 +94,15 @@ require (
 	github.com/go-kit/log v0.2.1 // indirect
 	github.com/go-logfmt/logfmt v0.5.1 // indirect
 	github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect
-	github.com/golang/glog v1.0.0 // indirect
+	github.com/golang/glog v1.1.0 // indirect
 	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
 	github.com/golang/snappy v0.0.4 // indirect
 	github.com/google/btree v1.1.2 // indirect
 	github.com/google/go-cmp v0.5.9 // indirect
 	github.com/google/orderedcode v0.0.1 // indirect
+	github.com/google/s2a-go v0.1.4 // indirect
 	github.com/googleapis/enterprise-certificate-proxy v0.2.3 // indirect
-	github.com/googleapis/gax-go/v2 v2.7.0 // indirect
+	github.com/googleapis/gax-go/v2 v2.11.0 // indirect
 	github.com/gorilla/websocket v1.5.0 // indirect
 	github.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c // indirect
 	github.com/gtank/merlin v0.1.1 // indirect
@@ -146,14 +147,17 @@ require (
 	github.com/zondax/ledger-go v0.14.3 // indirect
 	go.etcd.io/bbolt v1.3.6 // indirect
 	go.opencensus.io v0.24.0 // indirect
-	golang.org/x/net v0.9.0 // indirect
-	golang.org/x/oauth2 v0.5.0 // indirect
-	golang.org/x/sys v0.7.0 // indirect
-	golang.org/x/term v0.7.0 // indirect
-	golang.org/x/text v0.9.0 // indirect
+	golang.org/x/net v0.18.0 // indirect
+	golang.org/x/oauth2 v0.10.0 // indirect
+	golang.org/x/sync v0.3.0 // indirect
+	golang.org/x/sys v0.14.0 // indirect
+	golang.org/x/term v0.14.0 // indirect
+	golang.org/x/text v0.14.0 // indirect
 	golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 // indirect
-	google.golang.org/api v0.110.0 // indirect
+	google.golang.org/api v0.126.0 // indirect
 	google.golang.org/appengine v1.6.7 // indirect
+	google.golang.org/genproto v0.0.0-20230711160842-782d3b101e98 // indirect
+	google.golang.org/genproto/googleapis/rpc v0.0.0-20230711160842-782d3b101e98 // indirect
 	gopkg.in/ini.v1 v1.67.0 // indirect
 	gopkg.in/yaml.v2 v2.4.0 // indirect
 	gopkg.in/yaml.v3 v3.0.1 // indirect
@@ -163,6 +167,8 @@ require (
 replace (
 	// use cosmos fork of keyring
 	github.com/99designs/keyring => github.com/cosmos/keyring v1.2.0
+	// replace broken iavl
+	github.com/cosmos/iavl => github.com/cosmos/iavl v0.19.7
 	// dgrijalva/jwt-go is deprecated and doesn't receive security updates.
 	// TODO: remove it: https://github.com/cosmos/cosmos-sdk/issues/13134
 	github.com/dgrijalva/jwt-go => github.com/golang-jwt/jwt/v4 v4.4.2
@@ -174,7 +180,7 @@ replace (
 	// replace broken goleveldb.
 	github.com/syndtr/goleveldb => github.com/syndtr/goleveldb v1.0.1-0.20210819022825-2ae1ddf74ef7
 	// use cometbft
-	github.com/tendermint/tendermint => github.com/cometbft/cometbft v0.34.29
+	github.com/tendermint/tendermint => github.com/agoric-labs/cometbft v0.34.30-alpha.agoric.1
 )
 
 retract (
diff --git a/go.sum b/go.sum
index 4bd9a7cadf..7d635194db 100644
--- a/go.sum
+++ b/go.sum
@@ -19,8 +19,8 @@ cloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHOb
 cloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=
 cloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=
 cloud.google.com/go v0.75.0/go.mod h1:VGuuCn7PG0dwsd5XPVm2Mm3wlh3EL55/79EKB6hlPTY=
-cloud.google.com/go v0.110.0 h1:Zc8gqp3+a9/Eyph2KDmcGaPtbKRIoqq4YTlL4NMD0Ys=
-cloud.google.com/go v0.110.0/go.mod h1:SJnCLqQ0FCFGSZMUNUf84MV3Aia54kn7pi8st7tMzaY=
+cloud.google.com/go v0.110.4 h1:1JYyxKMN9hd5dR2MYTPWkGUgcoxVVhg0LKNKEo0qvmk=
+cloud.google.com/go v0.110.4/go.mod h1:+EYjdK8e5RME/VY/qLCAtuyALQ9q67dvuum8i+H5xsI=
 cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
 cloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=
 cloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=
@@ -28,15 +28,14 @@ cloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUM
 cloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=
 cloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=
 cloud.google.com/go/bigtable v1.2.0/go.mod h1:JcVAOl45lrTmQfLj7T6TxyMzIN/3FGGcFm+2xVAli2o=
-cloud.google.com/go/compute v1.18.0 h1:FEigFqoDbys2cvFkZ9Fjq4gnHBP55anJ0yQyau2f9oY=
-cloud.google.com/go/compute v1.18.0/go.mod h1:1X7yHxec2Ga+Ss6jPyjxRxpu2uu7PLgsOVXvgU0yacs=
+cloud.google.com/go/compute v1.21.0 h1:JNBsyXVoOoNJtTQcnEY5uYpZIbeCTYIeDe0Xh1bySMk=
+cloud.google.com/go/compute v1.21.0/go.mod h1:4tCnrn48xsqlwSAiLf1HXMQk8CONslYbdiEZc9FEIbM=
 cloud.google.com/go/compute/metadata v0.2.3 h1:mg4jlk7mCAj6xXp9UJ4fjI9VUI5rubuGBW5aJ7UnBMY=
 cloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=
 cloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=
 cloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=
-cloud.google.com/go/iam v0.12.0 h1:DRtTY29b75ciH6Ov1PHb4/iat2CLCvrOm40Q0a6DFpE=
-cloud.google.com/go/iam v0.12.0/go.mod h1:knyHGviacl11zrtZUoDuYpDgLjvr28sLQaG0YB2GYAY=
-cloud.google.com/go/longrunning v0.4.1 h1:v+yFJOfKC3yZdY6ZUI933pIYdhyhV8S3NpWrXWmg7jM=
+cloud.google.com/go/iam v1.1.1 h1:lW7fzj15aVIXYHREOqjRBV9PsH0Z6u8Y46a1YGvQP4Y=
+cloud.google.com/go/iam v1.1.1/go.mod h1:A5avdyVL2tCppe4unb0951eI9jreack+RJ0/d+KUZOU=
 cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=
 cloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=
 cloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=
@@ -47,8 +46,8 @@ cloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohl
 cloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=
 cloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=
 cloud.google.com/go/storage v1.14.0/go.mod h1:GrKmX003DSIwi9o29oFT7YDnHYwZoctc3fOKtUw0Xmo=
-cloud.google.com/go/storage v1.28.1 h1:F5QDG5ChchaAVQhINh24U99OWHURqrW8OmQcGKXcbgI=
-cloud.google.com/go/storage v1.28.1/go.mod h1:Qnisd4CqDdo6BGs2AD5LLnEsmSQ80wQ5ogcBBKhU86Y=
+cloud.google.com/go/storage v1.30.1 h1:uOdMxAs8HExqBlnLtnQyP0YkvbiDpdGShGKtx6U/oNM=
+cloud.google.com/go/storage v1.30.1/go.mod h1:NfxhC0UJE1aXSx7CIIbCf7y9HKT7BiccwkR7+P7gN8E=
 collectd.org v0.3.0/go.mod h1:A/8DzQBkF6abtvrT2j/AU/4tiBgJWYyh0y/oB/4MlWE=
 cosmossdk.io/errors v1.0.0-beta.7 h1:gypHW76pTQGVnHKo6QBkb4yFOJjC+sUGRc5Al3Odj1w=
 cosmossdk.io/errors v1.0.0-beta.7/go.mod h1:mz6FQMJRku4bY7aqS/Gwfcmr/ue91roMEKAmDUDpBfE=
@@ -89,6 +88,8 @@ github.com/Zilliqa/gozilliqa-sdk v1.2.1-0.20201201074141-dd0ecada1be6/go.mod h1:
 github.com/adlio/schema v1.3.3 h1:oBJn8I02PyTB466pZO1UZEn1TV5XLlifBSyMrmHl/1I=
 github.com/aead/siphash v1.0.1/go.mod h1:Nywa3cDsYNNK3gaciGTWPwHt0wlpNV15vwmswBAUSII=
 github.com/afex/hystrix-go v0.0.0-20180502004556-fa1af6a1f4f5/go.mod h1:SkGFH1ia65gfNATL8TAiHDNxPzPdmEL5uirI2Uyuz6c=
+github.com/agoric-labs/cometbft v0.34.30-alpha.agoric.1 h1:tqCNL72pQXdUmBzgv1md5SN2U3K/PaYQ4qZ5pFv8v6w=
+github.com/agoric-labs/cometbft v0.34.30-alpha.agoric.1/go.mod h1:myvkihZD8eg9jKE3WFaugkNoL5nvEqlP7Jbjg98pCek=
 github.com/ajstarks/svgo v0.0.0-20180226025133-644b8db467af/go.mod h1:K08gAheRH3/J6wwsYMMT4xOr94bZjxIelGM0+d/wbFw=
 github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
 github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
@@ -193,6 +194,10 @@ github.com/cloudflare/cloudflare-go v0.14.0/go.mod h1:EnwdgGMaFOruiPZRFSgn+TsQ3h
 github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
 github.com/cncf/udpa/go v0.0.0-20200629203442-efcf912fb354/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
 github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
+github.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
+github.com/cncf/xds/go v0.0.0-20210805033703-aa0b78936158/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
+github.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
+github.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
 github.com/cockroachdb/apd/v2 v2.0.2 h1:weh8u7Cneje73dDh+2tEVLUvyBc89iwepWCD8b8034E=
 github.com/cockroachdb/apd/v2 v2.0.2/go.mod h1:DDxRlzC2lo3/vSlmSoS7JkqbbrARPuFOGr0B9pvN3Gw=
 github.com/cockroachdb/datadriven v0.0.0-20190809214429-80d97fb3cbaa/go.mod h1:zn76sxSg3SzpJ0PPJaLDCu+Bu0Lg3sKTORVIj19EIF8=
@@ -200,8 +205,6 @@ github.com/codahale/hdrhistogram v0.0.0-20161010025455-3a0bb77429bd/go.mod h1:sE
 github.com/coinbase/kryptology v1.8.0/go.mod h1:RYXOAPdzOGUe3qlSFkMGn58i3xUA8hmxYHksuq+8ciI=
 github.com/coinbase/rosetta-sdk-go v0.7.9 h1:lqllBjMnazTjIqYrOGv8h8jxjg9+hJazIGZr9ZvoCcA=
 github.com/coinbase/rosetta-sdk-go v0.7.9/go.mod h1:0/knutI7XGVqXmmH4OQD8OckFrbQ8yMsUZTG7FXCR2M=
-github.com/cometbft/cometbft v0.34.29 h1:Q4FqMevP9du2pOgryZJHpDV2eA6jg/kMYxBj9ZTY6VQ=
-github.com/cometbft/cometbft v0.34.29/go.mod h1:L9shMfbkZ8B+7JlwANEr+NZbBcn+hBpwdbeYvA5rLCw=
 github.com/cometbft/cometbft-db v0.7.0 h1:uBjbrBx4QzU0zOEnU8KxoDl18dMNgDh+zZRUE0ucsbo=
 github.com/cometbft/cometbft-db v0.7.0/go.mod h1:yiKJIm2WKrt6x8Cyxtq9YTEcIMPcEe4XPxhgX59Fzf0=
 github.com/confio/ics23/go v0.9.0 h1:cWs+wdbS2KRPZezoaaj+qBleXgUk5WOQFMP3CQFGTr4=
@@ -228,8 +231,8 @@ github.com/cosmos/go-bip39 v1.0.0 h1:pcomnQdrdH22njcAatO0yWojsUnCO3y2tNoV1cb6hHY
 github.com/cosmos/go-bip39 v1.0.0/go.mod h1:RNJv0H/pOIVgxw6KS7QeX2a0Uo0aKUlfhZ4xuwvCdJw=
 github.com/cosmos/gorocksdb v1.2.0 h1:d0l3jJG8M4hBouIZq0mDUHZ+zjOx044J3nGRskwTb4Y=
 github.com/cosmos/gorocksdb v1.2.0/go.mod h1:aaKvKItm514hKfNJpUJXnnOWeBnk2GL4+Qw9NHizILw=
-github.com/cosmos/iavl v0.19.6 h1:XY78yEeNPrEYyNCKlqr9chrwoeSDJ0bV2VjocTk//OU=
-github.com/cosmos/iavl v0.19.6/go.mod h1:X9PKD3J0iFxdmgNLa7b2LYWdsGd90ToV5cAONApkEPw=
+github.com/cosmos/iavl v0.19.7 h1:ij32FaEnwxfEurtK0QKDNhTWFnz6NUmrI5gky/WnoY0=
+github.com/cosmos/iavl v0.19.7/go.mod h1:X9PKD3J0iFxdmgNLa7b2LYWdsGd90ToV5cAONApkEPw=
 github.com/cosmos/keyring v1.2.0 h1:8C1lBP9xhImmIabyXW4c3vFjjLiBdGCmfLUfeZlV1Yo=
 github.com/cosmos/keyring v1.2.0/go.mod h1:fc+wB5KTk9wQ9sDx0kFXB3A0MaeGHM9AwRStKOQ5vOA=
 github.com/cosmos/ledger-cosmos-go v0.12.4 h1:drvWt+GJP7Aiw550yeb3ON/zsrgW0jgh5saFCr7pDnw=
@@ -295,6 +298,7 @@ github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.m
 github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
 github.com/envoyproxy/go-control-plane v0.9.7/go.mod h1:cwu0lG7PUMfa9snN8LXBig5ynNVH9qI8YYLbd1fK2po=
 github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
+github.com/envoyproxy/go-control-plane v0.9.10-0.20210907150352-cf90f659a021/go.mod h1:AFq3mo9L8Lqqiid3OhADV3RfLJnjiw63cSpi+fDTRC0=
 github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
 github.com/ethereum/go-ethereum v1.10.17/go.mod h1:Lt5WzjM07XlXc95YzrhosmR4J9Ahd6X2wyEV2SvGhk0=
 github.com/facebookgo/ensure v0.0.0-20200202191622-63f1cf65ac4c h1:8ISkoahWXwZR41ois5lSJBSVw4D0OV19Ht/JSTzvSv0=
@@ -374,8 +378,8 @@ github.com/golang-jwt/jwt/v4 v4.4.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w
 github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=
 github.com/golang/geo v0.0.0-20190916061304-5b978397cfec/go.mod h1:QZ0nwyI2jOfgRAoBvP+ab5aRr7c9x7lhGEJrKvBwjWI=
 github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
-github.com/golang/glog v1.0.0 h1:nfP3RFugxnNRyKgeWd4oI1nYvXpxrx8ck8ZrcizshdQ=
-github.com/golang/glog v1.0.0/go.mod h1:EWib/APOK0SL3dFbYqvxE3UYd8E6s1ouQ7iEp/0LWV4=
+github.com/golang/glog v1.1.0 h1:/d3pCKDPWNnvIWe0vVUpNP32qc8U3PDVxySP/y360qE=
+github.com/golang/glog v1.1.0/go.mod h1:pfYeQZ3JWZoXTV5sFc986z3HTpwQs9At6P4ImfuP3NQ=
 github.com/golang/groupcache v0.0.0-20160516000752-02826c3e7903/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
 github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
 github.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
@@ -407,6 +411,7 @@ github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QD
 github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
 github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
 github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
+github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
 github.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=
 github.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
 github.com/golang/snappy v0.0.0-20180518054509-2e65f85255db/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=
@@ -455,6 +460,8 @@ github.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLe
 github.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
 github.com/google/pprof v0.0.0-20201218002935-b9804c9f04c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
 github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
+github.com/google/s2a-go v0.1.4 h1:1kZ/sQM3srePvKs3tXAvQzo66XfcReoqFpIpIccE7Oc=
+github.com/google/s2a-go v0.1.4/go.mod h1:Ej+mSEMGRnqRzjc7VtF+jdBwYG5fuJfiZ8ELkjEwM0A=
 github.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
 github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
 github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
@@ -465,8 +472,8 @@ github.com/googleapis/enterprise-certificate-proxy v0.2.3 h1:yk9/cqRKtT9wXZSsRH9
 github.com/googleapis/enterprise-certificate-proxy v0.2.3/go.mod h1:AwSRAtLfXpU5Nm3pW+v7rGDHp09LsPtGY9MduiEsR9k=
 github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
 github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=
-github.com/googleapis/gax-go/v2 v2.7.0 h1:IcsPKeInNvYi7eqSaDjiZqDDKu5rsmunY0Y1YupQSSQ=
-github.com/googleapis/gax-go/v2 v2.7.0/go.mod h1:TEop28CZZQ2y+c0VxMUmu1lV+fQx57QpBWsYpwqHJx8=
+github.com/googleapis/gax-go/v2 v2.11.0 h1:9V9PWXEsWnPpQhu/PeQIkS4eGzMlTLGgt80cUUI8Ki4=
+github.com/googleapis/gax-go/v2 v2.11.0/go.mod h1:DxmR61SGKkGLa2xigwuZIQpkCI2S5iydzRfb3peWZJI=
 github.com/googleapis/google-cloud-go-testing v0.0.0-20200911160855-bcd43fbb19e8/go.mod h1:dvDLG8qkwmyD9a/MJJN3XJcT3xFxOKAvTZGvuZmac9g=
 github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
 github.com/gordonklaus/ineffassign v0.0.0-20200309095847-7953dde2c7bf/go.mod h1:cuNKsD1zp2v6XfE/orVX2QE1LC+i254ceGcVeDT3pTU=
@@ -986,6 +993,7 @@ go.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
 go.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=
 go.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=
 go.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=
+go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
 go.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
 go.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
 go.uber.org/atomic v1.5.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=
@@ -1020,9 +1028,10 @@ golang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm
 golang.org/x/crypto v0.0.0-20210711020723-a769d52b0f97/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
 golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
 golang.org/x/crypto v0.0.0-20211108221036-ceb1ce70b4fa/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
+golang.org/x/crypto v0.0.0-20220314234659-1baeb1ce4c0b/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
 golang.org/x/crypto v0.5.0/go.mod h1:NK/OQwhpMQP3MwtdjgLlYHnH9ebylxKWv3e0fK+mkQU=
-golang.org/x/crypto v0.7.0 h1:AvwMYaRytfdeVt3u6mLaxYtErKYjxA2OXjJ1HHq6t3A=
-golang.org/x/crypto v0.7.0/go.mod h1:pYwdfH91IfpZVANVyUOhSIPZaFoJGxTFbZhFTx+dXZU=
+golang.org/x/crypto v0.15.0 h1:frVn1TEaCEaZcn3Tmd7Y2b5KKPaZ+I32Q2OA3kYp5TA=
+golang.org/x/crypto v0.15.0/go.mod h1:4ChreQoLWfG3xLDer1WdlH5NdlQ3+mwnQq1YTKY+72g=
 golang.org/x/exp v0.0.0-20180321215751-8460e604b9de/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20180807140117-3d87b88a115f/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
@@ -1118,11 +1127,12 @@ golang.org/x/net v0.0.0-20210610132358-84b48f89b13b/go.mod h1:9nx3DQGgdP8bBQD5qx
 golang.org/x/net v0.0.0-20210614182718-04defd469f4e/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20210805182204-aaa1db679c0d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20211015210444-4f30a5c0130f/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
+golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
 golang.org/x/net v0.5.0/go.mod h1:DivGGAXEgPSlEBzxGzZI+ZLohi+xUj054jfeKui00ws=
 golang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
-golang.org/x/net v0.9.0 h1:aWJ/m6xSmxWBx+V0XRHTlrYrPG56jKsLdTFmsSsCzOM=
-golang.org/x/net v0.9.0/go.mod h1:d48xBJpPfHeWQsugry2m+kC02ZBRGRgulfHnEXEuWns=
+golang.org/x/net v0.18.0 h1:mIYleuAkSbHh0tCv7RvjL3F6ZVbLjq4+R7zbOn3Kokg=
+golang.org/x/net v0.18.0/go.mod h1:/czyP5RqHAH4odGYxBJ1qz0+CE5WZ+2j1YgoEo8F2jQ=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
 golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
 golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
@@ -1132,8 +1142,8 @@ golang.org/x/oauth2 v0.0.0-20200902213428-5d25da1a8d43/go.mod h1:KelEdhl1UZF7XfJ
 golang.org/x/oauth2 v0.0.0-20201109201403-9fd604954f58/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
 golang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
 golang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
-golang.org/x/oauth2 v0.5.0 h1:HuArIo48skDwlrvM3sEdHXElYslAMsf3KwRkkW4MC4s=
-golang.org/x/oauth2 v0.5.0/go.mod h1:9/XBHVqLaWO3/BRHs5jbpYCnOZVjj5V0ndyaAM7KB4I=
+golang.org/x/oauth2 v0.10.0 h1:zHCpF2Khkwy4mMB4bv0U37YtJdTGW8jI0glAApi0Kh8=
+golang.org/x/oauth2 v0.10.0/go.mod h1:kTpgurOux7LqtuxjuyZa4Gj2gdezIt/jQtGnNFfypQI=
 golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
@@ -1146,6 +1156,8 @@ golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJ
 golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.3.0 h1:ftCYgMx6zT/asHUrPw8BLLscYtGznsLAnjq5RH9P66E=
+golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sys v0.0.0-20180823144017-11551d06cbcc/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
@@ -1230,15 +1242,15 @@ golang.org/x/sys v0.0.0-20220908164124-27713097b956/go.mod h1:oPkhp1MJrh7nUepCBc
 golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-golang.org/x/sys v0.7.0 h1:3jlCCIQZPdOYu1h8BkNvLz8Kgwtae2cagcG/VamtZRU=
-golang.org/x/sys v0.7.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.14.0 h1:Vz7Qs629MkJkGyHxUlRHizWJRG2j8fbQKjELVSNhy7Q=
+golang.org/x/sys v0.14.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
 golang.org/x/term v0.0.0-20201117132131-f5c789dd3221/go.mod h1:Nr5EML6q2oocZ2LXRh80K7BxOlk5/8JxuGnuhpl+muw=
 golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
 golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
 golang.org/x/term v0.4.0/go.mod h1:9P2UbLfCdcvo3p/nzKvsmas4TnlujnuoV9hGgYzW1lQ=
 golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
-golang.org/x/term v0.7.0 h1:BEvjmm5fURWqcfbSKTdpkDXYBrUS1c0m8agp14W48vQ=
-golang.org/x/term v0.7.0/go.mod h1:P32HKFT3hSsZrRxla30E9HqToFYAQPCMs/zFMBUFqPY=
+golang.org/x/term v0.14.0 h1:LGK9IlZ8T9jvdy6cTdfKUCltatMFOehAQo9SRC46UQ8=
+golang.org/x/term v0.14.0/go.mod h1:TySc+nGkYR6qt8km8wUhuFRTVSMIX3XPR58y2lC8vww=
 golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
@@ -1251,8 +1263,8 @@ golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
 golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
 golang.org/x/text v0.6.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
 golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
-golang.org/x/text v0.9.0 h1:2sjJmO8cDvYveuX97RDLsxlyUxLl+GHoLxBiRdHllBE=
-golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
+golang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=
+golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
 golang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
@@ -1355,8 +1367,8 @@ google.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz513
 google.golang.org/api v0.35.0/go.mod h1:/XrVsuzM0rZmrsbjJutiuftIzeuTQcEeaYcSk/mQ1dg=
 google.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34qYtE=
 google.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=
-google.golang.org/api v0.110.0 h1:l+rh0KYUooe9JGbGVx71tbFo4SMbMTXK3I3ia2QSEeU=
-google.golang.org/api v0.110.0/go.mod h1:7FC4Vvx1Mooxh8C5HWjzZHcavuS2f6pmJpZx60ca7iI=
+google.golang.org/api v0.126.0 h1:q4GJq+cAdMAC7XP7njvQ4tvohGLiSlytuL4BQxbIZ+o=
+google.golang.org/api v0.126.0/go.mod h1:mBwVAtz+87bEN6CbA1GtZPDOqY2R5ONPqJeIlvyo4Aw=
 google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
 google.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
 google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
@@ -1410,8 +1422,12 @@ google.golang.org/genproto v0.0.0-20201214200347-8c77b98c765d/go.mod h1:FWY/as6D
 google.golang.org/genproto v0.0.0-20210108203827-ffc7fda8c3d7/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
 google.golang.org/genproto v0.0.0-20210126160654-44e461bb6506/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
 google.golang.org/genproto v0.0.0-20210226172003-ab064af71705/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
-google.golang.org/genproto v0.0.0-20230306155012-7f2fa6fef1f4 h1:DdoeryqhaXp1LtT/emMP1BRJPHHKFi5akj/nbx/zNTA=
-google.golang.org/genproto v0.0.0-20230306155012-7f2fa6fef1f4/go.mod h1:NWraEVixdDnqcqQ30jipen1STv2r/n24Wb7twVTGR4s=
+google.golang.org/genproto v0.0.0-20230711160842-782d3b101e98 h1:Z0hjGZePRE0ZBWotvtrwxFNrNE9CUAGtplaDK5NNI/g=
+google.golang.org/genproto v0.0.0-20230711160842-782d3b101e98/go.mod h1:S7mY02OqCJTD0E1OiQy1F72PWFB4bZJ87cAtLPYgDR0=
+google.golang.org/genproto/googleapis/api v0.0.0-20230711160842-782d3b101e98 h1:FmF5cCW94Ij59cfpoLiwTgodWmm60eEV0CjlsVg2fuw=
+google.golang.org/genproto/googleapis/api v0.0.0-20230711160842-782d3b101e98/go.mod h1:rsr7RhLuwsDKL7RmgDDCUc6yaGr1iqceVb5Wv6f6YvQ=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20230711160842-782d3b101e98 h1:bVf09lpb+OJbByTj913DRJioFFAjf/ZGxEz7MajTp2U=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20230711160842-782d3b101e98/go.mod h1:TUfxEVdsvPg18p6AslUXFoLdpED4oBnGwyqk3dV1XzM=
 google.golang.org/grpc v1.17.0/go.mod h1:6QZJwpn2B+Zp71q/5VxRsJ6NXXVCE5NRUHRo+f3cWCs=
 google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
 google.golang.org/grpc v1.19.1/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
@@ -1436,8 +1452,10 @@ google.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTp
 google.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=
 google.golang.org/grpc v1.34.0/go.mod h1:WotjhfgOW/POjDeRt8vscBtXq+2VjORFy659qA51WJ8=
 google.golang.org/grpc v1.35.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
-google.golang.org/grpc v1.54.0 h1:EhTqbhiYeixwWQtAEZAxmV9MGqcjEU2mFx52xCzNyag=
-google.golang.org/grpc v1.54.0/go.mod h1:PUSEXI6iWghWaB6lXM4knEgpJNu2qUcKfDtNci3EC2g=
+google.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
+google.golang.org/grpc v1.45.0/go.mod h1:lN7owxKUQEqMfSyQikvvk5tf/6zMPsrK+ONuO11+0rQ=
+google.golang.org/grpc v1.58.3 h1:BjnpXut1btbtgN/6sp+brB2Kbm2LjNXnidYujAVbSoQ=
+google.golang.org/grpc v1.58.3/go.mod h1:tgX3ZQDlNJGU96V6yHh1T/JeoBQ2TXdr43YbYSsCJk0=
 google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
 google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
 google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
@@ -1453,8 +1471,8 @@ google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp0
 google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
 google.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
 google.golang.org/protobuf v1.28.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
-google.golang.org/protobuf v1.30.0 h1:kPPoIgf3TsEvrm0PFe15JQ+570QVxYzEvvHqChK+cng=
-google.golang.org/protobuf v1.30.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
+google.golang.org/protobuf v1.31.0 h1:g0LDEJHgrBl9N9r17Ru3sqWhkIx2NB67okBHPwC7hs8=
+google.golang.org/protobuf v1.31.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
 gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
diff --git a/proto/cosmos/vesting/v1beta1/tx.proto b/proto/cosmos/vesting/v1beta1/tx.proto
index 732fe12536..52b5e68a11 100644
--- a/proto/cosmos/vesting/v1beta1/tx.proto
+++ b/proto/cosmos/vesting/v1beta1/tx.proto
@@ -25,6 +25,13 @@ service Msg {
   //
   // Since: cosmos-sdk 0.46
   rpc CreatePeriodicVestingAccount(MsgCreatePeriodicVestingAccount) returns (MsgCreatePeriodicVestingAccountResponse);
+  // CreateClawbackVestingAccount defines a method that enables creating a
+  // vesting account that is subject to clawback.
+  rpc CreateClawbackVestingAccount(MsgCreateClawbackVestingAccount) returns (MsgCreateClawbackVestingAccountResponse);
+  // Clawback removes the unvested tokens from a ClawbackVestingAccount.
+  rpc Clawback(MsgClawback) returns (MsgClawbackResponse);
+  // ReturnGrants returns vesting grants to the funder.
+  rpc ReturnGrants(MsgReturnGrants) returns (MsgReturnGrantsResponse);
 }
 
 // MsgCreateVestingAccount defines a message that enables creating a vesting
@@ -79,6 +86,10 @@ message MsgCreatePeriodicVestingAccount {
   // start of vesting as unix time (in seconds).
   int64           start_time      = 3;
   repeated Period vesting_periods = 4 [(gogoproto.nullable) = false];
+  // If true, merge this new grant into an existing PeriodicVestingAccount,
+  // or create it if it does not exist. If false, creates a new account,
+  // or fails if an account already exists
+  bool merge = 5;
 }
 
 // MsgCreateVestingAccountResponse defines the Msg/CreatePeriodicVestingAccount
@@ -86,3 +97,53 @@ message MsgCreatePeriodicVestingAccount {
 //
 // Since: cosmos-sdk 0.46
 message MsgCreatePeriodicVestingAccountResponse {}
+
+// MsgCreateClawbackVestingAccount defines a message that enables creating a ClawbackVestingAccount.
+message MsgCreateClawbackVestingAccount {
+  option (gogoproto.equal) = false;
+
+  // Address of the account providing the funds, which must also sign the request.
+  string from_address = 1 [(gogoproto.moretags) = "yaml:\"from_address\""];
+  // Address of the account to receive the funds.
+  string to_address = 2 [(gogoproto.moretags) = "yaml:\"to_address\""];
+  // Start time of the vesting. Periods start relative to this time.
+  int64 start_time = 3 [(gogoproto.moretags) = "yaml:\"start_time\""];
+  // Unlocking events as a sequence of durations and amounts, starting relative to start_time.
+  repeated Period lockup_periods = 4 [(gogoproto.nullable) = false];
+  // Vesting events as a sequence of durations and amounts, starting relative to start_time.
+  repeated Period vesting_periods = 5 [(gogoproto.nullable) = false];
+  // If true, merge this new grant into an existing ClawbackVestingAccount,
+  // or create it if it does not exist. If false, creates a new account.
+  // New grants to an existing account must be from the same from_address.
+  bool merge = 6;
+}
+
+// MsgCreateClawbackVestingAccountResponse defines the MsgCreateClawbackVestingAccount response type.
+message MsgCreateClawbackVestingAccountResponse {}
+
+// MsgClawback defines a message that removes unvested tokens from a ClawbackVestingAccount.
+message MsgClawback {
+  // funder_address is the address which funded the account
+  string funder_address = 1;
+  // address is the address of the ClawbackVestingAccount to claw back from.
+  string address = 2;
+  // dest_address specifies where the clawed-back tokens should be transferred.
+  // If empty, the tokens will be transferred back to the original funder of the account.
+  string dest_address = 3;
+}
+
+// MsgClawbackResponse defines the MsgClawback response type.
+message MsgClawbackResponse {}
+
+// MsgReturnGrants defines a message for a grantee to return all granted assets,
+// including delegated, undelegated and unbonding, vested and unvested,
+// are transferred to the original funder of the account. Might not be complete if
+// some vested assets have been transferred out of the account. Currently only applies to
+// ClawbackVesting accounts.
+message MsgReturnGrants {
+  // address is the address of the grantee account returning the grant.
+  string address = 1;
+}
+
+// MsgReturnGrantsResponse defines the ReturnGrants response type.
+message MsgReturnGrantsResponse {}
diff --git a/proto/cosmos/vesting/v1beta1/vesting.proto b/proto/cosmos/vesting/v1beta1/vesting.proto
index d5c1c9e583..8c2687096a 100644
--- a/proto/cosmos/vesting/v1beta1/vesting.proto
+++ b/proto/cosmos/vesting/v1beta1/vesting.proto
@@ -46,6 +46,9 @@ message DelayedVestingAccount {
 }
 
 // Period defines a length of time and amount of coins that will vest.
+// A sequence of periods defines a sequence of vesting events, with the
+// first period relative to an externally-provided start time,
+// and subsequent periods relatie to their predecessor.
 message Period {
   option (gogoproto.goproto_stringer) = false;
 
@@ -77,3 +80,22 @@ message PermanentLockedAccount {
 
   BaseVestingAccount base_vesting_account = 1 [(gogoproto.embed) = true];
 }
+
+// ClawbackVestingAccount implements the VestingAccount interface. It provides
+// an account that can hold contributions subject to "lockup" (like a
+// PeriodicVestingAccount), or vesting which is subject to clawback
+// of unvested tokens, or a combination (tokens vest, but are still locked).
+message ClawbackVestingAccount {
+  option (gogoproto.goproto_getters)  = false;
+  option (gogoproto.goproto_stringer) = false;
+
+  BaseVestingAccount base_vesting_account = 1 [(gogoproto.embed) = true];
+
+  // funder_address specifies the account which can perform clawback.
+  string funder_address = 2 [(gogoproto.moretags) = "yaml:\"funder_address\""];
+  int64 start_time = 3 [(gogoproto.moretags) = "yaml:\"start_time\""];
+  // unlocking schedule relative to the BaseVestingAccount start_time.
+  repeated Period lockup_periods = 4 [(gogoproto.moretags) = "yaml:\"lockup_periods\"", (gogoproto.nullable) = false];
+  // vesting (i.e. immunity from clawback) schedule relative to the BaseVestingAccount start_time.
+  repeated Period vesting_periods = 5 [(gogoproto.moretags) = "yaml:\"vesting_periods\"", (gogoproto.nullable) = false];
+}
diff --git a/server/config/config.go b/server/config/config.go
index 40087b1496..ee57c6e048 100644
--- a/server/config/config.go
+++ b/server/config/config.go
@@ -14,9 +14,18 @@ import (
 	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
 )
 
+// [AGORIC] Valid values for FlagAbciClientType
+const (
+	AbciClientTypeCommitting = "committing"
+	AbciClientTypeLocal      = "local"
+)
+
 const (
 	defaultMinGasPrices = ""
 
+	// DefaultABCIClientType defines the default ABCI client type to use with cometbft.
+	DefaultABCIClientType = AbciClientTypeCommitting // [AGORIC]
+
 	// DefaultAPIAddress defines the default address to bind the API server to.
 	DefaultAPIAddress = "tcp://0.0.0.0:1317"
 
@@ -94,6 +103,12 @@ type BaseConfig struct {
 	// IAVLLazyLoading enable/disable the lazy loading of iavl store.
 	IAVLLazyLoading bool `mapstructure:"iavl-lazy-loading"`
 
+	// ABCIClientType selects the type of ABCI client.
+	// Valid settings are "committing" (default) or "local".
+	// The committing client allows greater query parallelism,
+	// but the local client is more defensive.
+	ABCIClientType string `mapstructure:"abci-client-type"`
+
 	// AppDBBackend defines the type of Database to use for the application and snapshots databases.
 	// An empty string indicates that the Tendermint config's DBBackend value should be used.
 	AppDBBackend string `mapstructure:"app-db-backend"`
@@ -289,6 +304,7 @@ func DefaultConfig() *Config {
 			IAVLCacheSize:       781250, // 50 MB
 			IAVLDisableFastNode: false,
 			IAVLLazyLoading:     false,
+			ABCIClientType:      DefaultABCIClientType, // [AGORIC]
 			AppDBBackend:        "",
 		},
 		Telemetry: telemetry.Config{
diff --git a/server/config/toml.go b/server/config/toml.go
index 920201b330..1c47ff1a2e 100644
--- a/server/config/toml.go
+++ b/server/config/toml.go
@@ -82,6 +82,12 @@ iavl-disable-fastnode = {{ .BaseConfig.IAVLDisableFastNode }}
 # Default is false.
 iavl-lazy-loading = {{ .BaseConfig.IAVLLazyLoading }}
 
+# ABCIClientType selects the type of ABCI client.
+# Valid settings are "committing" (default) or "local".
+# The committing client allows greater query parallelism,
+# but the local client is more defensive.
+abci-client-type = "{{ .BaseConfig.ABCIClientType }}"
+
 # AppDBBackend defines the database backend type to use for the application and snapshots DBs.
 # An empty string indicates that a fallback will be used.
 # First fallback is the deprecated compile-time types.DBBackend value.
diff --git a/server/grpc/server.go b/server/grpc/server.go
index 78a8e1955a..c4d4c69c16 100644
--- a/server/grpc/server.go
+++ b/server/grpc/server.go
@@ -6,6 +6,8 @@ import (
 	"time"
 
 	"google.golang.org/grpc"
+	"google.golang.org/grpc/health"
+	"google.golang.org/grpc/health/grpc_health_v1"
 
 	"github.com/cosmos/cosmos-sdk/client"
 	"github.com/cosmos/cosmos-sdk/codec"
@@ -35,6 +37,8 @@ func StartGRPCServer(clientCtx client.Context, app types.Application, cfg config
 	)
 
 	app.RegisterGRPCServer(grpcSrv)
+	// Respond to health checks.
+	grpc_health_v1.RegisterHealthServer(grpcSrv, health.NewServer())
 
 	// Reflection allows consumers to build dynamic clients that can write to any
 	// Cosmos SDK application without relying on application packages at compile
diff --git a/server/start.go b/server/start.go
index d45dca16e2..c6a35ffe85 100644
--- a/server/start.go
+++ b/server/start.go
@@ -12,6 +12,7 @@ import (
 
 	"github.com/spf13/cobra"
 	"github.com/tendermint/tendermint/abci/server"
+	abcitypes "github.com/tendermint/tendermint/abci/types"
 	tcmd "github.com/tendermint/tendermint/cmd/cometbft/commands"
 	tmos "github.com/tendermint/tendermint/libs/os"
 	"github.com/tendermint/tendermint/node"
@@ -59,6 +60,7 @@ const (
 	FlagIAVLCacheSize       = "iavl-cache-size"
 	FlagDisableIAVLFastNode = "iavl-disable-fastnode"
 	FlagIAVLLazyLoading     = "iavl-lazy-loading"
+	FlagAbciClientType      = "abci-client-type"
 
 	// state sync-related flags
 	FlagStateSyncSnapshotInterval   = "state-sync.snapshot-interval"
@@ -194,6 +196,7 @@ is performed. Note, when enabled, gRPC will also be automatically enabled.
 	cmd.Flags().Uint32(FlagStateSyncSnapshotKeepRecent, 2, "State sync snapshot to keep")
 
 	cmd.Flags().Bool(FlagDisableIAVLFastNode, false, "Disable fast node for IAVL tree")
+	cmd.Flags().String(FlagAbciClientType, serverconfig.DefaultABCIClientType, fmt.Sprintf(`Type of ABCI client ("%s" or "%s")`, serverconfig.AbciClientTypeCommitting, serverconfig.AbciClientTypeLocal))
 
 	// add support for all Tendermint-specific command line options
 	tcmd.AddNodeFlags(cmd)
@@ -254,6 +257,8 @@ func startStandAlone(ctx *Context, appCreator types.AppCreator) error {
 	return WaitForQuitSignals()
 }
 
+type abciClientCreator func(abcitypes.Application) proxy.ClientCreator
+
 func startInProcess(ctx *Context, clientCtx client.Context, appCreator types.AppCreator) error {
 	cfg := ctx.Config
 	home := cfg.RootDir
@@ -287,6 +292,14 @@ func startInProcess(ctx *Context, clientCtx client.Context, appCreator types.App
 
 	genDocProvider := node.DefaultGenesisDocProviderFunc(cfg)
 
+	// [AGORIC] allow the ABCI client type to be configurable.
+	abciClientType := config.ABCIClientType
+	ctx.Logger.Info(fmt.Sprintf("ABCI client type: %s", abciClientType))
+	clientCreator, err := getAbciClientCreator(abciClientType)
+	if err != nil {
+		return err
+	}
+
 	var (
 		tmNode   *node.Node
 		gRPCOnly = ctx.Viper.GetBool(flagGRPCOnly)
@@ -302,7 +315,7 @@ func startInProcess(ctx *Context, clientCtx client.Context, appCreator types.App
 			cfg,
 			pvm.LoadOrGenFilePV(cfg.PrivValidatorKeyFile(), cfg.PrivValidatorStateFile()),
 			nodeKey,
-			proxy.NewLocalClientCreator(app),
+			clientCreator(app),
 			genDocProvider,
 			node.DefaultDBProvider,
 			node.DefaultMetricsProvider(cfg.Instrumentation),
@@ -501,6 +514,18 @@ func startInProcess(ctx *Context, clientCtx client.Context, appCreator types.App
 	return WaitForQuitSignals()
 }
 
+// getAbciClientCreator dispatches the client type to the right cometbft constructor.
+// [AGORIC] Allows us to disable committingClient.
+func getAbciClientCreator(abciClientType string) (abciClientCreator, error) {
+	switch abciClientType {
+	case serverconfig.AbciClientTypeCommitting:
+		return proxy.NewCommittingClientCreator, nil
+	case serverconfig.AbciClientTypeLocal:
+		return proxy.NewLocalClientCreator, nil
+	}
+	return nil, fmt.Errorf(`unknown ABCI client type "%s"`, abciClientType)
+}
+
 func startTelemetry(cfg serverconfig.Config) (*telemetry.Metrics, error) {
 	if !cfg.Telemetry.Enabled {
 		return nil, nil
diff --git a/server/start_test.go b/server/start_test.go
new file mode 100644
index 0000000000..ddbc88ccc4
--- /dev/null
+++ b/server/start_test.go
@@ -0,0 +1,134 @@
+package server
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"os"
+	"path"
+	"reflect"
+	"runtime"
+	"testing"
+
+	"github.com/spf13/cobra"
+	tmcfg "github.com/tendermint/tendermint/config"
+)
+
+func TestAbciClientType(t *testing.T) {
+	for _, tt := range []struct {
+		clientType  string
+		creatorName string
+		wantErr     bool
+	}{
+		{
+			clientType:  "committing",
+			creatorName: "github.com/tendermint/tendermint/proxy.NewCommittingClientCreator",
+		},
+		{
+			clientType:  "local",
+			creatorName: "github.com/tendermint/tendermint/proxy.NewLocalClientCreator",
+		},
+		{
+			clientType: "cool ranch",
+			wantErr:    true,
+		},
+	} {
+		t.Run(tt.clientType, func(t *testing.T) {
+			creator, err := getAbciClientCreator(tt.clientType)
+			if tt.wantErr {
+				if err == nil {
+					t.Error("wanted error, got none")
+				}
+			} else {
+				if err != nil {
+					t.Errorf("unexpected error %v", err)
+				} else {
+					creatorName := runtime.FuncForPC(reflect.ValueOf(creator).Pointer()).Name()
+					if creatorName != tt.creatorName {
+						t.Errorf(`want creator "%s", got "%s"`, tt.creatorName, creatorName)
+					}
+				}
+			}
+		})
+	}
+}
+
+var errCancelledInPreRun = errors.New("cancelled in prerun")
+
+func TestAbciClientPrecedence(t *testing.T) {
+	for i, tt := range []struct {
+		flag, toml, want string
+	}{
+		{
+			want: "committing",
+		},
+		{
+			flag: "foo",
+			want: "foo",
+		},
+		{
+			toml: "foo",
+			want: "foo",
+		},
+		{
+			flag: "foo",
+			toml: "bar",
+			want: "foo",
+		},
+	} {
+		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
+			tempDir := t.TempDir()
+			err := os.Mkdir(path.Join(tempDir, "config"), os.ModePerm)
+			if err != nil {
+				t.Fatalf("creating config dir failed: %v", err)
+			}
+			appTomlPath := path.Join(tempDir, "config", "app.toml")
+
+			cmd := StartCmd(nil, tempDir)
+
+			if tt.flag != "" {
+				err = cmd.Flags().Set(FlagAbciClientType, tt.flag)
+				if err != nil {
+					t.Fatalf(`failed setting flag to "%s": %v`, tt.flag, err)
+				}
+			}
+
+			if tt.toml != "" {
+				writer, err := os.Create(appTomlPath)
+				if err != nil {
+					t.Fatalf(`failed creating "%s": %v`, appTomlPath, err)
+				}
+				_, err = writer.WriteString(fmt.Sprintf("%s = \"%s\"\n", FlagAbciClientType, tt.toml))
+				if err != nil {
+					t.Fatalf(`failed writing to app.toml: %v`, err)
+				}
+				err = writer.Close()
+				if err != nil {
+					t.Fatalf(`failed closing app.toml: %v`, err)
+				}
+			}
+
+			// Compare to tests in util_test.go
+			cmd.PreRunE = func(cmd *cobra.Command, args []string) error {
+				err := InterceptConfigsPreRunHandler(cmd, "", nil, tmcfg.DefaultConfig())
+				if err != nil {
+					return err
+				}
+				return errCancelledInPreRun
+			}
+
+			serverCtx := NewDefaultContext()
+			ctx := context.WithValue(context.Background(), ServerContextKey, serverCtx)
+			err = cmd.ExecuteContext(ctx)
+			if err != errCancelledInPreRun {
+				t.Fatal(err)
+			}
+
+			gotClientType := serverCtx.Viper.GetString(FlagAbciClientType)
+
+			if gotClientType != tt.want {
+				t.Errorf(`want client type "%s", got "%s"`, tt.want, gotClientType)
+			}
+		})
+	}
+}
diff --git a/simapp/app.go b/simapp/app.go
index 5261b55282..11eefc1b30 100644
--- a/simapp/app.go
+++ b/simapp/app.go
@@ -270,7 +270,7 @@ func NewSimApp(
 		appCodec, keys[minttypes.StoreKey], app.GetSubspace(minttypes.ModuleName), &stakingKeeper,
 		app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName,
 	)
-	app.DistrKeeper = distrkeeper.NewKeeper(
+	distrKeeper := distrkeeper.NewKeeper(
 		appCodec, keys[distrtypes.StoreKey], app.GetSubspace(distrtypes.ModuleName), app.AccountKeeper, app.BankKeeper,
 		&stakingKeeper, authtypes.FeeCollectorName,
 	)
@@ -286,8 +286,9 @@ func NewSimApp(
 	// register the staking hooks
 	// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks
 	app.StakingKeeper = *stakingKeeper.SetHooks(
-		stakingtypes.NewMultiStakingHooks(app.DistrKeeper.Hooks(), app.SlashingKeeper.Hooks()),
+		stakingtypes.NewMultiStakingHooks(distrKeeper.Hooks(), app.SlashingKeeper.Hooks()),
 	)
+	app.DistrKeeper = *distrKeeper.AddHooks(vestingtypes.NewDistributionHooks(app.AccountKeeper, app.BankKeeper, app.StakingKeeper))
 
 	app.AuthzKeeper = authzkeeper.NewKeeper(keys[authzkeeper.StoreKey], appCodec, app.MsgServiceRouter(), app.AccountKeeper)
 
@@ -349,7 +350,7 @@ func NewSimApp(
 			encodingConfig.TxConfig,
 		),
 		auth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts),
-		vesting.NewAppModule(app.AccountKeeper, app.BankKeeper),
+		vesting.NewAppModule(app.AccountKeeper, app.BankKeeper, app.StakingKeeper),
 		bank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper),
 		capability.NewAppModule(appCodec, *app.CapabilityKeeper),
 		crisis.NewAppModule(&app.CrisisKeeper, skipGenesisInvariants),
diff --git a/snapshots/helpers_test.go b/snapshots/helpers_test.go
index 04448bc0e0..5d3f57e891 100644
--- a/snapshots/helpers_test.go
+++ b/snapshots/helpers_test.go
@@ -18,6 +18,7 @@ import (
 	"github.com/cosmos/cosmos-sdk/snapshots"
 	snapshottypes "github.com/cosmos/cosmos-sdk/snapshots/types"
 	"github.com/cosmos/cosmos-sdk/testutil"
+	sdk "github.com/cosmos/cosmos-sdk/types"
 	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
 )
 
@@ -62,7 +63,7 @@ func readChunks(chunks <-chan io.ReadCloser) [][]byte {
 }
 
 // snapshotItems serialize a array of bytes as SnapshotItem_ExtensionPayload, and return the chunks.
-func snapshotItems(items [][]byte) [][]byte {
+func snapshotItems(items [][]byte, ext snapshottypes.ExtensionSnapshotter) [][]byte {
 	// copy the same parameters from the code
 	snapshotChunkSize := uint64(10e6)
 	snapshotBufferSize := int(snapshotChunkSize)
@@ -74,10 +75,21 @@ func snapshotItems(items [][]byte) [][]byte {
 		zWriter, _ := zlib.NewWriterLevel(bufWriter, 7)
 		protoWriter := protoio.NewDelimitedWriter(zWriter)
 		for _, item := range items {
-			_ = snapshottypes.WriteExtensionItem(protoWriter, item)
+			_ = snapshottypes.WriteExtensionPayload(protoWriter, item)
 		}
+		// write extension metadata
+		_ = protoWriter.WriteMsg(&snapshottypes.SnapshotItem{
+			Item: &snapshottypes.SnapshotItem_Extension{
+				Extension: &snapshottypes.SnapshotExtensionMeta{
+					Name:   ext.SnapshotName(),
+					Format: ext.SnapshotFormat(),
+				},
+			},
+		})
+		_ = ext.SnapshotExtension(0, func(payload []byte) error {
+			return snapshottypes.WriteExtensionPayload(protoWriter, payload)
+		})
 		_ = protoWriter.Close()
-		_ = zWriter.Close()
 		_ = bufWriter.Flush()
 		_ = chunkWriter.Close()
 	}()
@@ -110,10 +122,11 @@ func (m *mockSnapshotter) Restore(
 		return snapshottypes.SnapshotItem{}, errors.New("already has contents")
 	}
 
+	var item snapshottypes.SnapshotItem
 	m.items = [][]byte{}
 	for {
-		item := &snapshottypes.SnapshotItem{}
-		err := protoReader.ReadMsg(item)
+		item.Reset()
+		err := protoReader.ReadMsg(&item)
 		if err == io.EOF {
 			break
 		} else if err != nil {
@@ -121,17 +134,17 @@ func (m *mockSnapshotter) Restore(
 		}
 		payload := item.GetExtensionPayload()
 		if payload == nil {
-			return snapshottypes.SnapshotItem{}, sdkerrors.Wrap(err, "invalid protobuf message")
+			break
 		}
 		m.items = append(m.items, payload.Payload)
 	}
 
-	return snapshottypes.SnapshotItem{}, nil
+	return item, nil
 }
 
 func (m *mockSnapshotter) Snapshot(height uint64, protoWriter protoio.Writer) error {
 	for _, item := range m.items {
-		if err := snapshottypes.WriteExtensionItem(protoWriter, item); err != nil {
+		if err := snapshottypes.WriteExtensionPayload(protoWriter, item); err != nil {
 			return err
 		}
 	}
@@ -248,3 +261,52 @@ func (m *hungSnapshotter) Restore(
 ) (snapshottypes.SnapshotItem, error) {
 	panic("not implemented")
 }
+
+type extSnapshotter struct {
+	state []uint64
+}
+
+func newExtSnapshotter(count int) *extSnapshotter {
+	state := make([]uint64, 0, count)
+	for i := 0; i < count; i++ {
+		state = append(state, uint64(i))
+	}
+	return &extSnapshotter{
+		state,
+	}
+}
+
+func (s *extSnapshotter) SnapshotName() string {
+	return "mock"
+}
+
+func (s *extSnapshotter) SnapshotFormat() uint32 {
+	return 1
+}
+
+func (s *extSnapshotter) SupportedFormats() []uint32 {
+	return []uint32{1}
+}
+
+func (s *extSnapshotter) SnapshotExtension(height uint64, payloadWriter snapshottypes.ExtensionPayloadWriter) error {
+	for _, i := range s.state {
+		if err := payloadWriter(sdk.Uint64ToBigEndian(uint64(i))); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (s *extSnapshotter) RestoreExtension(height uint64, format uint32, payloadReader snapshottypes.ExtensionPayloadReader) error {
+	for {
+		payload, err := payloadReader()
+		if err == io.EOF {
+			break
+		} else if err != nil {
+			return err
+		}
+		s.state = append(s.state, sdk.BigEndianToUint64(payload))
+	}
+	// finalize restoration
+	return nil
+}
diff --git a/snapshots/manager.go b/snapshots/manager.go
index b92a2b5b82..1f67e77227 100644
--- a/snapshots/manager.go
+++ b/snapshots/manager.go
@@ -65,7 +65,10 @@ const (
 	chunkBufferSize   = 4
 	chunkIDBufferSize = 1024
 
-	snapshotMaxItemSize = int(64e6) // SDK has no key/value size limit, so we set an arbitrary limit
+	// snapshotMaxItemSize limits the size of both KVStore entries and snapshot
+	// extension payloads during a state-sync restore.
+	// Unexported so copied in manager_test.go for testing
+	snapshotMaxItemSize = int(512e6)
 )
 
 var ErrOptsZeroSnapshotInterval = errors.New("snaphot-interval must not be 0")
@@ -86,6 +89,9 @@ func NewManager(store *Store, opts types.SnapshotOptions, multistore types.Snaps
 
 // RegisterExtensions register extension snapshotters to manager
 func (m *Manager) RegisterExtensions(extensions ...types.ExtensionSnapshotter) error {
+	if m.extensions == nil {
+		m.extensions = make(map[string]types.ExtensionSnapshotter, len(extensions))
+	}
 	for _, extension := range extensions {
 		name := extension.SnapshotName()
 		if _, ok := m.extensions[name]; ok {
@@ -217,7 +223,10 @@ func (m *Manager) createSnapshot(height uint64, ch chan<- io.ReadCloser) {
 			streamWriter.CloseWithError(err)
 			return
 		}
-		if err := extension.Snapshot(height, streamWriter); err != nil {
+		payloadWriter := func(payload []byte) error {
+			return types.WriteExtensionPayload(streamWriter, payload)
+		}
+		if err := extension.SnapshotExtension(height, payloadWriter); err != nil {
 			streamWriter.CloseWithError(err)
 			return
 		}
@@ -337,24 +346,39 @@ func (m *Manager) doRestoreSnapshot(snapshot types.Snapshot, chChunks <-chan io.
 		return sdkerrors.Wrapf(err, "failed to create snapshot directory %q", dir)
 	}
 
+	var nextItem types.SnapshotItem
+
 	streamReader, err := NewStreamReader(chChunks)
 	if err != nil {
 		return err
 	}
 	defer streamReader.Close()
 
-	next, err := m.multistore.Restore(snapshot.Height, snapshot.Format, streamReader)
+	// payloadReader reads an extension payload for extension snapshotter, it returns `io.EOF` at extension boundaries.
+	payloadReader := func() ([]byte, error) {
+		nextItem.Reset()
+		if err := streamReader.ReadMsg(&nextItem); err != nil {
+			return nil, err
+		}
+		payload := nextItem.GetExtensionPayload()
+		if payload == nil {
+			return nil, io.EOF
+		}
+		return payload.Payload, nil
+	}
+
+	nextItem, err = m.multistore.Restore(snapshot.Height, snapshot.Format, streamReader)
 	if err != nil {
 		return sdkerrors.Wrap(err, "multistore restore")
 	}
 	for {
-		if next.Item == nil {
+		if nextItem.Item == nil {
 			// end of stream
 			break
 		}
-		metadata := next.GetExtension()
+		metadata := nextItem.GetExtension()
 		if metadata == nil {
-			return sdkerrors.Wrapf(sdkerrors.ErrLogic, "unknown snapshot item %T", next.Item)
+			return sdkerrors.Wrapf(sdkerrors.ErrLogic, "unknown snapshot item %T", nextItem.Item)
 		}
 		extension, ok := m.extensions[metadata.Name]
 		if !ok {
@@ -363,10 +387,14 @@ func (m *Manager) doRestoreSnapshot(snapshot types.Snapshot, chChunks <-chan io.
 		if !IsFormatSupported(extension, metadata.Format) {
 			return sdkerrors.Wrapf(types.ErrUnknownFormat, "format %v for extension %s", metadata.Format, metadata.Name)
 		}
-		next, err = extension.Restore(snapshot.Height, metadata.Format, streamReader)
-		if err != nil {
+
+		if err := extension.RestoreExtension(snapshot.Height, metadata.Format, payloadReader); err != nil {
 			return sdkerrors.Wrapf(err, "extension %s restore", metadata.Name)
 		}
+
+		if nextItem.GetExtensionPayload() != nil {
+			return sdkerrors.Wrapf(err, "extension %s don't exhausted payload stream", metadata.Name)
+		}
 	}
 	return nil
 }
@@ -485,19 +513,24 @@ func (m *Manager) SnapshotIfApplicable(height int64) {
 	if m == nil {
 		return
 	}
-	if !m.shouldTakeSnapshot(height) {
+	if !m.ShouldTakeSnapshot(height) {
 		m.logger.Debug("snapshot is skipped", "height", height)
 		return
 	}
-	m.snapshot(height)
+	m.Snapshot(height)
 }
 
-// shouldTakeSnapshot returns true is snapshot should be taken at height.
-func (m *Manager) shouldTakeSnapshot(height int64) bool {
+// ShouldTakeSnapshot returns true if a snapshot should be taken at height.
+func (m *Manager) ShouldTakeSnapshot(height int64) bool {
+	if m == nil {
+		return false
+	}
 	return m.opts.Interval > 0 && uint64(height)%m.opts.Interval == 0
 }
 
-func (m *Manager) snapshot(height int64) {
+// Snapshot taks a snapshot of the current state and prunes any old snapshottypes.
+// It should be started as a goroutine
+func (m *Manager) Snapshot(height int64) {
 	m.logger.Info("creating state snapshot", "height", height)
 
 	if height <= 0 {
diff --git a/snapshots/manager_test.go b/snapshots/manager_test.go
index d41819e3f1..25789583a6 100644
--- a/snapshots/manager_test.go
+++ b/snapshots/manager_test.go
@@ -2,6 +2,7 @@ package snapshots_test
 
 import (
 	"errors"
+	"io"
 	"testing"
 
 	"github.com/stretchr/testify/assert"
@@ -70,11 +71,15 @@ func TestManager_Take(t *testing.T) {
 		items:         items,
 		prunedHeights: make(map[int64]struct{}),
 	}
-	expectChunks := snapshotItems(items)
+	extSnapshotter := newExtSnapshotter(10)
+
+	expectChunks := snapshotItems(items, extSnapshotter)
 	manager := snapshots.NewManager(store, opts, snapshotter, nil, log.NewNopLogger())
+	err := manager.RegisterExtensions(extSnapshotter)
+	require.NoError(t, err)
 
 	// nil manager should return error
-	_, err := (*snapshots.Manager)(nil).Create(1)
+	_, err = (*snapshots.Manager)(nil).Create(1)
 	require.Error(t, err)
 
 	// creating a snapshot at a lower height than the latest should error
@@ -93,7 +98,7 @@ func TestManager_Take(t *testing.T) {
 		Height: 5,
 		Format: snapshotter.SnapshotFormat(),
 		Chunks: 1,
-		Hash:   []uint8{0x14, 0x38, 0x97, 0x96, 0xba, 0xe4, 0x81, 0xaf, 0x6c, 0xac, 0xff, 0xa5, 0xb8, 0x7e, 0x63, 0x4b, 0xac, 0x69, 0x3f, 0x38, 0x90, 0x5c, 0x7d, 0x57, 0xb3, 0xf, 0x69, 0x73, 0xb3, 0xa0, 0xe0, 0xad},
+		Hash:   []uint8{0xc5, 0xf7, 0xfe, 0xea, 0xd3, 0x4d, 0x3e, 0x87, 0xff, 0x41, 0xa2, 0x27, 0xfa, 0xcb, 0x38, 0x17, 0xa, 0x5, 0xeb, 0x27, 0x4e, 0x16, 0x5e, 0xf3, 0xb2, 0x8b, 0x47, 0xd1, 0xe6, 0x94, 0x7e, 0x8b},
 		Metadata: types.Metadata{
 			ChunkHashes: checksums(expectChunks),
 		},
@@ -135,7 +140,10 @@ func TestManager_Restore(t *testing.T) {
 	target := &mockSnapshotter{
 		prunedHeights: make(map[int64]struct{}),
 	}
+	extSnapshotter := newExtSnapshotter(0)
 	manager := snapshots.NewManager(store, opts, target, nil, log.NewNopLogger())
+	err := manager.RegisterExtensions(extSnapshotter)
+	require.NoError(t, err)
 
 	expectItems := [][]byte{
 		{1, 2, 3},
@@ -143,10 +151,10 @@ func TestManager_Restore(t *testing.T) {
 		{7, 8, 9},
 	}
 
-	chunks := snapshotItems(expectItems)
+	chunks := snapshotItems(expectItems, newExtSnapshotter(10))
 
 	// Restore errors on invalid format
-	err := manager.Restore(types.Snapshot{
+	err = manager.Restore(types.Snapshot{
 		Height:   3,
 		Format:   0,
 		Hash:     []byte{1, 2, 3},
@@ -206,6 +214,7 @@ func TestManager_Restore(t *testing.T) {
 	}
 
 	assert.Equal(t, expectItems, target.items)
+	assert.Equal(t, 10, len(extSnapshotter.state))
 
 	// The snapshot is saved in local snapshot store
 	snapshots, err := store.List()
@@ -238,6 +247,92 @@ func TestManager_Restore(t *testing.T) {
 	require.NoError(t, err)
 }
 
+const snapshotMaxItemSize = int(512e6) // Copied from github.com/cosmos/cosmos-sdk/snapshots
+
+func TestManager_RestoreLargeItem(t *testing.T) {
+	store := setupStore(t)
+	target := &mockSnapshotter{}
+	extSnapshotter := newExtSnapshotter(0)
+	manager := snapshots.NewManager(store, opts, target, nil, log.NewNopLogger())
+	err := manager.RegisterExtensions(extSnapshotter)
+	require.NoError(t, err)
+
+	largeItem := make([]byte, snapshotMaxItemSize)
+
+	// The protobuf wrapper introduces extra bytes
+	adjustedSize := 2*snapshotMaxItemSize - (&types.SnapshotItem{
+		Item: &types.SnapshotItem_ExtensionPayload{
+			ExtensionPayload: &types.SnapshotExtensionPayload{
+				Payload: largeItem,
+			},
+		},
+	}).Size()
+	largeItem = largeItem[:adjustedSize]
+	expectItems := [][]byte{largeItem}
+
+	chunks := snapshotItems(expectItems, newExtSnapshotter(1))
+
+	// Starting a restore works
+	err = manager.Restore(types.Snapshot{
+		Height:   3,
+		Format:   2,
+		Hash:     []byte{1, 2, 3},
+		Chunks:   1,
+		Metadata: types.Metadata{ChunkHashes: checksums(chunks)},
+	})
+	require.NoError(t, err)
+
+	// Feeding the chunks should work
+	for i, chunk := range chunks {
+		done, err := manager.RestoreChunk(chunk)
+		require.NoError(t, err)
+		if i == len(chunks)-1 {
+			assert.True(t, done)
+		} else {
+			assert.False(t, done)
+		}
+	}
+
+	assert.Equal(t, expectItems, target.items)
+	assert.Equal(t, 1, len(extSnapshotter.state))
+}
+
+func TestManager_CannotRestoreTooLargeItem(t *testing.T) {
+	store := setupStore(t)
+	target := &mockSnapshotter{}
+	extSnapshotter := newExtSnapshotter(0)
+	manager := snapshots.NewManager(store, opts, target, nil, log.NewNopLogger())
+	err := manager.RegisterExtensions(extSnapshotter)
+	require.NoError(t, err)
+
+	// The protobuf wrapper introduces extra bytes
+	largeItem := make([]byte, snapshotMaxItemSize)
+	expectItems := [][]byte{largeItem}
+
+	chunks := snapshotItems(expectItems, newExtSnapshotter(1))
+
+	// Starting a restore works
+	err = manager.Restore(types.Snapshot{
+		Height:   3,
+		Format:   2,
+		Hash:     []byte{1, 2, 3},
+		Chunks:   1,
+		Metadata: types.Metadata{ChunkHashes: checksums(chunks)},
+	})
+	require.NoError(t, err)
+
+	// Feeding the chunks fails
+	for _, chunk := range chunks {
+		_, err = manager.RestoreChunk(chunk)
+
+		if err != nil {
+			break
+		}
+	}
+	require.Error(t, err)
+	require.True(t, errors.Is(err, io.ErrShortBuffer))
+}
+
 func TestManager_TakeError(t *testing.T) {
 	snapshotter := &mockErrorSnapshotter{}
 	store, err := snapshots.NewStore(dbm.NewMemDB(), testutil.GetTempDir(t))
diff --git a/snapshots/stream.go b/snapshots/stream.go
index 935028313b..ce000f3e9c 100644
--- a/snapshots/stream.go
+++ b/snapshots/stream.go
@@ -57,10 +57,6 @@ func (sw *StreamWriter) Close() error {
 		sw.chunkWriter.CloseWithError(err)
 		return err
 	}
-	if err := sw.zWriter.Close(); err != nil {
-		sw.chunkWriter.CloseWithError(err)
-		return err
-	}
 	if err := sw.bufWriter.Flush(); err != nil {
 		sw.chunkWriter.CloseWithError(err)
 		return err
diff --git a/snapshots/types/snapshotter.go b/snapshots/types/snapshotter.go
index 76f800484a..a9b3cfd551 100644
--- a/snapshots/types/snapshotter.go
+++ b/snapshots/types/snapshotter.go
@@ -28,11 +28,16 @@ type Snapshotter interface {
 	Restore(height uint64, format uint32, protoReader protoio.Reader) (SnapshotItem, error)
 }
 
+// ExtensionPayloadReader read extension payloads,
+// it returns io.EOF when reached either end of stream or the extension boundaries.
+type ExtensionPayloadReader = func() ([]byte, error)
+
+// ExtensionPayloadWriter is a helper to write extension payloads to underlying stream.
+type ExtensionPayloadWriter = func([]byte) error
+
 // ExtensionSnapshotter is an extension Snapshotter that is appended to the snapshot stream.
 // ExtensionSnapshotter has an unique name and manages it's own internal formats.
 type ExtensionSnapshotter interface {
-	Snapshotter
-
 	// SnapshotName returns the name of snapshotter, it should be unique in the manager.
 	SnapshotName() string
 
@@ -43,4 +48,11 @@ type ExtensionSnapshotter interface {
 
 	// SupportedFormats returns a list of formats it can restore from.
 	SupportedFormats() []uint32
+
+	// SnapshotExtension writes extension payloads into the underlying protobuf stream.
+	SnapshotExtension(height uint64, payloadWriter ExtensionPayloadWriter) error
+
+	// RestoreExtension restores an extension state snapshot,
+	// the payload reader returns `io.EOF` when reached the extension boundaries.
+	RestoreExtension(height uint64, format uint32, payloadReader ExtensionPayloadReader) error
 }
diff --git a/snapshots/types/util.go b/snapshots/types/util.go
index 348b505768..e2d4949bf5 100644
--- a/snapshots/types/util.go
+++ b/snapshots/types/util.go
@@ -4,12 +4,12 @@ import (
 	protoio "github.com/gogo/protobuf/io"
 )
 
-// WriteExtensionItem writes an item payload for current extension snapshotter.
-func WriteExtensionItem(protoWriter protoio.Writer, item []byte) error {
+// WriteExtensionPayload writes an extension payload for current extension snapshotter.
+func WriteExtensionPayload(protoWriter protoio.Writer, payload []byte) error {
 	return protoWriter.WriteMsg(&SnapshotItem{
 		Item: &SnapshotItem_ExtensionPayload{
 			ExtensionPayload: &SnapshotExtensionPayload{
-				Payload: item,
+				Payload: payload,
 			},
 		},
 	})
diff --git a/store/rootmulti/snapshot_test.go b/store/rootmulti/snapshot_test.go
index f8b058656d..de7880788e 100644
--- a/store/rootmulti/snapshot_test.go
+++ b/store/rootmulti/snapshot_test.go
@@ -128,7 +128,7 @@ func TestMultistoreSnapshot_Checksum(t *testing.T) {
 			"aa048b4ee0f484965d7b3b06822cf0772cdcaad02f3b1b9055e69f2cb365ef3c",
 			"7921eaa3ed4921341e504d9308a9877986a879fe216a099c86e8db66fcba4c63",
 			"a4a864e6c02c9fca5837ec80dc84f650b25276ed7e4820cf7516ced9f9901b86",
-			"8ca5b957e36fa13e704c31494649b2a74305148d70d70f0f26dee066b615c1d0",
+			"980925390cc50f14998ecb1e87de719ca9dd7e72f5fefbe445397bf670f36c31",
 		}},
 	}
 	for _, tc := range testcases {
diff --git a/testutil/network/util.go b/testutil/network/util.go
index a29705c0fa..76ac50759f 100644
--- a/testutil/network/util.go
+++ b/testutil/network/util.go
@@ -45,7 +45,7 @@ func startInProcess(cfg Config, val *Validator) error {
 		tmCfg,
 		pvm.LoadOrGenFilePV(tmCfg.PrivValidatorKeyFile(), tmCfg.PrivValidatorStateFile()),
 		nodeKey,
-		proxy.NewLocalClientCreator(app),
+		proxy.NewCommittingClientCreator(app),
 		genDocProvider,
 		node.DefaultDBProvider,
 		node.DefaultMetricsProvider(tmCfg.Instrumentation),
diff --git a/types/coin.go b/types/coin.go
index 12b373c592..9e719f766b 100644
--- a/types/coin.go
+++ b/types/coin.go
@@ -656,7 +656,10 @@ func (coins Coins) IsEqual(coinsB Coins) bool {
 	coinsB = coinsB.Sort()
 
 	for i := 0; i < len(coins); i++ {
-		if !coins[i].IsEqual(coinsB[i]) {
+		if coins[i].Denom != coinsB[i].Denom {
+			return false
+		}
+		if !coins[i].Amount.Equal(coinsB[i].Amount) {
 			return false
 		}
 	}
diff --git a/types/coin_test.go b/types/coin_test.go
index 5010bce239..adee5901c0 100644
--- a/types/coin_test.go
+++ b/types/coin_test.go
@@ -490,7 +490,7 @@ func (s *coinTestSuite) TestEqualCoins() {
 		{sdk.Coins{}, sdk.Coins{}, true, false},
 		{sdk.Coins{sdk.NewInt64Coin(testDenom1, 0)}, sdk.Coins{sdk.NewInt64Coin(testDenom1, 0)}, true, false},
 		{sdk.Coins{sdk.NewInt64Coin(testDenom1, 0), sdk.NewInt64Coin(testDenom2, 1)}, sdk.Coins{sdk.NewInt64Coin(testDenom1, 0), sdk.NewInt64Coin(testDenom2, 1)}, true, false},
-		{sdk.Coins{sdk.NewInt64Coin(testDenom1, 0)}, sdk.Coins{sdk.NewInt64Coin(testDenom2, 0)}, false, true},
+		{sdk.Coins{sdk.NewInt64Coin(testDenom1, 0)}, sdk.Coins{sdk.NewInt64Coin(testDenom2, 0)}, false, false},
 		{sdk.Coins{sdk.NewInt64Coin(testDenom1, 0)}, sdk.Coins{sdk.NewInt64Coin(testDenom1, 1)}, false, false},
 		{sdk.Coins{sdk.NewInt64Coin(testDenom1, 0)}, sdk.Coins{sdk.NewInt64Coin(testDenom1, 0), sdk.NewInt64Coin(testDenom2, 1)}, false, false},
 		{sdk.Coins{sdk.NewInt64Coin(testDenom1, 0), sdk.NewInt64Coin(testDenom2, 1)}, sdk.Coins{sdk.NewInt64Coin(testDenom1, 0), sdk.NewInt64Coin(testDenom2, 1)}, true, false},
diff --git a/types/events.go b/types/events.go
index b7ce9868ec..260468a945 100644
--- a/types/events.go
+++ b/types/events.go
@@ -25,10 +25,47 @@ import (
 // can be emitted from.
 type EventManager struct {
 	events Events
+	// history holds the events from all transactions delivered in a block
+	// [AGORIC] Used to communicate the history through the context.
+	history []abci.Event
+}
+
+// NewEventManagerWithHistory returns a new event manager with empty events,
+// but seeded with the provided history of earlier events in the block.
+// [AGORIC] This should be used to create the EventManager for use in EndBlockers.
+func NewEventManagerWithHistory(history []abci.Event) *EventManager {
+	return &EventManager{
+		events:  EmptyEvents(),
+		history: history,
+	}
 }
 
 func NewEventManager() *EventManager {
-	return &EventManager{EmptyEvents()}
+	return NewEventManagerWithHistory([]abci.Event{})
+}
+
+// GetABCIEventHistory returns a deep copy of the ABCI events history.
+// [AGORIC] This should only be called in EndBlock processing.
+func (em *EventManager) GetABCIEventHistory() []abci.Event {
+	history := make([]abci.Event, len(em.history))
+	for i, event := range em.history {
+		history[i].Type = event.Type
+		attrs := make([]abci.EventAttribute, len(event.Attributes))
+		history[i].Attributes = attrs
+		for j, attr := range event.Attributes {
+			attrKey := make([]byte, len(attr.Key))
+			copy(attrKey, attr.Key)
+			attrValue := make([]byte, len(attr.Value))
+			copy(attrValue, attr.Value)
+			attrs[j] = abci.EventAttribute{
+				Index: attr.Index,
+				Key:   attrKey,
+				Value: attrValue,
+			}
+		}
+	}
+	copy(history, em.history)
+	return history
 }
 
 func (em *EventManager) Events() Events { return em.events }
diff --git a/types/module/module.go b/types/module/module.go
index 623b921c37..f1094cb8c1 100644
--- a/types/module/module.go
+++ b/types/module/module.go
@@ -494,7 +494,14 @@ func (m *Manager) BeginBlock(ctx sdk.Context, req abci.RequestBeginBlock) abci.R
 // child context with an event manager to aggregate events emitted from all
 // modules.
 func (m *Manager) EndBlock(ctx sdk.Context, req abci.RequestEndBlock) abci.ResponseEndBlock {
-	ctx = ctx.WithEventManager(sdk.NewEventManager())
+	// [AGORIC] Reset the EventManager, preserving any existing event history.
+	eventHistory := []abci.Event{}
+	if oldEm := ctx.EventManager(); oldEm != nil {
+		eventHistory = oldEm.GetABCIEventHistory()
+	}
+	em := sdk.NewEventManagerWithHistory(eventHistory)
+
+	ctx = ctx.WithEventManager(em)
 	validatorUpdates := []abci.ValidatorUpdate{}
 
 	for _, moduleName := range m.OrderEndBlockers {
diff --git a/types/router.go b/types/router.go
index 9dab11f606..fa8836f59a 100644
--- a/types/router.go
+++ b/types/router.go
@@ -6,6 +6,10 @@ import (
 )
 
 var (
+	// IsAlphaNumericOrUnderscore is a regular expression that matches all typical
+	// JSON property names.
+	IsAlphaNumericOrUnderscore = regexp.MustCompile(`^[a-zA-Z0-9_]+$`).MatchString
+
 	// IsAlphaNumeric defines a regular expression for matching against alpha-numeric
 	// values.
 	IsAlphaNumeric = regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString
diff --git a/x/auth/ante/fee.go b/x/auth/ante/fee.go
index 4ab9dda9ee..947ceb9aa8 100644
--- a/x/auth/ante/fee.go
+++ b/x/auth/ante/fee.go
@@ -17,22 +17,30 @@ type TxFeeChecker func(ctx sdk.Context, tx sdk.Tx) (sdk.Coins, int64, error)
 // Call next AnteHandler if fees successfully deducted
 // CONTRACT: Tx must implement FeeTx interface to use DeductFeeDecorator
 type DeductFeeDecorator struct {
-	accountKeeper  AccountKeeper
-	bankKeeper     types.BankKeeper
-	feegrantKeeper FeegrantKeeper
-	txFeeChecker   TxFeeChecker
+	accountKeeper    AccountKeeper
+	bankKeeper       types.BankKeeper
+	feegrantKeeper   FeegrantKeeper
+	txFeeChecker     TxFeeChecker
+	feeCollectorName string
 }
 
 func NewDeductFeeDecorator(ak AccountKeeper, bk types.BankKeeper, fk FeegrantKeeper, tfc TxFeeChecker) DeductFeeDecorator {
+	return NewDeductFeeDecoratorWithName(ak, bk, fk, tfc, types.FeeCollectorName)
+}
+
+// NewDeductFeeDecoratorWithName returns a DeductFeeDecorator using a custom fee collector module account.
+// Agoric note: for collecting fees in the reserve account.
+func NewDeductFeeDecoratorWithName(ak AccountKeeper, bk types.BankKeeper, fk FeegrantKeeper, tfc TxFeeChecker, feeCollectorName string) DeductFeeDecorator {
 	if tfc == nil {
 		tfc = checkTxFeeWithValidatorMinGasPrices
 	}
 
 	return DeductFeeDecorator{
-		accountKeeper:  ak,
-		bankKeeper:     bk,
-		feegrantKeeper: fk,
-		txFeeChecker:   tfc,
+		accountKeeper:    ak,
+		bankKeeper:       bk,
+		feegrantKeeper:   fk,
+		txFeeChecker:     tfc,
+		feeCollectorName: feeCollectorName,
 	}
 }
 
@@ -73,8 +81,8 @@ func (dfd DeductFeeDecorator) checkDeductFee(ctx sdk.Context, sdkTx sdk.Tx, fee
 		return sdkerrors.Wrap(sdkerrors.ErrTxDecode, "Tx must be a FeeTx")
 	}
 
-	if addr := dfd.accountKeeper.GetModuleAddress(types.FeeCollectorName); addr == nil {
-		return fmt.Errorf("fee collector module account (%s) has not been set", types.FeeCollectorName)
+	if addr := dfd.accountKeeper.GetModuleAddress(dfd.feeCollectorName); addr == nil {
+		return fmt.Errorf("fee collector module account (%s) has not been set", dfd.feeCollectorName)
 	}
 
 	feePayer := feeTx.FeePayer()
@@ -103,7 +111,7 @@ func (dfd DeductFeeDecorator) checkDeductFee(ctx sdk.Context, sdkTx sdk.Tx, fee
 
 	// deduct the fees
 	if !fee.IsZero() {
-		err := DeductFees(dfd.bankKeeper, ctx, deductFeesFromAcc, fee)
+		err := DeductFees(dfd.bankKeeper, ctx, deductFeesFromAcc, fee, dfd.feeCollectorName)
 		if err != nil {
 			return err
 		}
@@ -122,12 +130,12 @@ func (dfd DeductFeeDecorator) checkDeductFee(ctx sdk.Context, sdkTx sdk.Tx, fee
 }
 
 // DeductFees deducts fees from the given account.
-func DeductFees(bankKeeper types.BankKeeper, ctx sdk.Context, acc types.AccountI, fees sdk.Coins) error {
+func DeductFees(bankKeeper types.BankKeeper, ctx sdk.Context, acc types.AccountI, fees sdk.Coins, feeCollectorName string) error {
 	if !fees.IsValid() {
 		return sdkerrors.Wrapf(sdkerrors.ErrInsufficientFee, "invalid fee amount: %s", fees)
 	}
 
-	err := bankKeeper.SendCoinsFromAccountToModule(ctx, acc.GetAddress(), types.FeeCollectorName, fees)
+	err := bankKeeper.SendCoinsFromAccountToModule(ctx, acc.GetAddress(), feeCollectorName, fees)
 	if err != nil {
 		return sdkerrors.Wrapf(sdkerrors.ErrInsufficientFunds, err.Error())
 	}
diff --git a/x/auth/ante/fee_test.go b/x/auth/ante/fee_test.go
index c63706137e..5223c4d9d8 100644
--- a/x/auth/ante/fee_test.go
+++ b/x/auth/ante/fee_test.go
@@ -5,6 +5,7 @@ import (
 	"github.com/cosmos/cosmos-sdk/testutil/testdata"
 	sdk "github.com/cosmos/cosmos-sdk/types"
 	"github.com/cosmos/cosmos-sdk/x/auth/ante"
+	"github.com/cosmos/cosmos-sdk/x/auth/types"
 	"github.com/cosmos/cosmos-sdk/x/bank/testutil"
 )
 
@@ -146,3 +147,48 @@ func (s *AnteTestSuite) TestDeductFees() {
 
 	s.Require().Nil(err, "Tx errored after account has been set with sufficient funds")
 }
+
+func (s *AnteTestSuite) TestDeductFees_WithName() {
+	s.SetupTest(false) // setup
+	s.txBuilder = s.clientCtx.TxConfig.NewTxBuilder()
+
+	// keys and addresses
+	priv1, _, addr1 := testdata.KeyTestPubAddr()
+
+	// msg and signatures
+	msg := testdata.NewTestMsg(addr1)
+	feeAmount := testdata.NewTestFeeAmount()
+	gasLimit := testdata.NewTestGasLimit()
+	s.Require().NoError(s.txBuilder.SetMsgs(msg))
+	s.txBuilder.SetFeeAmount(feeAmount)
+	s.txBuilder.SetGasLimit(gasLimit)
+
+	privs, accNums, accSeqs := []cryptotypes.PrivKey{priv1}, []uint64{0}, []uint64{0}
+	tx, err := s.CreateTestTx(privs, accNums, accSeqs, s.ctx.ChainID())
+	s.Require().NoError(err)
+
+	// Set transacting account with sufficient funds
+	acc := s.app.AccountKeeper.NewAccountWithAddress(s.ctx, addr1)
+	s.app.AccountKeeper.SetAccount(s.ctx, acc)
+	coins := sdk.NewCoins(sdk.NewCoin("atom", sdk.NewInt(200)))
+	err = testutil.FundAccount(s.app.BankKeeper, s.ctx, addr1, coins)
+	s.Require().NoError(err)
+
+	feeCollectorAcc := s.app.AccountKeeper.GetModuleAccount(s.ctx, types.FeeCollectorName)
+	// pick a simapp module account
+	altCollectorName := "distribution"
+	altCollectorAcc := s.app.AccountKeeper.GetModuleAccount(s.ctx, altCollectorName)
+	s.Require().True(s.app.BankKeeper.GetAllBalances(s.ctx, feeCollectorAcc.GetAddress()).Empty())
+	altBalance := s.app.BankKeeper.GetAllBalances(s.ctx, altCollectorAcc.GetAddress())
+
+	// Run the transaction through a handler chain that deducts fees into altCollectorAcc.
+	dfd := ante.NewDeductFeeDecoratorWithName(s.app.AccountKeeper, s.app.BankKeeper, nil, nil, altCollectorName)
+	antehandler := sdk.ChainAnteDecorators(dfd)
+	_, err = antehandler(s.ctx, tx, false)
+	s.Require().NoError(err)
+
+	s.Require().True(s.app.BankKeeper.GetAllBalances(s.ctx, feeCollectorAcc.GetAddress()).Empty())
+	newAltBalance := s.app.BankKeeper.GetAllBalances(s.ctx, altCollectorAcc.GetAddress())
+	s.Require().True(newAltBalance.IsAllGTE(altBalance))
+	s.Require().False(newAltBalance.IsEqual(altBalance))
+}
diff --git a/x/auth/keeper/account.go b/x/auth/keeper/account.go
index a18a5240dc..8de1b468b6 100644
--- a/x/auth/keeper/account.go
+++ b/x/auth/keeper/account.go
@@ -6,7 +6,7 @@ import (
 )
 
 // NewAccountWithAddress implements AccountKeeperI.
-func (ak AccountKeeper) NewAccountWithAddress(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {
+func (ak accountKeeper) NewAccountWithAddress(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {
 	acc := ak.proto()
 	err := acc.SetAddress(addr)
 	if err != nil {
@@ -17,7 +17,7 @@ func (ak AccountKeeper) NewAccountWithAddress(ctx sdk.Context, addr sdk.AccAddre
 }
 
 // NewAccount sets the next account number to a given account interface
-func (ak AccountKeeper) NewAccount(ctx sdk.Context, acc types.AccountI) types.AccountI {
+func (ak accountKeeper) NewAccount(ctx sdk.Context, acc types.AccountI) types.AccountI {
 	if err := acc.SetAccountNumber(ak.GetNextAccountNumber(ctx)); err != nil {
 		panic(err)
 	}
@@ -26,19 +26,19 @@ func (ak AccountKeeper) NewAccount(ctx sdk.Context, acc types.AccountI) types.Ac
 }
 
 // HasAccount implements AccountKeeperI.
-func (ak AccountKeeper) HasAccount(ctx sdk.Context, addr sdk.AccAddress) bool {
+func (ak accountKeeper) HasAccount(ctx sdk.Context, addr sdk.AccAddress) bool {
 	store := ctx.KVStore(ak.key)
 	return store.Has(types.AddressStoreKey(addr))
 }
 
 // HasAccountAddressByID checks account address exists by id.
-func (ak AccountKeeper) HasAccountAddressByID(ctx sdk.Context, id uint64) bool {
+func (ak accountKeeper) HasAccountAddressByID(ctx sdk.Context, id uint64) bool {
 	store := ctx.KVStore(ak.key)
 	return store.Has(types.AccountNumberStoreKey(id))
 }
 
 // GetAccount implements AccountKeeperI.
-func (ak AccountKeeper) GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {
+func (ak accountKeeper) GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {
 	store := ctx.KVStore(ak.key)
 	bz := store.Get(types.AddressStoreKey(addr))
 	if bz == nil {
@@ -49,7 +49,7 @@ func (ak AccountKeeper) GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.A
 }
 
 // GetAccountAddressById returns account address by id.
-func (ak AccountKeeper) GetAccountAddressByID(ctx sdk.Context, id uint64) string {
+func (ak accountKeeper) GetAccountAddressByID(ctx sdk.Context, id uint64) string {
 	store := ctx.KVStore(ak.key)
 	bz := store.Get(types.AccountNumberStoreKey(id))
 	if bz == nil {
@@ -59,7 +59,7 @@ func (ak AccountKeeper) GetAccountAddressByID(ctx sdk.Context, id uint64) string
 }
 
 // GetAllAccounts returns all accounts in the accountKeeper.
-func (ak AccountKeeper) GetAllAccounts(ctx sdk.Context) (accounts []types.AccountI) {
+func (ak accountKeeper) GetAllAccounts(ctx sdk.Context) (accounts []types.AccountI) {
 	ak.IterateAccounts(ctx, func(acc types.AccountI) (stop bool) {
 		accounts = append(accounts, acc)
 		return false
@@ -69,7 +69,7 @@ func (ak AccountKeeper) GetAllAccounts(ctx sdk.Context) (accounts []types.Accoun
 }
 
 // SetAccount implements AccountKeeperI.
-func (ak AccountKeeper) SetAccount(ctx sdk.Context, acc types.AccountI) {
+func (ak accountKeeper) SetAccount(ctx sdk.Context, acc types.AccountI) {
 	addr := acc.GetAddress()
 	store := ctx.KVStore(ak.key)
 
@@ -84,7 +84,7 @@ func (ak AccountKeeper) SetAccount(ctx sdk.Context, acc types.AccountI) {
 
 // RemoveAccount removes an account for the account mapper store.
 // NOTE: this will cause supply invariant violation if called
-func (ak AccountKeeper) RemoveAccount(ctx sdk.Context, acc types.AccountI) {
+func (ak accountKeeper) RemoveAccount(ctx sdk.Context, acc types.AccountI) {
 	addr := acc.GetAddress()
 	store := ctx.KVStore(ak.key)
 	store.Delete(types.AddressStoreKey(addr))
@@ -93,7 +93,7 @@ func (ak AccountKeeper) RemoveAccount(ctx sdk.Context, acc types.AccountI) {
 
 // IterateAccounts iterates over all the stored accounts and performs a callback function.
 // Stops iteration when callback returns true.
-func (ak AccountKeeper) IterateAccounts(ctx sdk.Context, cb func(account types.AccountI) (stop bool)) {
+func (ak accountKeeper) IterateAccounts(ctx sdk.Context, cb func(account types.AccountI) (stop bool)) {
 	store := ctx.KVStore(ak.key)
 	iterator := sdk.KVStorePrefixIterator(store, types.AddressStoreKeyPrefix)
 
diff --git a/x/auth/keeper/genesis.go b/x/auth/keeper/genesis.go
index 50d36381fd..134f0e58b8 100644
--- a/x/auth/keeper/genesis.go
+++ b/x/auth/keeper/genesis.go
@@ -9,7 +9,7 @@ import (
 //
 // CONTRACT: old coins from the FeeCollectionKeeper need to be transferred through
 // a genesis port script to the new fee collector account
-func (ak AccountKeeper) InitGenesis(ctx sdk.Context, data types.GenesisState) {
+func (ak accountKeeper) InitGenesis(ctx sdk.Context, data types.GenesisState) {
 	ak.SetParams(ctx, data.Params)
 
 	accounts, err := types.UnpackAccounts(data.Accounts)
@@ -27,7 +27,7 @@ func (ak AccountKeeper) InitGenesis(ctx sdk.Context, data types.GenesisState) {
 }
 
 // ExportGenesis returns a GenesisState for a given context and keeper
-func (ak AccountKeeper) ExportGenesis(ctx sdk.Context) *types.GenesisState {
+func (ak accountKeeper) ExportGenesis(ctx sdk.Context) *types.GenesisState {
 	params := ak.GetParams(ctx)
 
 	var genAccounts types.GenesisAccounts
diff --git a/x/auth/keeper/grpc_query.go b/x/auth/keeper/grpc_query.go
index ae7469282a..f7ea27ecc9 100644
--- a/x/auth/keeper/grpc_query.go
+++ b/x/auth/keeper/grpc_query.go
@@ -17,9 +17,9 @@ import (
 	"github.com/cosmos/cosmos-sdk/x/auth/types"
 )
 
-var _ types.QueryServer = AccountKeeper{}
+var _ types.QueryServer = accountKeeper{}
 
-func (ak AccountKeeper) AccountAddressByID(c context.Context, req *types.QueryAccountAddressByIDRequest) (*types.QueryAccountAddressByIDResponse, error) {
+func (ak accountKeeper) AccountAddressByID(c context.Context, req *types.QueryAccountAddressByIDRequest) (*types.QueryAccountAddressByIDResponse, error) {
 	if req == nil {
 		return nil, status.Errorf(codes.InvalidArgument, "empty request")
 	}
@@ -37,7 +37,7 @@ func (ak AccountKeeper) AccountAddressByID(c context.Context, req *types.QueryAc
 	return &types.QueryAccountAddressByIDResponse{AccountAddress: address}, nil
 }
 
-func (ak AccountKeeper) Accounts(c context.Context, req *types.QueryAccountsRequest) (*types.QueryAccountsResponse, error) {
+func (ak accountKeeper) Accounts(c context.Context, req *types.QueryAccountsRequest) (*types.QueryAccountsResponse, error) {
 	if req == nil {
 		return nil, status.Error(codes.InvalidArgument, "empty request")
 	}
@@ -65,7 +65,7 @@ func (ak AccountKeeper) Accounts(c context.Context, req *types.QueryAccountsRequ
 }
 
 // Account returns account details based on address
-func (ak AccountKeeper) Account(c context.Context, req *types.QueryAccountRequest) (*types.QueryAccountResponse, error) {
+func (ak accountKeeper) Account(c context.Context, req *types.QueryAccountRequest) (*types.QueryAccountResponse, error) {
 	if req == nil {
 		return nil, status.Errorf(codes.InvalidArgument, "empty request")
 	}
@@ -93,7 +93,7 @@ func (ak AccountKeeper) Account(c context.Context, req *types.QueryAccountReques
 }
 
 // Params returns parameters of auth module
-func (ak AccountKeeper) Params(c context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) {
+func (ak accountKeeper) Params(c context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) {
 	if req == nil {
 		return nil, status.Error(codes.InvalidArgument, "empty request")
 	}
@@ -104,7 +104,7 @@ func (ak AccountKeeper) Params(c context.Context, req *types.QueryParamsRequest)
 }
 
 // ModuleAccounts returns all the existing Module Accounts
-func (ak AccountKeeper) ModuleAccounts(c context.Context, req *types.QueryModuleAccountsRequest) (*types.QueryModuleAccountsResponse, error) {
+func (ak accountKeeper) ModuleAccounts(c context.Context, req *types.QueryModuleAccountsRequest) (*types.QueryModuleAccountsResponse, error) {
 	if req == nil {
 		return nil, status.Error(codes.InvalidArgument, "empty request")
 	}
@@ -136,7 +136,7 @@ func (ak AccountKeeper) ModuleAccounts(c context.Context, req *types.QueryModule
 }
 
 // ModuleAccountByName returns module account by module name
-func (ak AccountKeeper) ModuleAccountByName(c context.Context, req *types.QueryModuleAccountByNameRequest) (*types.QueryModuleAccountByNameResponse, error) {
+func (ak accountKeeper) ModuleAccountByName(c context.Context, req *types.QueryModuleAccountByNameRequest) (*types.QueryModuleAccountByNameResponse, error) {
 	if req == nil {
 		return nil, status.Errorf(codes.InvalidArgument, "empty request")
 	}
@@ -161,7 +161,7 @@ func (ak AccountKeeper) ModuleAccountByName(c context.Context, req *types.QueryM
 }
 
 // Bech32Prefix returns the keeper internally stored bech32 prefix.
-func (ak AccountKeeper) Bech32Prefix(ctx context.Context, req *types.Bech32PrefixRequest) (*types.Bech32PrefixResponse, error) {
+func (ak accountKeeper) Bech32Prefix(ctx context.Context, req *types.Bech32PrefixRequest) (*types.Bech32PrefixResponse, error) {
 	bech32Prefix, err := ak.getBech32Prefix()
 	if err != nil {
 		return nil, err
@@ -172,7 +172,7 @@ func (ak AccountKeeper) Bech32Prefix(ctx context.Context, req *types.Bech32Prefi
 
 // AddressBytesToString converts an address from bytes to string, using the
 // keeper's bech32 prefix.
-func (ak AccountKeeper) AddressBytesToString(ctx context.Context, req *types.AddressBytesToStringRequest) (*types.AddressBytesToStringResponse, error) {
+func (ak accountKeeper) AddressBytesToString(ctx context.Context, req *types.AddressBytesToStringRequest) (*types.AddressBytesToStringResponse, error) {
 	if req == nil {
 		return nil, status.Error(codes.InvalidArgument, "empty request")
 	}
@@ -191,7 +191,7 @@ func (ak AccountKeeper) AddressBytesToString(ctx context.Context, req *types.Add
 
 // AddressStringToBytes converts an address from string to bytes, using the
 // keeper's bech32 prefix.
-func (ak AccountKeeper) AddressStringToBytes(ctx context.Context, req *types.AddressStringToBytesRequest) (*types.AddressStringToBytesResponse, error) {
+func (ak accountKeeper) AddressStringToBytes(ctx context.Context, req *types.AddressStringToBytesRequest) (*types.AddressStringToBytesResponse, error) {
 	if req == nil {
 		return nil, status.Error(codes.InvalidArgument, "empty request")
 	}
diff --git a/x/auth/keeper/keeper.go b/x/auth/keeper/keeper.go
index 207f65b0f8..3671b343fa 100644
--- a/x/auth/keeper/keeper.go
+++ b/x/auth/keeper/keeper.go
@@ -16,8 +16,8 @@ import (
 	paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
 )
 
-// AccountKeeperI is the interface contract that x/auth's keeper implements.
-type AccountKeeperI interface {
+// AccountKeeper is the interface contract that x/auth's keeper implements.
+type AccountKeeper interface {
 	// Return a new account with the next account number and the specified address. Does not save the new account to the store.
 	NewAccountWithAddress(sdk.Context, sdk.AccAddress) types.AccountI
 
@@ -30,6 +30,9 @@ type AccountKeeperI interface {
 	// Retrieve an account from the store.
 	GetAccount(sdk.Context, sdk.AccAddress) types.AccountI
 
+	// GetAllAccounts returns all accounts in the accountKeeper.
+	GetAllAccounts(sdk.Context) []types.AccountI
+
 	// Set an account in the store.
 	SetAccount(sdk.Context, types.AccountI)
 
@@ -39,6 +42,11 @@ type AccountKeeperI interface {
 	// Iterate over all accounts, calling the provided function. Stop iteration when it returns true.
 	IterateAccounts(sdk.Context, func(types.AccountI) bool)
 
+	types.QueryServer
+
+	// Logger returns a module-specific logger.
+	Logger(ctx sdk.Context) log.Logger
+
 	// Fetch the public key of an account at a specified address
 	GetPubKey(sdk.Context, sdk.AccAddress) (cryptotypes.PubKey, error)
 
@@ -47,11 +55,60 @@ type AccountKeeperI interface {
 
 	// Fetch the next account number, and increment the internal counter.
 	GetNextAccountNumber(sdk.Context) uint64
+
+	// ValidatePermissions validates that the module account has been granted
+	// permissions within its set of allowed permissions.
+	ValidatePermissions(types.ModuleAccountI) error
+
+	// GetModuleAddress returns an address based on the module name
+	GetModuleAddress(string) sdk.AccAddress
+
+	// GetModuleAddressAndPermissions returns an address and permissions based on the module name
+	GetModuleAddressAndPermissions(moduleName string) (addr sdk.AccAddress, permissions []string)
+
+	// GetModuleAccountAndPermissions gets the module account from the auth account store and its
+	// registered permissions
+	GetModuleAccountAndPermissions(ctx sdk.Context, moduleName string) (types.ModuleAccountI, []string)
+
+	// GetModuleAccount gets the module account from the auth account store, if the account does not
+	// exist in the AccountKeeper, then it is created.
+	GetModuleAccount(sdk.Context, string) types.ModuleAccountI
+
+	// SetModuleAccount sets the module account to the auth account store
+	SetModuleAccount(sdk.Context, types.ModuleAccountI)
+
+	// MarshalAccount protobuf serializes an Account interface
+	MarshalAccount(types.AccountI) ([]byte, error)
+
+	// UnmarshalAccount returns an Account interface from raw encoded account
+	// bytes of a Proto-based Account type
+	UnmarshalAccount([]byte) (types.AccountI, error)
+
+	// GetCodec return codec.Codec object used by the keeper
+	GetCodec() codec.BinaryCodec
+
+	// GetParams gets the auth module's parameters.
+	GetParams(sdk.Context) types.Params
+
+	// SetParams sets the auth module's parameters.
+	SetParams(sdk.Context, types.Params)
+
+	// HasAccountAddressByID checks account address exists by id.
+	HasAccountAddressByID(ctx sdk.Context, id uint64) bool
+
+	// GetAccountAddressByID returns account address by id.
+	GetAccountAddressByID(ctx sdk.Context, id uint64) string
+
+	// InitGenesis - Init store state from genesis data
+	InitGenesis(ctx sdk.Context, data types.GenesisState)
+
+	// ExportGenesis returns a GenesisState for a given context and keeper
+	ExportGenesis(ctx sdk.Context) *types.GenesisState
 }
 
-// AccountKeeper encodes/decodes accounts using the go-amino (binary)
+// accountKeeper encodes/decodes accounts using the go-amino (binary)
 // encoding/decoding library.
-type AccountKeeper struct {
+type accountKeeper struct {
 	key           storetypes.StoreKey
 	cdc           codec.BinaryCodec
 	paramSubspace paramtypes.Subspace
@@ -62,9 +119,9 @@ type AccountKeeper struct {
 	addressCdc address.Codec
 }
 
-var _ AccountKeeperI = &AccountKeeper{}
+var _ AccountKeeper = &accountKeeper{}
 
-// NewAccountKeeper returns a new AccountKeeperI that uses go-amino to
+// NewAccountKeeper returns a new AccountKeeper that uses go-amino to
 // (binary) encode and decode concrete sdk.Accounts.
 // `maccPerms` is a map that takes accounts' addresses as keys, and their respective permissions as values. This map is used to construct
 // types.PermissionsForAddress and is used in keeper.ValidatePermissions. Permissions are plain strings,
@@ -86,7 +143,7 @@ func NewAccountKeeper(
 
 	bech32Codec := newBech32Codec(bech32Prefix)
 
-	return AccountKeeper{
+	return accountKeeper{
 		key:           key,
 		proto:         proto,
 		cdc:           cdc,
@@ -97,12 +154,12 @@ func NewAccountKeeper(
 }
 
 // Logger returns a module-specific logger.
-func (ak AccountKeeper) Logger(ctx sdk.Context) log.Logger {
+func (ak accountKeeper) Logger(ctx sdk.Context) log.Logger {
 	return ctx.Logger().With("module", "x/"+types.ModuleName)
 }
 
 // GetPubKey Returns the PubKey of the account at address
-func (ak AccountKeeper) GetPubKey(ctx sdk.Context, addr sdk.AccAddress) (cryptotypes.PubKey, error) {
+func (ak accountKeeper) GetPubKey(ctx sdk.Context, addr sdk.AccAddress) (cryptotypes.PubKey, error) {
 	acc := ak.GetAccount(ctx, addr)
 	if acc == nil {
 		return nil, sdkerrors.Wrapf(sdkerrors.ErrUnknownAddress, "account %s does not exist", addr)
@@ -112,7 +169,7 @@ func (ak AccountKeeper) GetPubKey(ctx sdk.Context, addr sdk.AccAddress) (cryptot
 }
 
 // GetSequence Returns the Sequence of the account at address
-func (ak AccountKeeper) GetSequence(ctx sdk.Context, addr sdk.AccAddress) (uint64, error) {
+func (ak accountKeeper) GetSequence(ctx sdk.Context, addr sdk.AccAddress) (uint64, error) {
 	acc := ak.GetAccount(ctx, addr)
 	if acc == nil {
 		return 0, sdkerrors.Wrapf(sdkerrors.ErrUnknownAddress, "account %s does not exist", addr)
@@ -123,7 +180,7 @@ func (ak AccountKeeper) GetSequence(ctx sdk.Context, addr sdk.AccAddress) (uint6
 
 // GetNextAccountNumber returns and increments the global account number counter.
 // If the global account number is not set, it initializes it with value 0.
-func (ak AccountKeeper) GetNextAccountNumber(ctx sdk.Context) uint64 {
+func (ak accountKeeper) GetNextAccountNumber(ctx sdk.Context) uint64 {
 	var accNumber uint64
 	store := ctx.KVStore(ak.key)
 
@@ -150,7 +207,7 @@ func (ak AccountKeeper) GetNextAccountNumber(ctx sdk.Context) uint64 {
 
 // ValidatePermissions validates that the module account has been granted
 // permissions within its set of allowed permissions.
-func (ak AccountKeeper) ValidatePermissions(macc types.ModuleAccountI) error {
+func (ak accountKeeper) ValidatePermissions(macc types.ModuleAccountI) error {
 	permAddr := ak.permAddrs[macc.GetName()]
 	for _, perm := range macc.GetPermissions() {
 		if !permAddr.HasPermission(perm) {
@@ -162,7 +219,7 @@ func (ak AccountKeeper) ValidatePermissions(macc types.ModuleAccountI) error {
 }
 
 // GetModuleAddress returns an address based on the module name
-func (ak AccountKeeper) GetModuleAddress(moduleName string) sdk.AccAddress {
+func (ak accountKeeper) GetModuleAddress(moduleName string) sdk.AccAddress {
 	permAddr, ok := ak.permAddrs[moduleName]
 	if !ok {
 		return nil
@@ -172,7 +229,7 @@ func (ak AccountKeeper) GetModuleAddress(moduleName string) sdk.AccAddress {
 }
 
 // GetModuleAddressAndPermissions returns an address and permissions based on the module name
-func (ak AccountKeeper) GetModuleAddressAndPermissions(moduleName string) (addr sdk.AccAddress, permissions []string) {
+func (ak accountKeeper) GetModuleAddressAndPermissions(moduleName string) (addr sdk.AccAddress, permissions []string) {
 	permAddr, ok := ak.permAddrs[moduleName]
 	if !ok {
 		return addr, permissions
@@ -183,7 +240,7 @@ func (ak AccountKeeper) GetModuleAddressAndPermissions(moduleName string) (addr
 
 // GetModuleAccountAndPermissions gets the module account from the auth account store and its
 // registered permissions
-func (ak AccountKeeper) GetModuleAccountAndPermissions(ctx sdk.Context, moduleName string) (types.ModuleAccountI, []string) {
+func (ak accountKeeper) GetModuleAccountAndPermissions(ctx sdk.Context, moduleName string) (types.ModuleAccountI, []string) {
 	addr, perms := ak.GetModuleAddressAndPermissions(moduleName)
 	if addr == nil {
 		return nil, []string{}
@@ -208,17 +265,17 @@ func (ak AccountKeeper) GetModuleAccountAndPermissions(ctx sdk.Context, moduleNa
 
 // GetModuleAccount gets the module account from the auth account store, if the account does not
 // exist in the AccountKeeper, then it is created.
-func (ak AccountKeeper) GetModuleAccount(ctx sdk.Context, moduleName string) types.ModuleAccountI {
+func (ak accountKeeper) GetModuleAccount(ctx sdk.Context, moduleName string) types.ModuleAccountI {
 	acc, _ := ak.GetModuleAccountAndPermissions(ctx, moduleName)
 	return acc
 }
 
 // SetModuleAccount sets the module account to the auth account store
-func (ak AccountKeeper) SetModuleAccount(ctx sdk.Context, macc types.ModuleAccountI) {
+func (ak accountKeeper) SetModuleAccount(ctx sdk.Context, macc types.ModuleAccountI) {
 	ak.SetAccount(ctx, macc)
 }
 
-func (ak AccountKeeper) decodeAccount(bz []byte) types.AccountI {
+func (ak accountKeeper) decodeAccount(bz []byte) types.AccountI {
 	acc, err := ak.UnmarshalAccount(bz)
 	if err != nil {
 		panic(err)
@@ -228,22 +285,22 @@ func (ak AccountKeeper) decodeAccount(bz []byte) types.AccountI {
 }
 
 // MarshalAccount protobuf serializes an Account interface
-func (ak AccountKeeper) MarshalAccount(accountI types.AccountI) ([]byte, error) { // nolint:interfacer
+func (ak accountKeeper) MarshalAccount(accountI types.AccountI) ([]byte, error) { // nolint:interfacer
 	return ak.cdc.MarshalInterface(accountI)
 }
 
 // UnmarshalAccount returns an Account interface from raw encoded account
 // bytes of a Proto-based Account type
-func (ak AccountKeeper) UnmarshalAccount(bz []byte) (types.AccountI, error) {
+func (ak accountKeeper) UnmarshalAccount(bz []byte) (types.AccountI, error) {
 	var acc types.AccountI
 	return acc, ak.cdc.UnmarshalInterface(bz, &acc)
 }
 
 // GetCodec return codec.Codec object used by the keeper
-func (ak AccountKeeper) GetCodec() codec.BinaryCodec { return ak.cdc }
+func (ak accountKeeper) GetCodec() codec.BinaryCodec { return ak.cdc }
 
 // add getter for bech32Prefix
-func (ak AccountKeeper) getBech32Prefix() (string, error) {
+func (ak accountKeeper) getBech32Prefix() (string, error) {
 	bech32Codec, ok := ak.addressCdc.(bech32Codec)
 	if !ok {
 		return "", fmt.Errorf("unable cast addressCdc to bech32Codec; expected %T got %T", bech32Codec, ak.addressCdc)
diff --git a/x/auth/keeper/migrations.go b/x/auth/keeper/migrations.go
index 768bc7c10c..eb017e9baf 100644
--- a/x/auth/keeper/migrations.go
+++ b/x/auth/keeper/migrations.go
@@ -13,13 +13,13 @@ import (
 
 // Migrator is a struct for handling in-place store migrations.
 type Migrator struct {
-	keeper      AccountKeeper
+	keeper      accountKeeper
 	queryServer grpc.Server
 }
 
 // NewMigrator returns a new Migrator.
 func NewMigrator(keeper AccountKeeper, queryServer grpc.Server) Migrator {
-	return Migrator{keeper: keeper, queryServer: queryServer}
+	return Migrator{keeper: keeper.(accountKeeper), queryServer: queryServer}
 }
 
 // Migrate1to2 migrates from version 1 to 2.
diff --git a/x/auth/keeper/params.go b/x/auth/keeper/params.go
index 0236c7ae16..37bf932e74 100644
--- a/x/auth/keeper/params.go
+++ b/x/auth/keeper/params.go
@@ -6,12 +6,12 @@ import (
 )
 
 // SetParams sets the auth module's parameters.
-func (ak AccountKeeper) SetParams(ctx sdk.Context, params types.Params) {
+func (ak accountKeeper) SetParams(ctx sdk.Context, params types.Params) {
 	ak.paramSubspace.SetParamSet(ctx, &params)
 }
 
 // GetParams gets the auth module's parameters.
-func (ak AccountKeeper) GetParams(ctx sdk.Context) (params types.Params) {
+func (ak accountKeeper) GetParams(ctx sdk.Context) (params types.Params) {
 	ak.paramSubspace.GetParamSet(ctx, &params)
 	return
 }
diff --git a/x/auth/spec/08_agoric.md b/x/auth/spec/08_agoric.md
new file mode 100644
index 0000000000..678c441f08
--- /dev/null
+++ b/x/auth/spec/08_agoric.md
@@ -0,0 +1,86 @@
+<!--
+order: 8
+-->
+
+# Agoric
+
+## Intro
+
+Agoric has added a new type of vesting account, made some modifications
+to periodic vesting accounts, and has some comments to clarify the
+behavior of other vesting accounts.
+
+- Periodic vesting accounts now allow additional grants to be added
+to the account after they have been created. The new vesting schedule
+is merged with the existing schedule.
+- The new account type is clawback vesting, which is like periodic
+vesting, but unvested coins may be "clawed back" by the account
+which funded the initial grant of coins.  These accounts have
+independent schedules for unlocking (being available for transfer)
+and vesting (also unavailable for transfer, but also subject to
+clawback). Additional grants can be made to an existing account.
+Unvested coins may be staked, but staking rewards are subject to
+vesting (see details below). Staked (or unbonding) tokens are clawed
+back in their staked (unbonding) state.
+
+## Vesting Account Types
+
+### ClawbackVestingAccount
+
+[Snippet available after upstreaming.]
+
+Note that the `vesting_periods` field defines what is locked and subject to
+clawback. The `lockup_periods` field defines locking that is not subject to
+clawback with the same total amount but a separate schedule. Thus, tokens
+might be vested (immune from clawback) but still locked (unavailable for
+transfer).
+
+## Vesting Account Specification
+
+### Clawback Vesting Accounts
+
+Works like a Periodic vesting account, except that coins must be both vested
+and unlocked in order to be transferred. This allows coins to be vested, but
+still not available for transfer. For instance, you can have an account where
+the tokens vest monthly over two years, but are locked until 12 months. In
+this case, no coins can be transferred until the one year anniversary where
+half become transferrable, then one twelfth of the remainder each month
+thereafter.
+
+Since the commands to stake and unstake tokens do not specify the character
+of the funds to use (i.e. locked, vested, etc.), vesting accounts use a policy
+to determine how bonded and unbonding tokens are distributed. To determine
+the amount that is available for transfer (the only question most vesting
+accounts face), the policy is to maximize the number available for transfer
+by maximizing the locked tokens used for delegation. Slashing looks like
+tokens which remain forever bonded, and thus reduce the number of actual
+bonded and unbonded tokens which are encumbered to prevent transfer. This
+is the policy followed by all vesting accounts.
+
+But for clawback accounts, we distinguish between the encumbrance that is
+enforced preventing transfer and the right of the funder to retrieve the
+unvested amount from the account. The latter is not reduced by slashing,
+though slashing might limit the number of tokens which can be retrieved.
+
+Additional grants may be added to an existing `ClawbackVestingAccount` with
+their own schedule. Additional grants must come from the same account that
+provided the initial grant that created the account.
+
+Staking rewards are automatically added as such an additional grant following
+the current vesting schedule, with amounts scaled proportionally. (Staking
+rewards are given an immediate unlocking schedule.) The proportion follows
+the policy used to determine which tokens may be transferred - staked tokens
+prefer to be unvested first.
+
+### Transferring/Sending
+
+We've modified the `x/bank` mechanisms for vesting integration:
+
+- The `LockedCoins()` method takes a `sdk.Context` instead of a `Time`.
+
+## Glossary
+
+- Clawback: removal of unvested tokens from a ClawbackVestingAccount.
+- ClawbackVestingAccount: a vesting account specifying separate schedules for
+vesting (subject to clawback) and lockup (inability to transfer out of the
+account - the encumbrance implemented by the other vesting account types).
diff --git a/x/auth/spec/README.md b/x/auth/spec/README.md
index 1090bb6baa..1f2ebc060b 100644
--- a/x/auth/spec/README.md
+++ b/x/auth/spec/README.md
@@ -43,3 +43,4 @@ This module is used in the Cosmos Hub.
       * [REST](07_client.md#rest)
    * **[Vesting](07_client.md#vesting)**
       * [CLI](07_client.md#vesting#cli)
+8. **[Agoric](08_agoric.md)**
diff --git a/x/auth/vesting/client/cli/tx.go b/x/auth/vesting/client/cli/tx.go
index f2ef3ba67f..f8c9e5b1c5 100644
--- a/x/auth/vesting/client/cli/tx.go
+++ b/x/auth/vesting/client/cli/tx.go
@@ -18,6 +18,10 @@ import (
 // Transaction command flags
 const (
 	FlagDelayed = "delayed"
+	FlagDest    = "dest"
+	FlagLockup  = "lockup"
+	FlagMerge   = "merge"
+	FlagVesting = "vesting"
 )
 
 // GetTxCmd returns vesting module's transaction commands.
@@ -34,6 +38,9 @@ func GetTxCmd() *cobra.Command {
 		NewMsgCreateVestingAccountCmd(),
 		NewMsgCreatePermanentLockedAccountCmd(),
 		NewMsgCreatePeriodicVestingAccountCmd(),
+		NewMsgCreateClawbackVestingAccountCmd(),
+		NewMsgClawbackCmd(),
+		NewMsgReturnGrantsCmd(),
 	)
 
 	return txCmd
@@ -137,12 +144,13 @@ func NewMsgCreatePeriodicVestingAccountCmd() *cobra.Command {
 	cmd := &cobra.Command{
 		Use:   "create-periodic-vesting-account [to_address] [periods_json_file]",
 		Short: "Create a new vesting account funded with an allocation of tokens.",
-		Long: `A sequence of coins and period length in seconds. Periods are sequential, in that the duration of of a period only starts at the end of the previous period. The duration of the first period starts upon account creation. For instance, the following periods.json file shows 20 "test" coins vesting 30 days apart from each other.
+		Long:  `A sequence of coins and period length in seconds. Periods are sequential, in that the duration of a period only starts at the end of the previous period. The duration of the first period starts upon account creation.`,
+		Example: `The following periods.json file shows 20 "test" coins vesting 30 days apart from each other.
 		Where periods.json contains:
 
-		An array of coin strings and unix epoch times for coins to vest
+		An array of coin strings and durations for coins to vest
 { "start_time": 1625204910,
-"periods":[
+"period":[
  {
   "coins": "10test",
   "length_seconds":2592000 //30 days
@@ -166,35 +174,169 @@ func NewMsgCreatePeriodicVestingAccountCmd() *cobra.Command {
 				return err
 			}
 
-			contents, err := os.ReadFile(args[1])
+			startTime, periods, err := readScheduleFile(args[1])
 			if err != nil {
 				return err
 			}
 
-			var vestingData VestingData
+			merge, _ := cmd.Flags().GetBool(FlagMerge)
 
-			err = json.Unmarshal(contents, &vestingData)
-			if err != nil {
+			msg := types.NewMsgCreatePeriodicVestingAccount(clientCtx.GetFromAddress(), toAddr, startTime, periods, merge)
+			if err := msg.ValidateBasic(); err != nil {
 				return err
 			}
 
-			var periods []types.Period
+			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
+		},
+	}
+
+	cmd.Flags().Bool(FlagMerge, false, "Merge new amount and schedule with existing periodic vesting account, if any")
+	flags.AddTxFlagsToCmd(cmd)
+
+	return cmd
+}
+
+// readScheduleFile reads the file at path and unmarshals it to get the schedule.
+// Returns start time, periods, and error.
+func readScheduleFile(path string) (int64, []types.Period, error) {
+	contents, err := os.ReadFile(path)
+	if err != nil {
+		return 0, nil, err
+	}
+	var data VestingData
+	err = json.Unmarshal(contents, &data)
+	if err != nil {
+		return 0, nil, err
+	}
+	startTime := data.StartTime
+	var periods []types.Period
+	for i, p := range data.Periods {
+		amount, err := sdk.ParseCoinsNormalized(p.Coins)
+		if err != nil {
+			return 0, nil, err
+		}
+		if p.Length < 1 {
+			return 0, nil, fmt.Errorf("invalid period length of %d in period %d, length must be greater than 0", p.Length, i)
+		}
+		period := types.Period{Length: p.Length, Amount: amount}
+		periods = append(periods, period)
+	}
+	return startTime, periods, nil
+}
+
+// NewMsgCreateClawbackVestingAccountCmd returns a CLI command handler for creating a
+// MsgCreateClawbackVestingAccount transaction.
+func NewMsgCreateClawbackVestingAccountCmd() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "create-clawback-vesting-account [to_address]",
+		Short: "Create a new vesting account funded with an allocation of tokens, subject to clawback.",
+		Long: `Must provide a lockup periods file (--lockup), a vesting periods file (--vesting), or both.
+If both files are given, they must describe schedules for the same total amount.
+If one file is omitted, it will default to a schedule that immediately unlocks or vests the entire amount.
+The described amount of coins will be transferred from the --from address to the vesting account.
+Unvested coins may be "clawed back" by the funder with the clawback command.
+Coins may not be transferred out of the account if they are locked or unvested, but may be staked.
+Staking rewards are subject to a proportional vesting encumbrance.
+
+A periods file is a JSON object describing a sequence of unlocking or vesting events,
+with a start time and an array of coins strings and durations relative to the start or previous event.`,
+		Example: `Sample period file contents:
+		{ "start_time": 1625204910,
+	      "period": [
+			  {
+				  "coins": "10test",
+				  "length_seconds": 2592000 //30 days
+			  },
+			  {
+				"coins": "10test",
+				"length_seconds": 2592000 //30 days
+			}
+		]}
+	    `,
+		Args: cobra.ExactArgs(1),
+		RunE: func(cmd *cobra.Command, args []string) error {
+			clientCtx, err := client.GetClientTxContext(cmd)
+			if err != nil {
+				return err
+			}
 
-			for i, p := range vestingData.Periods {
+			toAddr, err := sdk.AccAddressFromBech32(args[0])
+			if err != nil {
+				return err
+			}
 
-				amount, err := sdk.ParseCoinsNormalized(p.Coins)
+			lockupFile, _ := cmd.Flags().GetString(FlagLockup)
+			vestingFile, _ := cmd.Flags().GetString(FlagVesting)
+			if lockupFile == "" && vestingFile == "" {
+				return fmt.Errorf("must specify at least one of %s or %s", FlagLockup, FlagVesting)
+			}
+			var lockupStart, vestingStart int64
+			var lockupPeriods, vestingPeriods []types.Period
+			if lockupFile != "" {
+				lockupStart, lockupPeriods, err = readScheduleFile(lockupFile)
 				if err != nil {
 					return err
 				}
+			}
+			if vestingFile != "" {
+				vestingStart, vestingPeriods, err = readScheduleFile(vestingFile)
+				if err != nil {
+					return err
+				}
+			}
+
+			commonStart, _ := types.AlignSchedules(lockupStart, vestingStart, lockupPeriods, vestingPeriods)
+
+			merge, _ := cmd.Flags().GetBool(FlagMerge)
+
+			msg := types.NewMsgCreateClawbackVestingAccount(clientCtx.GetFromAddress(), toAddr, commonStart, lockupPeriods, vestingPeriods, merge)
+			if err := msg.ValidateBasic(); err != nil {
+				return err
+			}
+
+			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
+		},
+	}
+
+	cmd.Flags().Bool(FlagMerge, false, "Merge new amount and schedule with existing ClawbackVestingAccount, if any")
+	cmd.Flags().String(FlagLockup, "", "path to file containing unlocking periods")
+	cmd.Flags().String(FlagVesting, "", "path to file containing vesting periods")
+	flags.AddTxFlagsToCmd(cmd)
+	return cmd
+}
+
+// NewMsgClawbackCmd returns a CLI command handler for creating a
+// MsgClawback transaction.
+func NewMsgClawbackCmd() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "clawback [address]",
+		Short: "Transfer unvested amount out of a ClawbackVestingAccount.",
+		Long: `Must be requested by the original funder address (--from).
+May provide a destination address (--dest), otherwise the coins return to the funder.
+Delegated or undelegating staking tokens will be transferred in the delegated (undelegating) state.
+The recipient is vulnerable to slashing, and must act to unbond the tokens if desired.`,
+		Args: cobra.ExactArgs(1),
+		RunE: func(cmd *cobra.Command, args []string) error {
+			clientCtx, err := client.GetClientTxContext(cmd)
+			if err != nil {
+				return err
+			}
+
+			addr, err := sdk.AccAddressFromBech32(args[0])
+			if err != nil {
+				return err
+			}
 
-				if p.Length < 0 {
-					return fmt.Errorf("invalid period length of %d in period %d, length must be greater than 0", p.Length, i)
+			var dest sdk.AccAddress
+			destString, _ := cmd.Flags().GetString(FlagDest)
+			if destString != "" {
+				dest, err = sdk.AccAddressFromBech32(destString)
+				if err != nil {
+					return fmt.Errorf("bad dest address: %w", err)
 				}
-				period := types.Period{Length: p.Length, Amount: amount}
-				periods = append(periods, period)
 			}
 
-			msg := types.NewMsgCreatePeriodicVestingAccount(clientCtx.GetFromAddress(), toAddr, vestingData.StartTime, periods)
+			msg := types.NewMsgClawback(clientCtx.GetFromAddress(), addr, dest)
 			if err := msg.ValidateBasic(); err != nil {
 				return err
 			}
@@ -203,7 +345,37 @@ func NewMsgCreatePeriodicVestingAccountCmd() *cobra.Command {
 		},
 	}
 
+	cmd.Flags().String(FlagDest, "", "address of destination (defaults to funder)")
 	flags.AddTxFlagsToCmd(cmd)
+	return cmd
+}
 
+// NewMsgReturnGrantsCmd returns a CLI command handler for creating a
+// MsgReturnGrantsCmd transaction.
+func NewMsgReturnGrantsCmd() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   "return-grants",
+		Short: "Transfer grants out of a vesting account.",
+		Long: `Must be authorized by the vesting account itself.
+All granted assets, including delegated and undelegating, vested and unvested,
+are transferred to the original funder of the account. Might not be complete if
+some vested assets have been transferred out of the account.
+Currently only supported for ClawbackVestingAccount.`,
+		Args: cobra.NoArgs,
+		RunE: func(cmd *cobra.Command, args []string) error {
+			clientCtx, err := client.GetClientTxContext(cmd)
+			if err != nil {
+				return err
+			}
+
+			msg := types.NewMsgReturnGrants(clientCtx.GetFromAddress())
+			if err := msg.ValidateBasic(); err != nil {
+				return err
+			}
+
+			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
+		},
+	}
+	flags.AddTxFlagsToCmd(cmd)
 	return cmd
 }
diff --git a/x/auth/vesting/client/testutil/suite.go b/x/auth/vesting/client/testutil/suite.go
index 7f56de2c1c..451d240fad 100644
--- a/x/auth/vesting/client/testutil/suite.go
+++ b/x/auth/vesting/client/testutil/suite.go
@@ -7,6 +7,9 @@ import (
 	"github.com/stretchr/testify/suite"
 
 	"github.com/cosmos/cosmos-sdk/client/flags"
+	"github.com/cosmos/cosmos-sdk/crypto/hd"
+	"github.com/cosmos/cosmos-sdk/crypto/keyring"
+	"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519"
 	clitestutil "github.com/cosmos/cosmos-sdk/testutil/cli"
 	"github.com/cosmos/cosmos-sdk/testutil/network"
 	sdk "github.com/cosmos/cosmos-sdk/types"
@@ -147,6 +150,407 @@ func (s *IntegrationTestSuite) TestNewMsgCreateVestingAccountCmd() {
 	}
 }
 
+func (s *IntegrationTestSuite) TestNewMsgCreatePeriodicVestingAccountCmd() {
+	val := s.network.Validators[0]
+	testCases := map[string]struct {
+		args         []string
+		expectErr    bool
+		expectedCode uint32
+		respType     proto.Message
+	}{
+		"create a periodic vesting account": {
+			args: []string{
+				sdk.AccAddress("addr5_______________").String(),
+				"testdata/periods1.json",
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+		"bad to address": {
+			args: []string{
+				"foo",
+				"testdata/periods1.json",
+			},
+			expectErr: true,
+		},
+		"bad from address": {
+			args: []string{
+				sdk.AccAddress("addr5_______________").String(),
+				"testdata/periods1.json",
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, "foo"),
+			},
+			expectErr: true,
+		},
+		"bad file": {
+			args: []string{
+				sdk.AccAddress("addr6_______________").String(),
+				"testdata/noexist",
+			},
+			expectErr: true,
+		},
+		"bad json": {
+			args: []string{
+				sdk.AccAddress("addr7_______________").String(),
+				"testdata/badjson",
+			},
+			expectErr: true,
+		},
+		"bad periods length": {
+			args: []string{
+				sdk.AccAddress("addr8_______________").String(),
+				"testdata/badperiod.json",
+			},
+			expectErr: true,
+		},
+		"bad periods amount": {
+			args: []string{
+				sdk.AccAddress("addr9_______________").String(),
+				"testdata/badperiod2.json",
+			},
+			expectErr: true,
+		},
+		"merge": {
+			args: []string{
+				sdk.AccAddress("addr9_______________").String(),
+				"testdata/periods1.json",
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+				"--merge",
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+	}
+
+	for name, tc := range testCases {
+		tc := tc
+
+		s.Run(name, func() {
+			clientCtx := val.ClientCtx
+
+			bw, err := clitestutil.ExecTestCLICmd(clientCtx, cli.NewMsgCreatePeriodicVestingAccountCmd(), tc.args)
+			if tc.expectErr {
+				s.Require().Error(err)
+			} else {
+				s.Require().NoError(err)
+				s.Require().NoError(clientCtx.Codec.UnmarshalJSON(bw.Bytes(), tc.respType), bw.String())
+
+				txResp := tc.respType.(*sdk.TxResponse)
+				s.Require().Equal(tc.expectedCode, txResp.Code)
+			}
+		})
+	}
+}
+
+func (s *IntegrationTestSuite) TestNewMsgCreateClawbackVestingAccountCmd() {
+	val := s.network.Validators[0]
+	for _, tc := range []struct {
+		name         string
+		args         []string
+		expectErr    bool
+		expectedCode uint32
+		respType     proto.Message
+	}{
+		{
+			name: "basic",
+			args: []string{
+				sdk.AccAddress("addr10______________").String(),
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/periods1.json"),
+				fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/periods1.json"),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+		{
+			name: "defaultLockup",
+			args: []string{
+				sdk.AccAddress("addr11______________").String(),
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/periods1.json"),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+		{
+			name: "defaultVesting",
+			args: []string{
+				sdk.AccAddress("addr12______________").String(),
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/periods1.json"),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+		{
+			name: "merge",
+			args: []string{
+				sdk.AccAddress("addr10______________").String(),
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/periods1.json"),
+				fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/periods1.json"),
+				fmt.Sprintf("--%s=%s", cli.FlagMerge, "true"),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+		{
+			name: "bad vesting addr",
+			args: []string{
+				"foo",
+			},
+			expectErr: true,
+		},
+		{
+			name: "no files",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad lockup filename",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+				fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/noexist"),
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad lockup json",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+				fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/badjson"),
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad lockup periods",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+				fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/badperiod.json"),
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad vesting filename",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+				fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/noexist"),
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad vesting json",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+				fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/badjson"),
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad vesting periods length",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+				fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/badperiod.json"),
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad vesting periods amount",
+			args: []string{
+				sdk.AccAddress("addr13______________").String(),
+				fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/badperiod2.json"),
+			},
+			expectErr: true,
+		},
+	} {
+		s.Run(tc.name, func() {
+			clientCtx := val.ClientCtx
+
+			bw, err := clitestutil.ExecTestCLICmd(clientCtx, cli.NewMsgCreateClawbackVestingAccountCmd(), tc.args)
+			if tc.expectErr {
+				s.Require().Error(err)
+			} else {
+				s.Require().NoError(err)
+				s.Require().NoError(clientCtx.Codec.UnmarshalJSON(bw.Bytes(), tc.respType), bw.String())
+
+				txResp := tc.respType.(*sdk.TxResponse)
+				s.Require().Equal(tc.expectedCode, txResp.Code)
+			}
+		})
+	}
+}
+
+func (s *IntegrationTestSuite) TestNewMsgReturnGrantsCmd() {
+	val := s.network.Validators[0]
+
+	consPrivKey := ed25519.GenPrivKey()
+	consPubKeyBz, err := s.cfg.Codec.MarshalInterfaceJSON(consPrivKey.PubKey())
+	s.Require().NoError(err)
+	s.Require().NotNil(consPubKeyBz)
+
+	info, _, err := val.ClientCtx.Keyring.NewMnemonic("NewClawback", keyring.English, sdk.FullFundraiserPath, keyring.DefaultBIP39Passphrase, hd.Secp256k1)
+	s.Require().NoError(err)
+
+	pubKey, err := info.GetPubKey()
+	s.Require().NoError(err)
+	addr := sdk.AccAddress(pubKey.Address())
+
+	_, err = clitestutil.ExecTestCLICmd(val.ClientCtx, cli.NewMsgCreateClawbackVestingAccountCmd(), []string{
+		addr.String(),
+		fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+		fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/periods1.json"),
+		fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/periods1.json"),
+		fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+		fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+		fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+	})
+	s.Require().NoError(err)
+
+	for _, tc := range []struct {
+		name         string
+		args         []string
+		expectErr    bool
+		expectedCode uint32
+		respType     proto.Message
+	}{
+		{
+			name: "basic",
+			args: []string{
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, addr),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+	} {
+		s.Run(tc.name, func() {
+			clientCtx := val.ClientCtx
+
+			bw, err := clitestutil.ExecTestCLICmd(clientCtx, cli.NewMsgReturnGrantsCmd(), tc.args)
+			if tc.expectErr {
+				s.Require().Error(err)
+			} else {
+				s.Require().NoError(err)
+				s.Require().NoError(clientCtx.Codec.UnmarshalJSON(bw.Bytes(), tc.respType), bw.String())
+
+				txResp := tc.respType.(*sdk.TxResponse)
+				s.Require().Equal(tc.expectedCode, txResp.Code)
+			}
+		})
+	}
+}
+
+func (s *IntegrationTestSuite) TestNewMsgClawbackCmd() {
+	val := s.network.Validators[0]
+	addr := sdk.AccAddress("addr30______________")
+
+	_, err := clitestutil.ExecTestCLICmd(val.ClientCtx, cli.NewMsgCreateClawbackVestingAccountCmd(), []string{
+		addr.String(),
+		fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+		fmt.Sprintf("--%s=%s", cli.FlagLockup, "testdata/periods1.json"),
+		fmt.Sprintf("--%s=%s", cli.FlagVesting, "testdata/periods1.json"),
+		fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+		fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+		fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+	})
+	s.Require().NoError(err)
+
+	for _, tc := range []struct {
+		name         string
+		args         []string
+		expectErr    bool
+		expectedCode uint32
+		respType     proto.Message
+	}{
+		{
+			name: "basic",
+			args: []string{
+				addr.String(),
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=%s", cli.FlagDest, sdk.AccAddress("addr32______________").String()),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+		{
+			name: "bad vesting addr",
+			args: []string{
+				"foo",
+			},
+			expectErr: true,
+		},
+		{
+			name: "bad dest addr",
+			args: []string{
+				addr.String(),
+				fmt.Sprintf("--%s=%s", cli.FlagDest, "bar"),
+			},
+			expectErr: true,
+		},
+		{
+			name: "default dest",
+			args: []string{
+				addr.String(),
+				fmt.Sprintf("--%s=%s", flags.FlagFrom, val.Address),
+				fmt.Sprintf("--%s=true", flags.FlagSkipConfirmation),
+				fmt.Sprintf("--%s=%s", flags.FlagBroadcastMode, flags.BroadcastBlock),
+				fmt.Sprintf("--%s=%s", flags.FlagFees, sdk.NewCoins(sdk.NewCoin(s.cfg.BondDenom, sdk.NewInt(10))).String()),
+			},
+			expectErr:    false,
+			expectedCode: 0,
+			respType:     &sdk.TxResponse{},
+		},
+	} {
+		s.Run(tc.name, func() {
+			clientCtx := val.ClientCtx
+
+			bw, err := clitestutil.ExecTestCLICmd(clientCtx, cli.NewMsgClawbackCmd(), tc.args)
+			if tc.expectErr {
+				s.Require().Error(err)
+			} else {
+				s.Require().NoError(err)
+				s.Require().NoError(clientCtx.Codec.UnmarshalJSON(bw.Bytes(), tc.respType), bw.String())
+
+				txResp := tc.respType.(*sdk.TxResponse)
+				s.Require().Equal(tc.expectedCode, txResp.Code)
+			}
+		})
+	}
+}
+
 func (s *IntegrationTestSuite) TestNewMsgCreatePermanentLockedAccountCmd() {
 	val := s.network.Validators[0]
 
diff --git a/x/auth/vesting/client/testutil/testdata/badjson b/x/auth/vesting/client/testutil/testdata/badjson
new file mode 100644
index 0000000000..aad60f4a0e
--- /dev/null
+++ b/x/auth/vesting/client/testutil/testdata/badjson
@@ -0,0 +1 @@
+Not JSON data.
diff --git a/x/auth/vesting/client/testutil/testdata/badperiod.json b/x/auth/vesting/client/testutil/testdata/badperiod.json
new file mode 100644
index 0000000000..e580e83143
--- /dev/null
+++ b/x/auth/vesting/client/testutil/testdata/badperiod.json
@@ -0,0 +1,9 @@
+{
+    "start_time": 1625204910,
+    "periods": [
+        {
+            "coins": "10test",
+            "length_seconds": -500
+        }
+    ]
+}
diff --git a/x/auth/vesting/client/testutil/testdata/badperiod2.json b/x/auth/vesting/client/testutil/testdata/badperiod2.json
new file mode 100644
index 0000000000..f7ffdbf599
--- /dev/null
+++ b/x/auth/vesting/client/testutil/testdata/badperiod2.json
@@ -0,0 +1,9 @@
+{
+    "start_time": 1625204910,
+    "periods": [
+        {
+            "coins": "-10test",
+            "length_seconds": 500
+        }
+    ]
+}
diff --git a/x/auth/vesting/client/testutil/testdata/periods1.json b/x/auth/vesting/client/testutil/testdata/periods1.json
new file mode 100644
index 0000000000..9c2c0a0d89
--- /dev/null
+++ b/x/auth/vesting/client/testutil/testdata/periods1.json
@@ -0,0 +1,13 @@
+{
+    "start_time": 1625204910,
+    "periods": [
+        {
+            "coins": "10stake",
+            "length_seconds": 2592000
+        },
+        {
+            "coins": "10stake",
+            "length_seconds":2592000
+        }
+    ]
+}
diff --git a/x/auth/vesting/cmd/vestcalc/README.md b/x/auth/vesting/cmd/vestcalc/README.md
new file mode 100644
index 0000000000..a445a7b4a8
--- /dev/null
+++ b/x/auth/vesting/cmd/vestcalc/README.md
@@ -0,0 +1,172 @@
+# `vestcalc`: A vesting schedule calculator
+
+A periodic vesting account has its vesting schedule configured as a sequence
+of vesting events, spaced by the relative time between them, in seconds.
+Most vesting agreements, however, are specified in terms of a number of
+monthly events from a given start time, possibly subject to one or more
+vesting "cliffs" which delay vesting until at or after the cliff.
+
+This tool can generate a vesting schedule given the parameters above,
+and can translate a vesting schedule into readable timestamps.
+
+This tool correctly handles:
+
+- clipping event dates to the end of the month (e.g. vesting on the 31st of
+  the month happens on the 30th in June);
+- daylight saving time;
+- leap years;
+- gigantic amounts (up to 255-bit);
+- multiple denominations.
+
+Times are interpreted in the local timezone unless explicitly overridden,
+since the desired vesting schedule is commonly specified in local time.
+To use another timezone, set your `TZ` environment variable before
+running the command.
+
+## Build and install
+
+Run `go install` in this directory, which will create or update the
+`vestcalc` binary in (by default) your `~/go/bin` directory. See the
+[documentation](https://pkg.go.dev/cmd/go) for the `go` command-line
+tool for other options.
+
+## Schedule format
+
+Schedules are expressed in the format expected by the `create-periodic-vesting-account`
+or `create-clawback-vesting-account` cli commands, namely a JSON
+object with the members:
+
+- `"start_time"`: integer UNIX time;
+- `"periods"`: an array of objects describing vesting events with members:
+    - "coins": string giving the text coins format for the additional amount vested by this event;
+    - "length_seconds": positive integer seconds from the last vesting event, or from the start time for the first vesting event.
+
+For instance:
+
+```
+{
+  "start_time": 1700000000,
+  "periods": [
+    {
+      "coins": "10000000uatom,500000000ubld",
+      "length_seconds": 2678400
+    },
+    {
+      "coins": "500000000ubld",
+      "length_seconds": 31536000
+    }
+  ]
+}
+
+```
+
+## Writing a schedule
+
+When the `--write` flag is set, the tool will write a schedule to stdout.
+The following flags control the output:
+
+- `--coins:` The total coins to vest, e.g. `100ubld,50urun`.
+- `--months`: The total number of months to complete vesting.
+- `--start`: The vesting start time: i.e. the first event happens in the
+  next month. Specified in the format `YYYY-MM-DD` or `YYYY-MM-DDThh:mm`,
+  e.g. `2006-01-02T15:04` for 3:04pm on January 2, 2006.
+- `--time`: The time of day (in the local timezone) of the vesting events, in 24-hour HH:MM format.
+  Defaults to midnight.
+- `--cliffs`: Vesting cliffs in `YYYY-MM-DD` or `YYYY-MM-DDThh:mm`
+  format. Only the latest one will have any effect, but it is useful to let
+  the computer do that calculation to avoid mistakes. Multiple cliff dates
+  can be separated by commas or given as multiple arguments. Cliffs are not required.
+
+The vesting events will occur each month following the start time on the same
+day of the month (or the last day of the month, if the month does not have a
+sufficient number of days), for the specified number of months. The total coins
+to vest will be divided as evenly as possible among all the vesting events.
+Lastly, all events before the last cliff time, if any, are consolidated into a single event
+at the last cliff time with the sum of the event amounts.
+
+## Reading a schedule
+
+When the `--read` flag is set, the tool will read a schedule from
+stdin and write the vesting events in absolute time to stdout.
+
+## Examples
+
+```
+$ vestcalc --write --start=2021-01-01 --coins=1000000000ubld \
+> --months=24 --time=09:00 --cliffs=2022-01-15T00:00 | \
+> vestcalc --read
+[
+    2022-01-15T00:00: 500000000ubld
+    2022-02-01T09:00: 41666666ubld
+    2022-03-01T09:00: 41666667ubld
+    2022-04-01T09:00: 41666667ubld
+    2022-05-01T09:00: 41666666ubld
+    2022-06-01T09:00: 41666667ubld
+    2022-07-01T09:00: 41666667ubld
+    2022-08-01T09:00: 41666666ubld
+    2022-09-01T09:00: 41666667ubld
+    2022-10-01T09:00: 41666667ubld
+    2022-11-01T09:00: 41666666ubld
+    2022-12-01T09:00: 41666667ubld
+    2023-01-01T09:00: 41666667ubld
+]
+$ vestcalc --write --start=2021-01-01 --coins=1000000000ubld \
+> --months=24 --time=09:00 --cliffs=2022-01-15T00:00
+{
+  "start_time": 1609488000,
+  "periods": [
+    {
+      "coins": "500000000ubld",
+      "length_seconds": 32745600
+    },
+    {
+      "coins": "41666666ubld",
+      "length_seconds": 1501200
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2419200
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2674800
+    },
+    {
+      "coins": "41666666ubld",
+      "length_seconds": 2592000
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2678400
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2592000
+    },
+    {
+      "coins": "41666666ubld",
+      "length_seconds": 2678400
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2678400
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2592000
+    },
+    {
+      "coins": "41666666ubld",
+      "length_seconds": 2678400
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2595600
+    },
+    {
+      "coins": "41666667ubld",
+      "length_seconds": 2678400
+    }
+  ]
+}
+```
diff --git a/x/auth/vesting/cmd/vestcalc/vestcalc.go b/x/auth/vesting/cmd/vestcalc/vestcalc.go
new file mode 100644
index 0000000000..b6eedb4b7f
--- /dev/null
+++ b/x/auth/vesting/cmd/vestcalc/vestcalc.go
@@ -0,0 +1,575 @@
+package main
+
+import (
+	"encoding/json"
+	"flag"
+	"fmt"
+	"io"
+	"os"
+	"strings"
+	"time"
+
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	"github.com/cosmos/cosmos-sdk/x/auth/vesting/client/cli"
+)
+
+// vestcalc is a utility for creating or reading schedule files
+// for use in some vesting account types.  See README.md for usage.
+
+// divide returns the division of total as evenly as possible.
+// Divisor must be 1 or greater and total must be nonnegative.
+func divide(total sdk.Int, divisor int) ([]sdk.Int, error) {
+	if divisor < 1 {
+		return nil, fmt.Errorf("divisions must be 1 or greater")
+	}
+	div64 := int64(divisor)
+	if total.IsNegative() {
+		return nil, fmt.Errorf("total must be nonnegative")
+	}
+	divisions := make([]sdk.Int, divisor)
+
+	// Ideally we could compute total of the first i divisions as
+	//     cumulative(i) = floor((total * i) / divisor)
+	// and so
+	//     divisions[i] = cumulative(i + 1) - cumulative(i)
+	// but this could lead to numeric overflow for large values of total.
+	// Instead, we'll compute
+	//     truncated = floor(total / divisor)
+	// so that
+	//     total = truncated * divisor + remainder
+	// where remainder < divisor, then divide the remainder via the
+	// above algorithm - which now won't overflow - and sum the
+	// truncated and slices of the remainder to form the divisions.
+	truncated := total.QuoRaw(div64)
+	remainder := total.ModRaw(div64)
+	cumulative := sdk.NewInt(0) // portion of remainder which has been doled out
+	for i := int64(0); i < div64; i++ {
+		// multiply will not overflow since remainder and div64 are < 2^63
+		nextCumulative := remainder.MulRaw(i + 1).QuoRaw(div64)
+		divisions[i] = truncated.Add(nextCumulative.Sub(cumulative))
+		cumulative = nextCumulative
+	}
+
+	// Integrity check
+	sum := sdk.NewInt(0)
+	for _, x := range divisions {
+		sum = sum.Add(x)
+	}
+	if !sum.Equal(total) {
+		return nil, fmt.Errorf("failed integrity check: divisions of %v sum to %d, should be %d", divisions, sum, total)
+	}
+	return divisions, nil
+}
+
+// divideCoins divides the coins into divisor separate parts as evenly as possible.
+// Divisor must be positive. Returns an array holding the division.
+func divideCoins(coins sdk.Coins, divisor int) ([]sdk.Coins, error) {
+	if divisor < 1 {
+		return nil, fmt.Errorf("divisor must be 1 or greater")
+	}
+	divisions := make([]sdk.Coins, divisor)
+	divisionsByDenom := make(map[string][]sdk.Int)
+	for _, coin := range coins {
+		dividedCoin, err := divide(coin.Amount, divisor)
+		if err != nil {
+			return nil, fmt.Errorf("cannot divide %s: %v", coin.Denom, err)
+		}
+		divisionsByDenom[coin.Denom] = dividedCoin
+	}
+	for i := 0; i < divisor; i++ {
+		newCoins := sdk.NewCoins()
+		for _, coin := range coins {
+			c := sdk.NewCoin(coin.Denom, divisionsByDenom[coin.Denom][i])
+			newCoins = newCoins.Add(c)
+		}
+		divisions[i] = newCoins
+	}
+	// Integrity check
+	sum := sdk.NewCoins()
+	for _, c := range divisions {
+		sum = sum.Add(c...)
+	}
+	if !sum.IsEqual(coins) {
+		return nil, fmt.Errorf("failed integrity check: divisions of %v sum to %s, should be %s", divisions, sum, coins)
+	}
+	return divisions, nil
+}
+
+// monthlyVestTimes generates timestamps for successive months after startTime.
+// The monthly events occur at the given time of day. If the month is not
+// long enough for the desired date, the last day of the month is used.
+// The number of months must be positive.
+func monthlyVestTimes(startTime time.Time, months int, timeOfDay time.Time) ([]time.Time, error) {
+	if months < 1 {
+		return nil, fmt.Errorf("must have at least one vesting period")
+	}
+	location := startTime.Location()
+	hour := timeOfDay.Hour()
+	minute := timeOfDay.Minute()
+	second := timeOfDay.Second()
+	times := make([]time.Time, months)
+	for i := 1; i <= months; i++ {
+		tm := startTime.AddDate(0, i, 0)
+		if tm.Day() != startTime.Day() {
+			// The starting day-of-month cannot fit in this month,
+			// and we've wrapped to the next month. Back up to the
+			// end of the previous month.
+			tm = tm.AddDate(0, 0, -tm.Day())
+		}
+		times[i-1] = time.Date(tm.Year(), tm.Month(), tm.Day(), hour, minute, second, 0, location)
+	}
+	// Integrity check: dates must be sequential and 26-33 days apart.
+	// (Jan 31 to Feb 28 or Feb 28 to Mar 31, plus slop for DST.)
+	lastTime := startTime
+	for _, tm := range times {
+		duration := tm.Sub(lastTime)
+		if duration < 26*24*time.Hour {
+			return nil, fmt.Errorf("vesting dates too close: %v and %v", lastTime, tm)
+		}
+		if duration > 33*24*time.Hour {
+			return nil, fmt.Errorf("vesting dates too distant: %v and %v", lastTime, tm)
+		}
+		lastTime = tm
+	}
+	return times, nil
+}
+
+// marshalVestingData writes the vesting data as JSON.
+func marshalVestingData(data cli.VestingData) ([]byte, error) {
+	return json.MarshalIndent(data, "", "  ")
+}
+
+// unmarshalVestingData parses the vesting data from JSON.
+func unmarshalVestingData(bz []byte) (cli.VestingData, error) {
+	data := cli.VestingData{}
+	err := json.Unmarshal(bz, &data)
+	return data, err
+}
+
+// event represents a single vesting event with an absolute time.
+type event struct {
+	Time  time.Time
+	Coins sdk.Coins
+}
+
+// zipEvents generates events by zipping corresponding amounts and times
+// from equal-sized arrays, returning an event array of the same size.
+func zipEvents(divisions []sdk.Coins, times []time.Time) ([]event, error) {
+	n := len(divisions)
+	if len(times) != n {
+		return nil, fmt.Errorf("amount and time arrays are unequal")
+	}
+	events := make([]event, n)
+	for i := 0; i < n; i++ {
+		events[i] = event{Time: times[i], Coins: divisions[i]}
+	}
+	return events, nil
+}
+
+// marshalEvents returns a printed representation of events.
+// nolint:unparam
+func marshalEvents(events []event) ([]byte, error) {
+	var b strings.Builder
+	b.WriteString("[\n")
+	for _, e := range events {
+		b.WriteString("    ")
+		b.WriteString(formatIso(e.Time))
+		b.WriteString(": ")
+		b.WriteString(e.Coins.String())
+		b.WriteString("\n")
+	}
+	b.WriteString("]")
+	return []byte(b.String()), nil
+}
+
+// applyCliff accumulates vesting events before or at the cliff time
+// into a single event, leaving subsequent events unchanged.
+func applyCliff(events []event, cliff time.Time) ([]event, error) {
+	newEvents := []event{}
+	preCliffAmount := sdk.NewCoins()
+	i := 0
+	for ; i < len(events) && !events[i].Time.After(cliff); i++ {
+		preCliffAmount = preCliffAmount.Add(events[i].Coins...)
+	}
+	if !preCliffAmount.IsZero() {
+		cliffEvent := event{Time: cliff, Coins: preCliffAmount}
+		newEvents = append(newEvents, cliffEvent)
+	}
+	for ; i < len(events); i++ {
+		newEvents = append(newEvents, events[i])
+	}
+
+	// integrity check
+	oldTotal := sdk.NewCoins()
+	for _, e := range events {
+		oldTotal = oldTotal.Add(e.Coins...)
+	}
+	newTotal := sdk.NewCoins()
+	for _, e := range newEvents {
+		newTotal = newTotal.Add(e.Coins...)
+	}
+	if !oldTotal.IsEqual(newTotal) {
+		return nil, fmt.Errorf("applying vesting cliff changed total from %s to %s", oldTotal, newTotal)
+	}
+
+	return newEvents, nil
+}
+
+// eventsToVestingData converts the events to VestingData with the given start time.
+func eventsToVestingData(startTime time.Time, events []event) cli.VestingData {
+	periods := []cli.InputPeriod{}
+	lastTime := startTime
+	for _, e := range events {
+		dur := e.Time.Sub(lastTime)
+		p := cli.InputPeriod{
+			Coins:  e.Coins.String(),
+			Length: int64(dur.Seconds()),
+		}
+		periods = append(periods, p)
+		lastTime = e.Time
+	}
+	return cli.VestingData{
+		StartTime: startTime.Unix(),
+		Periods:   periods,
+	}
+}
+
+// vestingDataToEvents converts the vesting data to absolute-timestamped events.
+func vestingDataToEvents(data cli.VestingData) ([]event, error) {
+	startTime := time.Unix(data.StartTime, 0)
+	events := []event{}
+	lastTime := startTime
+	for _, p := range data.Periods {
+		coins, err := sdk.ParseCoinsNormalized(p.Coins)
+		if err != nil {
+			return nil, err
+		}
+		newTime := lastTime.Add(time.Duration(p.Length) * time.Second)
+		e := event{
+			Time:  newTime,
+			Coins: coins,
+		}
+		events = append(events, e)
+		lastTime = newTime
+	}
+	return events, nil
+}
+
+// Time utilities
+
+// nolint:unused
+const day = 24 * time.Hour
+
+// formatDuration returns a duration in a string like "3d4h3m0.5s".
+// It follows time.Duration.String() except that it includes 24-hour days.
+// NOTE: Does not reflect daylight savings changes.
+// nolint:deadcode,unused
+func formatDuration(d time.Duration) string {
+	s := ""
+	if d < 0 {
+		d = -d
+		s = "-"
+	}
+	if d < day {
+		// handle several special cases
+		return s + d.String()
+	}
+	// Now we know days are the most significant unit,
+	// so all other units should be present
+	r := d
+	days := int64(r / day)
+	r %= day // remainder
+	s += fmt.Sprint(days) + "d"
+	hours := int64(r / time.Hour)
+	r %= time.Hour
+	s += fmt.Sprint(hours) + "h"
+	minutes := int64(r / time.Minute)
+	r %= time.Minute
+	s += fmt.Sprint(minutes) + "m"
+	seconds := int64(r / time.Second)
+	r %= time.Second
+	s += fmt.Sprint(seconds) // no suffix yet
+	if r != 0 {
+		// Follow normal Duration formatting, but need to avoid
+		// the special handling of fractional seconds.
+		r += time.Second
+		frac := r.String()
+		// append skipping the leading "1"
+		return s + frac[1:] // adds the suffix
+	}
+	return s + "s" // now the suffix
+}
+
+// maxTime gives the maximum of a set of times, or the zero time if empty.
+func maxTime(cliffs []time.Time) time.Time {
+	tm := time.Time{}
+	for _, c := range cliffs {
+		if c.After(tm) {
+			tm = c
+		}
+	}
+	return tm
+}
+
+// shortIsoFmt specifies ISO 8601 without seconds or timezone.
+// Note: when parsing, timezone is UTC unless overridden.
+const shortIsoFmt = "2006-01-02T15:04"
+
+// Common ISO-8601 formats for local day/time.
+var localIsoFormats = []string{
+	"2006-01-02",
+	"2006-01-02T15:04",
+	"2006-01-02T15:04:05",
+}
+
+// parseIso tries to parse the given string as some common prefix of ISO-8601.
+// "Common" means the least significant unit is day, minute, or second.
+// The time will be in local time unless a timezone specifier is given.
+func parseIso(s string) (time.Time, error) {
+	// Try local (no explicit timezone) formats first.
+	for _, fmt := range localIsoFormats {
+		tm, err := time.ParseInLocation(fmt, s, time.Local)
+		if err == nil {
+			return tm, nil
+		}
+	}
+	// Now try the full format.
+	return time.Parse(time.RFC3339, s)
+}
+
+// formatIso formats the time in shortIso format in local time.
+func formatIso(tm time.Time) string {
+	return tm.Format(shortIsoFmt)
+}
+
+// hhmmFmt specifies an HH:MM time format to generate time.Time values
+// where only hours, minutes, seconds are used.
+const hhmmFmt = "15:04"
+
+// Custom flag types
+
+// isoDate is time.Time as a flag.Value in shortIsoFmt.
+type isoDate struct{ time.Time }
+
+var _ flag.Value = &isoDate{}
+
+// Set implements flag.Value.Set().
+func (id *isoDate) Set(s string) error {
+	t, err := parseIso(s)
+	if err != nil {
+		return err
+	}
+	id.Time = t
+	return nil
+}
+
+// String implements flag.Value.String().
+func (id *isoDate) String() string {
+	return formatIso(id.Time)
+}
+
+// isoDateFlag makes a new isoDate flag, accessed as a time.Time.
+func isoDateFlag(name string, usage string) *time.Time {
+	id := isoDate{time.Time{}}
+	flag.CommandLine.Var(&id, name, usage)
+	return &id.Time
+}
+
+// isoDateList is []time.Time as a flag.Value in repeated or comma-separated shortIsoFmt.
+type isoDateList []time.Time
+
+var _ flag.Value = &isoDateList{}
+
+// Set implements flag.Value.Set().
+func (dates *isoDateList) Set(s string) error {
+	for _, ds := range strings.Split(s, ",") {
+		d, err := parseIso(ds)
+		if err != nil {
+			return err
+		}
+		*dates = append(*dates, d) // accumulates repeated flag arguments
+	}
+	return nil
+}
+
+// String implements flag.Value.String().
+func (dates *isoDateList) String() string {
+	s := ""
+	for _, t := range *dates {
+		if s == "" {
+			s = formatIso(t)
+		} else {
+			s = s + "," + formatIso(t)
+		}
+	}
+	return s
+}
+
+// isoDateListFlag makes a new isoDateList flag.
+func isoDateListFlag(name string, usage string) *isoDateList {
+	dates := isoDateList([]time.Time{})
+	flag.Var(&dates, name, usage)
+	return &dates
+}
+
+// isoTime is time.Time as a flagValue in HH:MM format.
+type isoTime struct{ time.Time }
+
+var _ flag.Value = &isoTime{}
+
+// Set implements flag.Value.Set().
+func (it *isoTime) Set(s string) error {
+	t, err := time.Parse(hhmmFmt, s)
+	if err != nil {
+		return err
+	}
+	it.Time = t
+	return nil
+}
+
+// String implements flag.Value.String().
+func (it *isoTime) String() string {
+	return it.Format(hhmmFmt)
+}
+
+// isoTimeFlag makes a new isoTime flag, accessed as a time.Time.
+func isoTimeFlag(name string, value string, usage string) *time.Time {
+	t, err := time.Parse(hhmmFmt, value)
+	if err != nil {
+		t = time.Time{}
+	}
+	it := isoTime{t}
+	flag.CommandLine.Var(&it, name, usage)
+	return &it.Time
+}
+
+var (
+	flagStart  = isoDateFlag("start", "Start date for the vesting in format 2006-01-02T15:04 (local time).")
+	flagMonths = flag.Int("months", 1, "Number of months to vest over.")
+	flagCoins  = flag.String("coins", "", "Total coins to vest.")
+	flagTime   = isoTimeFlag("time", "00:00", "Time of day for vesting, e.g. 15:04.")
+	flagCliffs = isoDateListFlag("cliffs", "Vesting cliffs in format 2006-01-02T15:04 (local time).")
+	flagRead   = flag.Bool("read", false, "Read periods file from stdin and print dates relative to start.")
+	flagWrite  = flag.Bool("write", false, "Write periods file to stdout.")
+)
+
+// readCmd reads a schedule file from stdin and writes a sequence of vesting
+// events in local time to stdout. See README.md for the format.
+func readCmd() {
+	bzIn, err := io.ReadAll(os.Stdin)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "cannot read stdin: %v", err)
+		return
+	}
+	vestingData, err := unmarshalVestingData(bzIn)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "cannot decode vesting data: %v", err)
+		return
+	}
+	events, err := vestingDataToEvents(vestingData)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "cannot convert vesting data: %v", err)
+	}
+	bzOut, err := marshalEvents(events)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "cannot encode events: %v", err)
+		return
+	}
+	fmt.Println(string(bzOut))
+}
+
+// writeConfig bundles data needed for the write operation.
+type writeConfig struct {
+	// Coins is the total amount to be vested.
+	Coins sdk.Coins
+	// Months is the number of months to vest over. Must be positive.
+	Months    int
+	TimeOfDay time.Time
+	Start     time.Time
+	Cliffs    []time.Time
+}
+
+// genWriteConfig generates a writeConfig from flag settings and validates it.
+func genWriteConfig() (writeConfig, error) {
+	wc := writeConfig{}
+	coins, err := sdk.ParseCoinsNormalized(*flagCoins)
+	if err != nil {
+		return wc, fmt.Errorf("cannot parse --coins: %v", err)
+	}
+	wc.Coins = coins
+	if *flagMonths < 1 {
+		return wc, fmt.Errorf("must use a positive number of months")
+	}
+	wc.Months = *flagMonths
+	wc.TimeOfDay = *flagTime
+	wc.Start = *flagStart
+	wc.Cliffs = *flagCliffs
+	return wc, nil
+}
+
+// generateEvents generates vesting events from the writeConfig.
+func (wc writeConfig) generateEvents() ([]event, error) {
+	divisions, err := divideCoins(wc.Coins, wc.Months)
+	if err != nil {
+		return nil, fmt.Errorf("vesting amount division failed: %v", err)
+	}
+	times, err := monthlyVestTimes(wc.Start, wc.Months, wc.TimeOfDay)
+	if err != nil {
+		return nil, fmt.Errorf("vesting time calcuation failed: %v", err)
+	}
+	events, err := zipEvents(divisions, times)
+	if err != nil {
+		return nil, fmt.Errorf("vesting event generation failed: %v", err)
+	}
+	if len(wc.Cliffs) > 0 {
+		last := maxTime(wc.Cliffs)
+		events, err = applyCliff(events, last)
+		if err != nil {
+			return nil, fmt.Errorf("vesting cliff failed: %v", err)
+		}
+	}
+	return events, nil
+}
+
+// convertRelative converts absolute-time events to VestingData relative to the Start time.
+func (wc writeConfig) convertRelative(events []event) cli.VestingData {
+	return eventsToVestingData(wc.Start, events)
+}
+
+// writeCmd generates a set of vesting events based on parsed flags
+// and writes a schedule file to stdout.
+func writeCmd() {
+	wc, err := genWriteConfig()
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "bad write configuration: %v", err)
+		return
+	}
+	events, err := wc.generateEvents()
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "cannot generate events: %v", err)
+		return
+	}
+	vestingData := wc.convertRelative(events)
+	bz, err := marshalVestingData(vestingData)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "cannot marshal vesting data: %v", err)
+		return
+	}
+	fmt.Println(string(bz))
+}
+
+// main parses the flags and executes a subcommand based on flags.
+// See README.md for flags and subcommands.
+func main() {
+	flag.Parse()
+	switch {
+	case *flagRead && !*flagWrite:
+		readCmd()
+	case *flagWrite && !*flagRead:
+		writeCmd()
+	default:
+		fmt.Fprintln(os.Stderr, "Must specify one of --read or --write")
+		flag.Usage()
+		os.Exit(1)
+	}
+}
diff --git a/x/auth/vesting/cmd/vestcalc/vestcalc_test.go b/x/auth/vesting/cmd/vestcalc/vestcalc_test.go
new file mode 100644
index 0000000000..70d9fb9dd0
--- /dev/null
+++ b/x/auth/vesting/cmd/vestcalc/vestcalc_test.go
@@ -0,0 +1,384 @@
+package main
+
+import (
+	// "encoding/json"
+	"reflect"
+	"testing"
+	"time"
+
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	"github.com/cosmos/cosmos-sdk/x/auth/vesting/client/cli"
+)
+
+const (
+	billion = int64(1000 * 1000 * 1000)
+)
+
+func iso(s string) time.Time {
+	t, err := parseIso(s)
+	if err != nil {
+		panic(err)
+	}
+	return t
+}
+
+func hhmm(s string) time.Time {
+	t, err := time.Parse(hhmmFmt, s)
+	if err != nil {
+		panic(err)
+	}
+	return t
+}
+
+func coins(s string) sdk.Coins {
+	c, err := sdk.ParseCoinsNormalized(s)
+	if err != nil {
+		panic(err)
+	}
+	return c
+}
+
+func evt(ts string, cs string) event {
+	tm := iso(ts)
+	c := coins(cs)
+	return event{Time: tm, Coins: c}
+}
+
+func TestDivision(t *testing.T) {
+	for _, tt := range []struct {
+		name      string
+		total     int64
+		divisions int
+		want      []int64
+	}{
+		{"zeroparts", 99, 0, nil},
+		{"negparts", 99, -3, nil},
+		{"negtot", -25, 7, nil},
+		{"onepart", 123, 1, []int64{123}},
+		{"twoparts_even", 32, 2, []int64{16, 16}},
+		{"twoparts_odd", 17, 2, []int64{8, 9}},
+		{"hard", 25, 7, []int64{3, 4, 3, 4, 3, 4, 4}},
+		{"big", 30 * billion, 3, []int64{
+			10 * billion, 10 * billion, 10 * billion,
+		}},
+		{"huge", billion * billion, 10, []int64{
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+			100 * 1000 * 1000 * billion,
+		}},
+		{"huge_hard", billion*billion + 7, 10, []int64{
+			100 * 1000 * 1000 * billion,
+			100*1000*1000*billion + 1,
+			100*1000*1000*billion + 1,
+			100 * 1000 * 1000 * billion,
+			100*1000*1000*billion + 1,
+			100*1000*1000*billion + 1,
+			100 * 1000 * 1000 * billion,
+			100*1000*1000*billion + 1,
+			100*1000*1000*billion + 1,
+			100*1000*1000*billion + 1,
+		}},
+	} {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := divide(sdk.NewInt(tt.total), tt.divisions)
+			if err != nil {
+				if tt.want != nil {
+					t.Fatalf("divide got error %v", err)
+				}
+				return
+			}
+			if len(got) != tt.divisions || len(got) != len(tt.want) {
+				t.Fatalf("divide returned wrong size: got %d, want %d", len(got), len(tt.want))
+			}
+			for i := 0; i < len(got); i++ {
+				if !got[i].Equal(sdk.NewInt(tt.want[i])) {
+					t.Errorf("divide got %v, want %v", got, tt.want)
+				}
+			}
+			if got != nil {
+				sum := sdk.NewInt(0)
+				for _, x := range got {
+					sum = sum.Add(x)
+				}
+				if !sum.Equal(sdk.NewInt(tt.total)) {
+					t.Errorf("divide total got %v, want %v", sum, tt.total)
+				}
+			}
+		})
+	}
+}
+
+func TestDivideCoins(t *testing.T) {
+	for _, tt := range []struct {
+		name      string
+		coins     sdk.Coins
+		divisions int
+		want      []sdk.Coins
+	}{
+		{
+			name:      "one_denom",
+			coins:     coins("5ubld"),
+			divisions: 3,
+			want:      []sdk.Coins{coins("1ubld"), coins("2ubld"), coins("2ubld")},
+		},
+		{
+			name:      "mixed_gaps",
+			coins:     coins("3xxx,2yyy"),
+			divisions: 6,
+			want: []sdk.Coins{
+				coins(""),
+				coins("1xxx"),
+				coins("1yyy"),
+				coins("1xxx"),
+				coins(""),
+				coins("1xxx,1yyy"),
+			},
+		},
+	} {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := divideCoins(tt.coins, tt.divisions)
+			if err != nil {
+				t.Fatalf("division error: %v", err)
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("division got %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestMonthlyVestTimes(t *testing.T) {
+	for _, tt := range []struct {
+		Name      string
+		Start     time.Time
+		Months    int
+		TimeOfDay time.Time
+		Want      []time.Time
+		WantErr   bool
+	}{
+		{
+			Name:      "first",
+			Start:     iso("2020-01-01"),
+			Months:    12,
+			TimeOfDay: hhmm("12:00"),
+			Want: []time.Time{
+				iso("2020-02-01T12:00"),
+				iso("2020-03-01T12:00"),
+				iso("2020-04-01T12:00"),
+				iso("2020-05-01T12:00"),
+				iso("2020-06-01T12:00"),
+				iso("2020-07-01T12:00"),
+				iso("2020-08-01T12:00"),
+				iso("2020-09-01T12:00"),
+				iso("2020-10-01T12:00"),
+				iso("2020-11-01T12:00"),
+				iso("2020-12-01T12:00"),
+				iso("2021-01-01T12:00"),
+			},
+		},
+		{
+			Name:      "clip to end of month",
+			Start:     iso("2021-01-31"),
+			Months:    12,
+			TimeOfDay: hhmm("17:00"),
+			Want: []time.Time{
+				iso("2021-02-28T17:00"),
+				iso("2021-03-31T17:00"),
+				iso("2021-04-30T17:00"),
+				iso("2021-05-31T17:00"),
+				iso("2021-06-30T17:00"),
+				iso("2021-07-31T17:00"),
+				iso("2021-08-31T17:00"),
+				iso("2021-09-30T17:00"),
+				iso("2021-10-31T17:00"),
+				iso("2021-11-30T17:00"),
+				iso("2021-12-31T17:00"),
+				iso("2022-01-31T17:00"),
+			},
+		},
+	} {
+		t.Run(tt.Name, func(t *testing.T) {
+			got, err := monthlyVestTimes(tt.Start, tt.Months, tt.TimeOfDay)
+			if err != nil {
+				if tt.WantErr {
+					return
+				}
+				t.Fatalf("vestingTimes failed: %v", err)
+			}
+			if tt.WantErr {
+				t.Fatalf("vestingTimes didn't fail!")
+			}
+			if !reflect.DeepEqual(got, tt.Want) {
+				t.Errorf("vestingTimes got %v, want %v", got, tt.Want)
+			}
+		})
+	}
+}
+
+func TestApplyCliff(t *testing.T) {
+	for _, tt := range []struct {
+		name   string
+		cliff  time.Time
+		events []event
+		want   []event
+	}{
+		{
+			name:  "before",
+			cliff: iso("1999-12-31T23:59"),
+			events: []event{
+				evt("2020-03-01T12:00", "1000ubld"),
+				evt("2020-04-01T12:00", "100ubld"),
+			},
+			want: []event{
+				evt("2020-03-01T12:00", "1000ubld"),
+				evt("2020-04-01T12:00", "100ubld"),
+			},
+		},
+		{
+			name:  "after",
+			cliff: iso("2021-01-02T09:30"),
+			events: []event{
+				evt("2020-03-01T12:00", "1000ubld"),
+				evt("2020-04-01T12:00", "100ubld"),
+			},
+			want: []event{
+				evt("2021-01-02T09:30", "1100ubld"),
+			},
+		},
+		{
+			name:  "mid",
+			cliff: iso("2021-06-15T17:00"),
+			events: []event{
+				evt("2021-05-15T12:00", "10ubld"),
+				evt("2021-06-15T12:00", "100ubld"),
+				evt("2021-07-15T12:00", "1000ubld"),
+			},
+			want: []event{
+				evt("2021-06-15T17:00", "110ubld"),
+				evt("2021-07-15T12:00", "1000ubld"),
+			},
+		},
+	} {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := applyCliff(tt.events, tt.cliff)
+			if err != nil {
+				t.Fatalf("applyCliff error: %v", err)
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("applyCliff got %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestWrite(t *testing.T) {
+	// Use an explicit timezone for consistant intervals between timestamps.
+	oldLoc := time.Local
+	loc, err := time.LoadLocation("America/Los_Angeles")
+	if err != nil {
+		t.Fatalf("cannot load timezone: %v", err)
+	}
+	time.Local = loc
+
+	for _, tt := range []struct {
+		name   string
+		config writeConfig
+		want   cli.VestingData
+	}{
+		{
+			name: "simple_2y",
+			config: writeConfig{
+				Coins:     coins("1000000000ubld"), // 1000 BLD
+				Months:    24,
+				TimeOfDay: hhmm("09:00"),
+				Start:     iso("2021-01-01T09:30"),
+				Cliffs: []time.Time{
+					iso("2022-01-15T00:00"),
+				},
+			},
+			want: cli.VestingData{
+				StartTime: 1609522200,
+				Periods: []cli.InputPeriod{
+					{Coins: "500000000ubld", Length: 32711400},
+					{Coins: "41666666ubld", Length: 1501200},
+					{Coins: "41666667ubld", Length: 2419200},
+					{Coins: "41666667ubld", Length: 2674800},
+					{Coins: "41666666ubld", Length: 2592000},
+					{Coins: "41666667ubld", Length: 2678400}, // DST begins
+					{Coins: "41666667ubld", Length: 2592000},
+					{Coins: "41666666ubld", Length: 2678400},
+					{Coins: "41666667ubld", Length: 2678400},
+					{Coins: "41666667ubld", Length: 2592000},
+					{Coins: "41666666ubld", Length: 2678400},
+					{Coins: "41666667ubld", Length: 2595600}, // DST ends
+					{Coins: "41666667ubld", Length: 2678400},
+				},
+			},
+		},
+		{
+			name: "mixed_denom",
+			config: writeConfig{
+				Coins:     coins("201ubld,1002urun"),
+				Months:    4,
+				TimeOfDay: hhmm("14:30"),
+				Start:     iso("2021-07-01"),
+			},
+			want: cli.VestingData{
+				StartTime: 1625122800,
+				Periods: []cli.InputPeriod{
+					{Coins: "50ubld,250urun", Length: 2730600},
+					{Coins: "50ubld,251urun", Length: 2678400},
+					{Coins: "50ubld,250urun", Length: 2592000},
+					{Coins: "51ubld,251urun", Length: 2678400},
+				},
+			},
+		},
+	} {
+		t.Run(tt.name, func(t *testing.T) {
+			events, err := tt.config.generateEvents()
+			if err != nil {
+				t.Fatalf("generateEvents error: %v", err)
+			}
+			got := tt.config.convertRelative(events)
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("generateEvents got %v, want %v", got, tt.want)
+			}
+		})
+	}
+
+	time.Local = oldLoc
+}
+
+func TestFormatDuration(t *testing.T) {
+	for _, tt := range []struct {
+		name  string
+		input string
+		want  string
+	}{
+		{"zero", "0s", "0s"},
+		{"small", "23h", "23h0m0s"},
+		{"whole", "72h", "3d0h0m0s"},
+		{"mixed", "127h", "5d7h0m0s"},
+		{"fracsec", "76h3m7.501s", "3d4h3m7.501s"},
+		{"fracsec_harder", "76h3m0.501s", "3d4h3m0.501s"},
+		{"neg", "-76h3m7.501s", "-3d4h3m7.501s"},
+	} {
+		t.Run(tt.name, func(t *testing.T) {
+			duration, err := time.ParseDuration(tt.input)
+			if err != nil {
+				t.Fatalf("bad duration: %v", err)
+			}
+			got := formatDuration(duration)
+			if got != tt.want {
+				t.Errorf(`got "%s", want "%s"`, got, tt.want)
+			}
+		})
+	}
+}
diff --git a/x/auth/vesting/exported/exported.go b/x/auth/vesting/exported/exported.go
index 858e53ed4f..45e32b7ad6 100644
--- a/x/auth/vesting/exported/exported.go
+++ b/x/auth/vesting/exported/exported.go
@@ -18,7 +18,7 @@ type VestingAccount interface {
 	// To get spendable coins of a vesting account, first the total balance must
 	// be retrieved and the locked tokens can be subtracted from the total balance.
 	// Note, the spendable balance can be negative.
-	LockedCoins(blockTime time.Time) sdk.Coins
+	LockedCoins(ctx sdk.Context) sdk.Coins
 
 	// TrackDelegation performs internal vesting accounting necessary when
 	// delegating from a vesting account. It accepts the current block time, the
@@ -40,3 +40,66 @@ type VestingAccount interface {
 	GetDelegatedFree() sdk.Coins
 	GetDelegatedVesting() sdk.Coins
 }
+
+// Additional vesting account behaviors are abstracted by interfaces to avoid
+// cyclic package dependencies. Specifically, the account-wrapping mechanism
+// to support liens in Agoric/agoric-sdk.
+
+// AddGrantAction encapsulates the data needed to add a grant to an account.
+type AddGrantAction interface {
+	// AddToAccount adds the grant to the specified account.
+	// The rawAccount should bypass any account wrappers.
+	AddToAccount(ctx sdk.Context, rawAccount VestingAccount) error
+}
+
+// ReturnGrantAction encapsulates the data needed to return grants from an account.
+type ReturnGrantAction interface {
+	// TakeGrants removes the original vesting amount from the account
+	// and clears the original vesting amount and schedule.
+	// The rawAccount should bypass any account wrappers.
+	TakeGrants(ctx sdk.Context, rawAccount VestingAccount) error
+}
+
+// ClabackAction encapsulates the data needed to perform clawback.
+type ClawbackAction interface {
+	// TakeFromAccount removes unvested tokens from the specified account.
+	// The rawAccount should bypass any account wrappers.
+	TakeFromAccount(ctx sdk.Context, rawAccount VestingAccount) error
+}
+
+// RewardAction encapsulates the data needed to process rewards distributed to an account.
+type RewardAction interface {
+	// ProcessReward processes the given reward which as been added to the account.
+	// Returns an error if the account is of the wrong type.
+	// The rawAccount should bypass any account wrappers.
+	ProcessReward(ctx sdk.Context, reward sdk.Coins, rawAccount VestingAccount) error
+}
+
+// GrantAccount is a VestingAccount which can accept new grants.
+type GrantAccount interface {
+	VestingAccount
+	// AddGrant adds the specified grant to the account.
+	AddGrant(ctx sdk.Context, action AddGrantAction) error
+}
+
+// ClawbackVestingAccountI is an interface for the methods of a clawback account.
+type ClawbackVestingAccountI interface {
+	GrantAccount
+
+	// GetUnlockedOnly returns the sum of all unlocking events up to and including
+	// the blockTime.
+	GetUnlockedOnly(blockTime time.Time) sdk.Coins
+
+	// GetVestedOnly returns the sum of all vesting events up to and including
+	// the blockTime.
+	GetVestedOnly(blockTime time.Time) sdk.Coins
+
+	// Clawback performs the clawback described by action.
+	Clawback(ctx sdk.Context, action ClawbackAction) error
+
+	// PostReward preforms post-reward processing described by action.
+	PostReward(ctx sdk.Context, reward sdk.Coins, action RewardAction) error
+
+	// ReturnGrants returns all grants to the funder.
+	ReturnGrants(ctx sdk.Context, action ReturnGrantAction) error
+}
diff --git a/x/auth/vesting/module.go b/x/auth/vesting/module.go
index 06f9b8d995..f20b1c3dca 100644
--- a/x/auth/vesting/module.go
+++ b/x/auth/vesting/module.go
@@ -74,13 +74,16 @@ type AppModule struct {
 
 	accountKeeper keeper.AccountKeeper
 	bankKeeper    types.BankKeeper
+	stakingKeeper types.StakingKeeper
 }
 
-func NewAppModule(ak keeper.AccountKeeper, bk types.BankKeeper) AppModule {
+// NewAppModule returns a new vesting AppModule.
+func NewAppModule(ak keeper.AccountKeeper, bk types.BankKeeper, sk types.StakingKeeper) AppModule {
 	return AppModule{
 		AppModuleBasic: AppModuleBasic{},
 		accountKeeper:  ak,
 		bankKeeper:     bk,
+		stakingKeeper:  sk,
 	}
 }
 
@@ -98,7 +101,7 @@ func (AppModule) QuerierRoute() string { return "" }
 
 // RegisterServices registers module services.
 func (am AppModule) RegisterServices(cfg module.Configurator) {
-	types.RegisterMsgServer(cfg.MsgServer(), NewMsgServerImpl(am.accountKeeper, am.bankKeeper))
+	types.RegisterMsgServer(cfg.MsgServer(), NewMsgServerImpl(am.accountKeeper, am.bankKeeper, am.stakingKeeper))
 }
 
 // LegacyQuerierHandler performs a no-op.
diff --git a/x/auth/vesting/msg_server.go b/x/auth/vesting/msg_server.go
index c3dd578516..094950d40f 100644
--- a/x/auth/vesting/msg_server.go
+++ b/x/auth/vesting/msg_server.go
@@ -10,18 +10,20 @@ import (
 	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
 	"github.com/cosmos/cosmos-sdk/x/auth/keeper"
 	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
+	"github.com/cosmos/cosmos-sdk/x/auth/vesting/exported"
 	"github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
 )
 
 type msgServer struct {
 	keeper.AccountKeeper
 	types.BankKeeper
+	types.StakingKeeper
 }
 
 // NewMsgServerImpl returns an implementation of the vesting MsgServer interface,
-// wrapping the corresponding AccountKeeper and BankKeeper.
-func NewMsgServerImpl(k keeper.AccountKeeper, bk types.BankKeeper) types.MsgServer {
-	return &msgServer{AccountKeeper: k, BankKeeper: bk}
+// wrapping the corresponding keepers.
+func NewMsgServerImpl(k keeper.AccountKeeper, bk types.BankKeeper, sk types.StakingKeeper) types.MsgServer {
+	return &msgServer{AccountKeeper: k, BankKeeper: bk, StakingKeeper: sk}
 }
 
 var _ types.MsgServer = msgServer{}
@@ -153,6 +155,192 @@ func (s msgServer) CreatePermanentLockedAccount(goCtx context.Context, msg *type
 	return &types.MsgCreatePermanentLockedAccountResponse{}, nil
 }
 
+// CreateClawbackVestingAccount creates a new ClawbackVestingAccount, or merges a grant into an existing one.
+func (s msgServer) CreateClawbackVestingAccount(goCtx context.Context, msg *types.MsgCreateClawbackVestingAccount) (*types.MsgCreateClawbackVestingAccountResponse, error) {
+	ctx := sdk.UnwrapSDKContext(goCtx)
+	ak := s.AccountKeeper
+	bk := s.BankKeeper
+
+	from, err := sdk.AccAddressFromBech32(msg.FromAddress)
+	if err != nil {
+		return nil, err
+	}
+	to, err := sdk.AccAddressFromBech32(msg.ToAddress)
+	if err != nil {
+		return nil, err
+	}
+
+	if bk.BlockedAddr(to) {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.ToAddress)
+	}
+
+	vestingCoins := sdk.NewCoins()
+	for _, period := range msg.VestingPeriods {
+		vestingCoins = vestingCoins.Add(period.Amount...)
+	}
+
+	lockupCoins := sdk.NewCoins()
+	for _, period := range msg.LockupPeriods {
+		lockupCoins = lockupCoins.Add(period.Amount...)
+	}
+
+	if !vestingCoins.IsZero() && len(msg.LockupPeriods) == 0 {
+		// If lockup absent, default to an instant unlock schedule
+		msg.LockupPeriods = []types.Period{
+			{Length: 0, Amount: vestingCoins},
+		}
+		lockupCoins = vestingCoins
+	}
+
+	if !lockupCoins.IsZero() && len(msg.VestingPeriods) == 0 {
+		// If vesting absent, default to an instant vesting schedule
+		msg.VestingPeriods = []types.Period{
+			{Length: 0, Amount: lockupCoins},
+		}
+		vestingCoins = lockupCoins
+	}
+
+	// The vesting and lockup schedules must describe the same total amount.
+	// IsEqual can panic, so use (a == b) <=> (a <= b && b <= a).
+	if !(vestingCoins.IsAllLTE(lockupCoins) && lockupCoins.IsAllLTE(vestingCoins)) {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "lockup and vesting amounts must be equal")
+	}
+
+	madeNewAcc := false
+	acc := ak.GetAccount(ctx, to)
+	var va exported.ClawbackVestingAccountI
+
+	if acc != nil {
+		var isClawback bool
+		va, isClawback = acc.(exported.ClawbackVestingAccountI)
+		switch {
+		case !msg.Merge && isClawback:
+			return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists; consider using --merge", msg.ToAddress)
+		case !msg.Merge && !isClawback:
+			return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists", msg.ToAddress)
+		case msg.Merge && !isClawback:
+			return nil, sdkerrors.Wrapf(sdkerrors.ErrNotSupported, "account %s must be a clawback vesting account", msg.ToAddress)
+		}
+		grantAction := types.NewClawbackGrantAction(msg.FromAddress, s.StakingKeeper, msg.GetStartTime(), msg.GetLockupPeriods(), msg.GetVestingPeriods(), vestingCoins)
+		err := va.AddGrant(ctx, grantAction)
+		if err != nil {
+			return nil, err
+		}
+	} else {
+		baseAccount := ak.NewAccountWithAddress(ctx, to)
+		va = types.NewClawbackVestingAccount(baseAccount.(*authtypes.BaseAccount), from, vestingCoins, msg.StartTime, msg.LockupPeriods, msg.VestingPeriods)
+		madeNewAcc = true
+	}
+
+	ak.SetAccount(ctx, va)
+
+	if madeNewAcc {
+		defer func() {
+			telemetry.IncrCounter(1, "new", "account")
+
+			for _, a := range vestingCoins {
+				if a.Amount.IsInt64() {
+					telemetry.SetGaugeWithLabels(
+						[]string{"tx", "msg", "create_clawback_vesting_account"},
+						float32(a.Amount.Int64()),
+						[]metrics.Label{telemetry.NewLabel("denom", a.Denom)},
+					)
+				}
+			}
+		}()
+	}
+
+	err = bk.SendCoins(ctx, from, to, vestingCoins)
+	if err != nil {
+		return nil, err
+	}
+
+	ctx.EventManager().EmitEvent(
+		sdk.NewEvent(
+			sdk.EventTypeMessage,
+			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
+		),
+	)
+
+	return &types.MsgCreateClawbackVestingAccountResponse{}, nil
+}
+
+// Clawback removes the unvested amount from a ClawbackVestingAccount.
+// The destination defaults to the funder address, but can be overridden.
+func (s msgServer) Clawback(goCtx context.Context, msg *types.MsgClawback) (*types.MsgClawbackResponse, error) {
+	ctx := sdk.UnwrapSDKContext(goCtx)
+
+	ak := s.AccountKeeper
+	bk := s.BankKeeper
+
+	funder, err := sdk.AccAddressFromBech32(msg.GetFunderAddress())
+	if err != nil {
+		return nil, err
+	}
+	addr, err := sdk.AccAddressFromBech32(msg.GetAddress())
+	if err != nil {
+		return nil, err
+	}
+	dest := funder
+	if msg.GetDestAddress() != "" {
+		dest, err = sdk.AccAddressFromBech32(msg.GetDestAddress())
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	if bk.BlockedAddr(dest) {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.DestAddress)
+	}
+
+	acc := ak.GetAccount(ctx, addr)
+	if acc == nil {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrNotFound, "account %s does not exist", msg.Address)
+	}
+	va, ok := acc.(exported.ClawbackVestingAccountI)
+	if !ok {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account not subject to clawback: %s", msg.Address)
+	}
+
+	clawbackAction := types.NewClawbackAction(funder, dest, ak, bk, s.StakingKeeper)
+	err = va.Clawback(ctx, clawbackAction)
+	if err != nil {
+		return nil, err
+	}
+
+	return &types.MsgClawbackResponse{}, nil
+}
+
+// ReturnGrants removes the unvested amount from a vesting account,
+// returning it to the funder. Currently only supported for ClawbackVestingAccount.
+func (s msgServer) ReturnGrants(goCtx context.Context, msg *types.MsgReturnGrants) (*types.MsgReturnGrantsResponse, error) {
+	ctx := sdk.UnwrapSDKContext(goCtx)
+
+	ak := s.AccountKeeper
+
+	addr, err := sdk.AccAddressFromBech32(msg.GetAddress())
+	if err != nil {
+		return nil, err
+	}
+
+	acc := ak.GetAccount(ctx, addr)
+	if acc == nil {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrNotFound, "account %s does not exist", msg.Address)
+	}
+	va, ok := acc.(exported.ClawbackVestingAccountI)
+	if !ok {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account does not support return-grants: %s", msg.Address)
+	}
+
+	returnGrantsAction := types.NewReturnGrantAction(ak, s.BankKeeper, s.StakingKeeper)
+	err = va.ReturnGrants(ctx, returnGrantsAction)
+	if err != nil {
+		return nil, err
+	}
+
+	return &types.MsgReturnGrantsResponse{}, nil
+}
+
 func (s msgServer) CreatePeriodicVestingAccount(goCtx context.Context, msg *types.MsgCreatePeriodicVestingAccount) (*types.MsgCreatePeriodicVestingAccountResponse, error) {
 	ctx := sdk.UnwrapSDKContext(goCtx)
 
@@ -168,8 +356,8 @@ func (s msgServer) CreatePeriodicVestingAccount(goCtx context.Context, msg *type
 		return nil, err
 	}
 
-	if acc := ak.GetAccount(ctx, to); acc != nil {
-		return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists", msg.ToAddress)
+	if bk.BlockedAddr(to) {
+		return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.ToAddress)
 	}
 
 	var totalCoins sdk.Coins
@@ -177,29 +365,48 @@ func (s msgServer) CreatePeriodicVestingAccount(goCtx context.Context, msg *type
 		totalCoins = totalCoins.Add(period.Amount...)
 	}
 
-	if err := bk.IsSendEnabledCoins(ctx, totalCoins...); err != nil {
-		return nil, err
+	madeNewAcc := false
+	acc := ak.GetAccount(ctx, to)
+
+	if acc != nil {
+		pva, isPeriodic := acc.(exported.GrantAccount)
+		switch {
+		case !msg.Merge && isPeriodic:
+			return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists; consider using --merge", msg.ToAddress)
+		case !msg.Merge && !isPeriodic:
+			return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists", msg.ToAddress)
+		case msg.Merge && !isPeriodic:
+			return nil, sdkerrors.Wrapf(sdkerrors.ErrNotSupported, "account %s must be a periodic vesting account", msg.ToAddress)
+		}
+		grantAction := types.NewPeriodicGrantAction(s.StakingKeeper, msg.GetStartTime(), msg.GetVestingPeriods(), totalCoins)
+		err := pva.AddGrant(ctx, grantAction)
+		if err != nil {
+			return nil, err
+		}
+	} else {
+		baseAccount := authtypes.NewBaseAccountWithAddress(to)
+		baseAccount = ak.NewAccount(ctx, baseAccount).(*authtypes.BaseAccount)
+		acc = types.NewPeriodicVestingAccount(baseAccount, totalCoins.Sort(), msg.StartTime, msg.VestingPeriods)
+		madeNewAcc = true
 	}
 
-	baseAccount := authtypes.NewBaseAccountWithAddress(to)
-	baseAccount = ak.NewAccount(ctx, baseAccount).(*authtypes.BaseAccount)
-	vestingAccount := types.NewPeriodicVestingAccount(baseAccount, totalCoins.Sort(), msg.StartTime, msg.VestingPeriods)
+	ak.SetAccount(ctx, acc)
 
-	ak.SetAccount(ctx, vestingAccount)
+	if madeNewAcc {
+		defer func() {
+			telemetry.IncrCounter(1, "new", "account")
 
-	defer func() {
-		telemetry.IncrCounter(1, "new", "account")
-
-		for _, a := range totalCoins {
-			if a.Amount.IsInt64() {
-				telemetry.SetGaugeWithLabels(
-					[]string{"tx", "msg", "create_periodic_vesting_account"},
-					float32(a.Amount.Int64()),
-					[]metrics.Label{telemetry.NewLabel("denom", a.Denom)},
-				)
+			for _, a := range totalCoins {
+				if a.Amount.IsInt64() {
+					telemetry.SetGaugeWithLabels(
+						[]string{"tx", "msg", "create_periodic_vesting_account"},
+						float32(a.Amount.Int64()),
+						[]metrics.Label{telemetry.NewLabel("denom", a.Denom)},
+					)
+				}
 			}
-		}
-	}()
+		}()
+	}
 
 	if err = bk.SendCoins(ctx, from, to, totalCoins); err != nil {
 		return nil, err
diff --git a/x/auth/vesting/types/codec.go b/x/auth/vesting/types/codec.go
index 270116671e..9456516e6f 100644
--- a/x/auth/vesting/types/codec.go
+++ b/x/auth/vesting/types/codec.go
@@ -17,12 +17,18 @@ import (
 func RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {
 	cdc.RegisterInterface((*exported.VestingAccount)(nil), nil)
 	cdc.RegisterConcrete(&BaseVestingAccount{}, "cosmos-sdk/BaseVestingAccount", nil)
+	cdc.RegisterConcrete(&ClawbackVestingAccount{}, "cosmos-sdk/ClawbackVestingAccount", nil)
 	cdc.RegisterConcrete(&ContinuousVestingAccount{}, "cosmos-sdk/ContinuousVestingAccount", nil)
 	cdc.RegisterConcrete(&DelayedVestingAccount{}, "cosmos-sdk/DelayedVestingAccount", nil)
 	cdc.RegisterConcrete(&PeriodicVestingAccount{}, "cosmos-sdk/PeriodicVestingAccount", nil)
 	cdc.RegisterConcrete(&PermanentLockedAccount{}, "cosmos-sdk/PermanentLockedAccount", nil)
-	legacy.RegisterAminoMsg(cdc, &MsgCreateVestingAccount{}, "cosmos-sdk/MsgCreateVestingAccount")
+	legacy.RegisterAminoMsg(cdc, &MsgClawback{}, "cosmos-sdk/MsgClawback")
+	// msgName needs to be 39 chars or less, but only needs to be unique - abbreviate next two
+	legacy.RegisterAminoMsg(cdc, &MsgCreateClawbackVestingAccount{}, "cosmos-sdk/MsgCreateClawbackVestingAcc")
+	legacy.RegisterAminoMsg(cdc, &MsgCreatePeriodicVestingAccount{}, "cosmos-sdk/MsgCreatePeriodicVestingAcc")
 	legacy.RegisterAminoMsg(cdc, &MsgCreatePermanentLockedAccount{}, "cosmos-sdk/MsgCreatePermLockedAccount")
+	legacy.RegisterAminoMsg(cdc, &MsgCreateVestingAccount{}, "cosmos-sdk/MsgCreateVestingAccount")
+	legacy.RegisterAminoMsg(cdc, &MsgReturnGrants{}, "cosmos-sdk/MsgReturnGrants")
 }
 
 // RegisterInterface associates protoName with AccountI and VestingAccount
@@ -35,6 +41,7 @@ func RegisterInterfaces(registry types.InterfaceRegistry) {
 		&DelayedVestingAccount{},
 		&PeriodicVestingAccount{},
 		&PermanentLockedAccount{},
+		&ClawbackVestingAccount{},
 	)
 
 	registry.RegisterImplementations(
@@ -44,6 +51,7 @@ func RegisterInterfaces(registry types.InterfaceRegistry) {
 		&ContinuousVestingAccount{},
 		&PeriodicVestingAccount{},
 		&PermanentLockedAccount{},
+		&ClawbackVestingAccount{},
 	)
 
 	registry.RegisterImplementations(
@@ -53,12 +61,17 @@ func RegisterInterfaces(registry types.InterfaceRegistry) {
 		&ContinuousVestingAccount{},
 		&PeriodicVestingAccount{},
 		&PermanentLockedAccount{},
+		&ClawbackVestingAccount{},
 	)
 
 	registry.RegisterImplementations(
 		(*sdk.Msg)(nil),
-		&MsgCreateVestingAccount{},
+		&MsgClawback{},
+		&MsgCreateClawbackVestingAccount{},
+		&MsgCreatePeriodicVestingAccount{},
 		&MsgCreatePermanentLockedAccount{},
+		&MsgCreateVestingAccount{},
+		&MsgReturnGrants{},
 	)
 
 	msgservice.RegisterMsgServiceDesc(registry, &_Msg_serviceDesc)
diff --git a/x/auth/vesting/types/expected_keepers.go b/x/auth/vesting/types/expected_keepers.go
index 5705eea30b..7291f49de5 100644
--- a/x/auth/vesting/types/expected_keepers.go
+++ b/x/auth/vesting/types/expected_keepers.go
@@ -2,12 +2,52 @@ package types
 
 import (
 	sdk "github.com/cosmos/cosmos-sdk/types"
+	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
+	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
 )
 
+// AccountKeeper defines the expected interface contract the vesting module
+// requires for storing accounts.
+type AccountKeeper interface {
+	GetAccount(sdk.Context, sdk.AccAddress) authtypes.AccountI
+	SetAccount(sdk.Context, authtypes.AccountI)
+}
+
 // BankKeeper defines the expected interface contract the vesting module requires
 // for creating vesting accounts with funds.
 type BankKeeper interface {
+	GetAllBalances(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins
+	GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin
 	IsSendEnabledCoins(ctx sdk.Context, coins ...sdk.Coin) error
 	SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error
+	SpendableCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins
 	BlockedAddr(addr sdk.AccAddress) bool
 }
+
+// StakingKeeper defines the expected interface contract the vesting module
+// requires for finding and changing the delegated tokens, used in clawback.
+type StakingKeeper interface {
+	BondDenom(ctx sdk.Context) string
+	GetDelegatorBonded(ctx sdk.Context, delegator sdk.AccAddress) sdk.Int
+	GetDelegatorDelegations(ctx sdk.Context, delegator sdk.AccAddress,
+		maxRetrieve uint16) []stakingtypes.Delegation
+	GetDelegatorUnbonding(ctx sdk.Context, delegator sdk.AccAddress) sdk.Int
+	GetUnbondingDelegations(ctx sdk.Context, delegator sdk.AccAddress,
+		maxRetrieve uint16) []stakingtypes.UnbondingDelegation
+	GetValidator(ctx sdk.Context, valAddr sdk.ValAddress) (stakingtypes.Validator, bool)
+	TransferUnbonding(ctx sdk.Context, fromAddr, toAddr sdk.AccAddress, valAddr sdk.ValAddress, wantAmt sdk.Int) sdk.Int
+	TransferDelegation(ctx sdk.Context, fromAddr, toAddr sdk.AccAddress, valAddr sdk.ValAddress, wantShares sdk.Dec) sdk.Dec
+}
+
+// DistributionHooks is the expected interface for distribution module hooks.
+type DistributionHooks interface {
+	// AllowWithdrawAddr tells whether to honor the delegation withdraw
+	// address associated with the address (if any). The distribution
+	// keeper will call this before each reward withdrawal.
+	// If multiple distribution hooks are set, then any of them may
+	// disallow the withdraw address.
+	AllowWithdrawAddr(ctx sdk.Context, delAddr sdk.AccAddress) bool
+
+	// AfterDelegationReward is called after the reward has been transferred the address.
+	AfterDelegationReward(ctx sdk.Context, delAddr, withdrawAddr sdk.AccAddress, reward sdk.Coins)
+}
diff --git a/x/auth/vesting/types/genesis_test.go b/x/auth/vesting/types/genesis_test.go
index 98aabb15cf..36710e0b9a 100644
--- a/x/auth/vesting/types/genesis_test.go
+++ b/x/auth/vesting/types/genesis_test.go
@@ -21,7 +21,8 @@ var (
 func TestValidateGenesisInvalidAccounts(t *testing.T) {
 	acc1 := authtypes.NewBaseAccountWithAddress(sdk.AccAddress(addr1))
 	acc1Balance := sdk.NewCoins(sdk.NewInt64Coin(sdk.DefaultBondDenom, 150))
-	baseVestingAcc := NewBaseVestingAccount(acc1, acc1Balance, 1548775410)
+	endTime := int64(1548775410)
+	baseVestingAcc := NewBaseVestingAccount(acc1, acc1Balance, endTime)
 
 	// invalid delegated vesting
 	baseVestingAcc.DelegatedVesting = acc1Balance.Add(acc1Balance...)
@@ -40,4 +41,19 @@ func TestValidateGenesisInvalidAccounts(t *testing.T) {
 	// invalid start time
 	genAccs[0] = NewContinuousVestingAccountRaw(baseVestingAcc, 1548888000)
 	require.Error(t, authtypes.ValidateGenAccounts(genAccs))
+	// invalid period: duration
+	genAccs[0] = NewPeriodicVestingAccountRaw(baseVestingAcc, endTime-100000, []Period{
+		{Length: 100000 + 20, Amount: acc1Balance},
+	})
+	require.Error(t, authtypes.ValidateGenAccounts(genAccs))
+	// invalid period: amount
+	genAccs[0] = NewPeriodicVestingAccountRaw(baseVestingAcc, endTime-100000, []Period{
+		{Length: 100000, Amount: acc1Balance.Add(acc1Balance...)},
+	})
+	require.Error(t, authtypes.ValidateGenAccounts(genAccs))
+	// Passing case
+	genAccs[0] = NewPeriodicVestingAccountRaw(baseVestingAcc, endTime-100000, []Period{
+		{Length: 100000, Amount: acc1Balance},
+	})
+	require.NoError(t, authtypes.ValidateGenAccounts(genAccs))
 }
diff --git a/x/auth/vesting/types/hooks.go b/x/auth/vesting/types/hooks.go
new file mode 100644
index 0000000000..63de9b706a
--- /dev/null
+++ b/x/auth/vesting/types/hooks.go
@@ -0,0 +1,37 @@
+package types
+
+import (
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	"github.com/cosmos/cosmos-sdk/x/auth/vesting/exported"
+)
+
+type distributionHooks struct {
+	accountKeeper AccountKeeper
+	rewardAction  exported.RewardAction
+}
+
+var _ DistributionHooks = distributionHooks{}
+
+func NewDistributionHooks(ak AccountKeeper, bk BankKeeper, sk StakingKeeper) DistributionHooks {
+	return distributionHooks{
+		accountKeeper: ak,
+		rewardAction:  NewClawbackRewardAction(ak, bk, sk),
+	}
+}
+
+func (dh distributionHooks) AllowWithdrawAddr(ctx sdk.Context, delAddr sdk.AccAddress) bool {
+	acc := dh.accountKeeper.GetAccount(ctx, delAddr)
+	_, isClawback := acc.(exported.ClawbackVestingAccountI)
+	return !isClawback
+}
+
+func (dh distributionHooks) AfterDelegationReward(ctx sdk.Context, delAddr, withdrawAddr sdk.AccAddress, reward sdk.Coins) {
+	acc := dh.accountKeeper.GetAccount(ctx, delAddr)
+	cva, isClawback := acc.(exported.ClawbackVestingAccountI)
+	if isClawback {
+		err := cva.PostReward(ctx, reward, dh.rewardAction)
+		if err != nil {
+			panic(err)
+		}
+	}
+}
diff --git a/x/auth/vesting/types/msgs.go b/x/auth/vesting/types/msgs.go
index f2194af569..8582098063 100644
--- a/x/auth/vesting/types/msgs.go
+++ b/x/auth/vesting/types/msgs.go
@@ -16,12 +16,27 @@ const TypeMsgCreatePermanentLockedAccount = "msg_create_permanent_locked_account
 // TypeMsgCreatePeriodicVestingAccount defines the type value for a MsgCreateVestingAccount.
 const TypeMsgCreatePeriodicVestingAccount = "msg_create_periodic_vesting_account"
 
+// TypeMsgCreateClawbackVestingAccount defines the type value for a MsgCreateClawbackVestingAcount.
+const TypeMsgCreateClawbackVestingAccount = "msg_create_clawback_vesting_account"
+
+// TypeMsgClawback defines the type value for a MsgClawback.
+const TypeMsgClawback = "msg_clawback"
+
+// TypeMsgReturnGrants defines the type value for a MsgReturnGrants.
+const TypeMsgReturnGrants = "msg_return_grants"
+
 var _ sdk.Msg = &MsgCreateVestingAccount{}
 
 var _ sdk.Msg = &MsgCreatePermanentLockedAccount{}
 
 var _ sdk.Msg = &MsgCreatePeriodicVestingAccount{}
 
+var _ sdk.Msg = &MsgCreateClawbackVestingAccount{}
+
+var _ sdk.Msg = &MsgClawback{}
+
+var _ sdk.Msg = &MsgReturnGrants{}
+
 // NewMsgCreateVestingAccount returns a reference to a new MsgCreateVestingAccount.
 //
 //nolint:interfacer
@@ -129,12 +144,13 @@ func (msg MsgCreatePermanentLockedAccount) GetSigners() []sdk.AccAddress {
 // NewMsgCreatePeriodicVestingAccount returns a reference to a new MsgCreatePeriodicVestingAccount.
 //
 //nolint:interfacer
-func NewMsgCreatePeriodicVestingAccount(fromAddr, toAddr sdk.AccAddress, startTime int64, periods []Period) *MsgCreatePeriodicVestingAccount {
+func NewMsgCreatePeriodicVestingAccount(fromAddr, toAddr sdk.AccAddress, startTime int64, periods []Period, merge bool) *MsgCreatePeriodicVestingAccount {
 	return &MsgCreatePeriodicVestingAccount{
 		FromAddress:    fromAddr.String(),
 		ToAddress:      toAddr.String(),
 		StartTime:      startTime,
 		VestingPeriods: periods,
+		Merge:          merge,
 	}
 }
 
@@ -197,3 +213,198 @@ func (msg MsgCreatePeriodicVestingAccount) ValidateBasic() error {
 
 	return nil
 }
+
+// NewMsgCreateClawbackVestingAccount returns a reference to a new MsgCreateClawbackVestingAccount.
+//
+//nolint:interfacer
+func NewMsgCreateClawbackVestingAccount(fromAddr, toAddr sdk.AccAddress, startTime int64, lockupPeriods, vestingPeriods []Period, merge bool) *MsgCreateClawbackVestingAccount {
+	return &MsgCreateClawbackVestingAccount{
+		FromAddress:    fromAddr.String(),
+		ToAddress:      toAddr.String(),
+		StartTime:      startTime,
+		LockupPeriods:  lockupPeriods,
+		VestingPeriods: vestingPeriods,
+		Merge:          merge,
+	}
+}
+
+// Route returns the message route for a MsgCreateClawbackVestingAccount.
+func (msg MsgCreateClawbackVestingAccount) Route() string { return RouterKey }
+
+// Type returns the message type for a MsgCreateClawbackVestingAccount.
+func (msg MsgCreateClawbackVestingAccount) Type() string { return TypeMsgCreateClawbackVestingAccount }
+
+// GetSigners returns the expected signers for a MsgCreateClawbackVestingAccount.
+func (msg MsgCreateClawbackVestingAccount) GetSigners() []sdk.AccAddress {
+	from, err := sdk.AccAddressFromBech32(msg.FromAddress)
+	if err != nil {
+		panic(err)
+	}
+	return []sdk.AccAddress{from}
+}
+
+// GetSignBytes returns the bytes all expected signers must sign over for a
+// MsgCreateClawbackVestingAccount.
+func (msg MsgCreateClawbackVestingAccount) GetSignBytes() []byte {
+	return sdk.MustSortJSON(amino.MustMarshalJSON(&msg))
+}
+
+// ValidateBasic Implements Msg.
+func (msg MsgCreateClawbackVestingAccount) ValidateBasic() error {
+	from, err := sdk.AccAddressFromBech32(msg.FromAddress)
+	if err != nil {
+		return err
+	}
+	to, err := sdk.AccAddressFromBech32(msg.ToAddress)
+	if err != nil {
+		return err
+	}
+	if err := sdk.VerifyAddressFormat(from); err != nil {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid sender address: %s", err)
+	}
+
+	if err := sdk.VerifyAddressFormat(to); err != nil {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid recipient address: %s", err)
+	}
+
+	lockupCoins := sdk.NewCoins()
+	for i, period := range msg.LockupPeriods {
+		if period.Length < 1 {
+			return sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "invalid period length of %d in period %d, length must be greater than 0", period.Length, i)
+		}
+		if !period.Amount.IsValid() {
+			return sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "invalid period amount in period %d: %s", i, err)
+		}
+		lockupCoins = lockupCoins.Add(period.Amount...)
+	}
+
+	vestingCoins := sdk.NewCoins()
+	for i, period := range msg.VestingPeriods {
+		if period.Length < 1 {
+			return sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "invalid period length of %d in period %d, length must be greater than 0", period.Length, i)
+		}
+		if !period.Amount.IsValid() {
+			return sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "invalid period amount in period %d: %s", i, err)
+		}
+		vestingCoins = vestingCoins.Add(period.Amount...)
+	}
+
+	// If both schedules are present, the must describe the same total amount.
+	// IsEqual can panic, so use (a == b) <=> (a <= b && b <= a).
+	if len(msg.LockupPeriods) > 0 && len(msg.VestingPeriods) > 0 &&
+		!(lockupCoins.IsAllLTE(vestingCoins) && vestingCoins.IsAllLTE(lockupCoins)) {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "vesting and lockup schedules must have same total coins")
+	}
+
+	return nil
+}
+
+// NewMsgClawback returns a reference to a new MsgClawback.
+// The dest address may be nil - defaulting to the funder.
+//
+//nolint:interfacer
+func NewMsgClawback(funder, addr, dest sdk.AccAddress) *MsgClawback {
+	destString := ""
+	if dest != nil {
+		destString = dest.String()
+	}
+	return &MsgClawback{
+		FunderAddress: funder.String(),
+		Address:       addr.String(),
+		DestAddress:   destString,
+	}
+}
+
+// Route returns the message route for a MsgClawback.
+func (msg MsgClawback) Route() string { return RouterKey }
+
+// Type returns the message type for a MsgClawback.
+func (msg MsgClawback) Type() string { return TypeMsgClawback }
+
+// GetSigners returns the expected signers for a MsgClawback.
+func (msg MsgClawback) GetSigners() []sdk.AccAddress {
+	funder, err := sdk.AccAddressFromBech32(msg.FunderAddress)
+	if err != nil {
+		panic(err)
+	}
+	return []sdk.AccAddress{funder}
+}
+
+// GetSignBytes returns the bytes all expected signers must sign over for a
+// MsgClawback.
+func (msg MsgClawback) GetSignBytes() []byte {
+	return sdk.MustSortJSON(amino.MustMarshalJSON(&msg))
+}
+
+// ValidateBasic Implements Msg.
+func (msg MsgClawback) ValidateBasic() error {
+	funder, err := sdk.AccAddressFromBech32(msg.GetFunderAddress())
+	if err != nil {
+		return err
+	}
+	if err := sdk.VerifyAddressFormat(funder); err != nil {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid funder address: %s", err)
+	}
+
+	addr, err := sdk.AccAddressFromBech32(msg.GetAddress())
+	if err != nil {
+		return err
+	}
+	if err := sdk.VerifyAddressFormat(addr); err != nil {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid account address: %s", err)
+	}
+
+	if msg.GetDestAddress() != "" {
+		dest, err := sdk.AccAddressFromBech32(msg.GetDestAddress())
+		if err != nil {
+			return err
+		}
+		if err := sdk.VerifyAddressFormat(dest); err != nil {
+			return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid destination address: %s", err)
+		}
+	}
+
+	return nil
+}
+
+// NewMsgReturnGrants returns a reference to a new MsgReturnGrants.
+//
+//nolint:interfacer
+func NewMsgReturnGrants(addr sdk.AccAddress) *MsgReturnGrants {
+	return &MsgReturnGrants{
+		Address: addr.String(),
+	}
+}
+
+// Route returns the message route for a MsgReturnGrants.
+func (msg MsgReturnGrants) Route() string { return RouterKey }
+
+// Type returns the message type for a MsgReturnGrants.
+func (msg MsgReturnGrants) Type() string { return TypeMsgReturnGrants }
+
+// GetSigners returns the expected signers for a MsgReturnGrants.
+func (msg MsgReturnGrants) GetSigners() []sdk.AccAddress {
+	addr, err := sdk.AccAddressFromBech32(msg.Address)
+	if err != nil {
+		panic(err)
+	}
+	return []sdk.AccAddress{addr}
+}
+
+// GetSignBytes returns the bytes all expected signers must sign over for a
+// MsgReturnGrants.
+func (msg MsgReturnGrants) GetSignBytes() []byte {
+	return sdk.MustSortJSON(amino.MustMarshalJSON(&msg))
+}
+
+// ValidateBasic Implements Msg.
+func (msg MsgReturnGrants) ValidateBasic() error {
+	addr, err := sdk.AccAddressFromBech32(msg.GetAddress())
+	if err != nil {
+		return err
+	}
+	if err := sdk.VerifyAddressFormat(addr); err != nil {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, "invalid account address: %s", err)
+	}
+	return nil
+}
diff --git a/x/auth/vesting/types/msgs_test.go b/x/auth/vesting/types/msgs_test.go
new file mode 100644
index 0000000000..3f8e154ce9
--- /dev/null
+++ b/x/auth/vesting/types/msgs_test.go
@@ -0,0 +1,213 @@
+package types
+
+import (
+	"testing"
+
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	"github.com/stretchr/testify/require"
+)
+
+func TestVestingAccountMsg(t *testing.T) {
+	_, _, fromAddr := KeyTestPubAddr()
+	_, _, toAddr := KeyTestPubAddr()
+	amount := NewTestCoins()
+	endTime := int64(123456789)
+	msg := NewMsgCreateVestingAccount(fromAddr, toAddr, amount, endTime, false)
+	require.NotNil(t, msg)
+	route := msg.Route()
+	require.Equal(t, RouterKey, route)
+	tp := msg.Type()
+	require.Equal(t, TypeMsgCreateVestingAccount, tp)
+	err := msg.ValidateBasic()
+	require.NoError(t, err)
+
+	badFromMsg := MsgCreateVestingAccount{
+		FromAddress: "foo",
+		ToAddress:   toAddr.String(),
+		Amount:      amount,
+		EndTime:     endTime,
+	}
+	err = badFromMsg.ValidateBasic()
+	require.Error(t, err)
+
+	badToMsg := MsgCreateVestingAccount{
+		FromAddress: fromAddr.String(),
+		ToAddress:   "foo",
+		Amount:      amount,
+		EndTime:     endTime,
+	}
+	err = badToMsg.ValidateBasic()
+	require.Error(t, err)
+
+	badEndTime := NewMsgCreateVestingAccount(fromAddr, toAddr, amount, int64(-1), false)
+	err = badEndTime.ValidateBasic()
+	require.Error(t, err)
+}
+
+func TestPeriodicVestingAccountMsg(t *testing.T) {
+	_, _, fromAddr := KeyTestPubAddr()
+	_, _, toAddr := KeyTestPubAddr()
+	amount := NewTestCoins()
+	startTime := int64(123456789)
+	periods := []Period{
+		{Length: 86400, Amount: amount},
+	}
+	msg := NewMsgCreatePeriodicVestingAccount(fromAddr, toAddr, startTime, periods, false)
+	route := msg.Route()
+	require.Equal(t, RouterKey, route)
+	tp := msg.Type()
+	require.Equal(t, TypeMsgCreatePeriodicVestingAccount, tp)
+	err := msg.ValidateBasic()
+	require.NoError(t, err)
+
+	badFromMsg := MsgCreatePeriodicVestingAccount{
+		FromAddress:    "foo",
+		ToAddress:      toAddr.String(),
+		StartTime:      startTime,
+		VestingPeriods: periods,
+	}
+	err = badFromMsg.ValidateBasic()
+	require.Error(t, err)
+
+	badToMsg := MsgCreatePeriodicVestingAccount{
+		FromAddress:    fromAddr.String(),
+		ToAddress:      "foo",
+		StartTime:      startTime,
+		VestingPeriods: periods,
+	}
+	err = badToMsg.ValidateBasic()
+	require.Error(t, err)
+
+	badPeriods := NewMsgCreatePeriodicVestingAccount(fromAddr, toAddr, startTime, []Period{
+		{Length: 0, Amount: amount},
+	}, false)
+	err = badPeriods.ValidateBasic()
+	require.Error(t, err)
+
+	badPeriodAmount := NewMsgCreatePeriodicVestingAccount(fromAddr, toAddr, startTime, []Period{
+		{Length: 1, Amount: []sdk.Coin{{Denom: "atom", Amount: sdk.NewInt(1000)}}},
+		{Length: 1000, Amount: []sdk.Coin{{Denom: "atom", Amount: sdk.NewInt(-999)}}},
+	}, true)
+	err = badPeriodAmount.ValidateBasic()
+	require.Error(t, err)
+}
+
+func TestClawbackVestingAccountMsg(t *testing.T) {
+	_, _, fromAddr := KeyTestPubAddr()
+	_, _, toAddr := KeyTestPubAddr()
+	amount := NewTestCoins()
+	startTime := int64(100200300)
+	lockupPeriods := []Period{
+		{Length: 200000, Amount: amount},
+	}
+	vestingPeriods := []Period{
+		{Length: 300000, Amount: amount},
+	}
+	msg := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, lockupPeriods, vestingPeriods, false)
+	route := msg.Route()
+	require.Equal(t, RouterKey, route)
+	tp := msg.Type()
+	require.Equal(t, TypeMsgCreateClawbackVestingAccount, tp)
+	err := msg.ValidateBasic()
+	require.NoError(t, err)
+
+	badFromMsg := MsgCreateClawbackVestingAccount{
+		FromAddress:    "foo",
+		ToAddress:      toAddr.String(),
+		StartTime:      startTime,
+		LockupPeriods:  lockupPeriods,
+		VestingPeriods: vestingPeriods,
+	}
+	err = badFromMsg.ValidateBasic()
+	require.Error(t, err)
+
+	badToMsg := MsgCreateClawbackVestingAccount{
+		FromAddress:    fromAddr.String(),
+		ToAddress:      "foo",
+		StartTime:      startTime,
+		LockupPeriods:  lockupPeriods,
+		VestingPeriods: vestingPeriods,
+	}
+	err = badToMsg.ValidateBasic()
+	require.Error(t, err)
+
+	badPeriods := []Period{{Length: 0, Amount: amount}}
+	badLockup := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, badPeriods, vestingPeriods, false)
+	err = badLockup.ValidateBasic()
+	require.Error(t, err)
+
+	badVesting := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, lockupPeriods, badPeriods, false)
+	err = badVesting.ValidateBasic()
+	require.Error(t, err)
+
+	badAmounts := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, lockupPeriods, []Period{
+		{Length: 17, Amount: amount.Add(amount...)},
+	}, false)
+	err = badAmounts.ValidateBasic()
+	require.Error(t, err)
+
+	emptyPeriods := []Period{}
+	noLockupOk := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, emptyPeriods, vestingPeriods, false)
+	err = noLockupOk.ValidateBasic()
+	require.NoError(t, err)
+
+	noVestingOk := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, lockupPeriods, emptyPeriods, false)
+	err = noVestingOk.ValidateBasic()
+	require.NoError(t, err)
+
+	badPeriodsAmount := []Period{
+		{Length: 1, Amount: []sdk.Coin{{Denom: "atom", Amount: sdk.NewInt(20000000)}}},
+		{Length: 1000, Amount: []sdk.Coin{{Denom: "atom", Amount: sdk.NewInt(-10000000)}}},
+	}
+
+	negLockupEvent := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, badPeriodsAmount, vestingPeriods, false)
+	err = negLockupEvent.ValidateBasic()
+	require.Error(t, err)
+
+	negVestingEvent := NewMsgCreateClawbackVestingAccount(fromAddr, toAddr, startTime, lockupPeriods, badPeriodsAmount, false)
+	err = negVestingEvent.ValidateBasic()
+	require.Error(t, err)
+}
+
+func TestClawbackMsg(t *testing.T) {
+	_, _, funderAddr := KeyTestPubAddr()
+	_, _, addr := KeyTestPubAddr()
+	_, _, destAddr := KeyTestPubAddr()
+
+	okMsg := NewMsgClawback(funderAddr, addr, destAddr)
+	route := okMsg.Route()
+	require.Equal(t, RouterKey, route)
+	tp := okMsg.Type()
+	require.Equal(t, TypeMsgClawback, tp)
+	err := okMsg.ValidateBasic()
+	require.NoError(t, err)
+
+	noDest := NewMsgClawback(funderAddr, addr, nil)
+	require.Equal(t, noDest.DestAddress, "")
+	err = noDest.ValidateBasic()
+	require.NoError(t, err)
+
+	badFunder := MsgClawback{
+		FunderAddress: "foo",
+		Address:       addr.String(),
+		DestAddress:   destAddr.String(),
+	}
+	err = badFunder.ValidateBasic()
+	require.Error(t, err)
+
+	badAddr := MsgClawback{
+		FunderAddress: funderAddr.String(),
+		Address:       "foo",
+		DestAddress:   destAddr.String(),
+	}
+	err = badAddr.ValidateBasic()
+	require.Error(t, err)
+
+	badDest := MsgClawback{
+		FunderAddress: funderAddr.String(),
+		Address:       addr.String(),
+		DestAddress:   "foo",
+	}
+	err = badDest.ValidateBasic()
+	require.Error(t, err)
+}
diff --git a/x/auth/vesting/types/period.go b/x/auth/vesting/types/period.go
index 2d64fd6199..2369464118 100644
--- a/x/auth/vesting/types/period.go
+++ b/x/auth/vesting/types/period.go
@@ -58,3 +58,269 @@ func (p Periods) String() string {
 	return strings.TrimSpace(fmt.Sprintf(`Vesting Periods:
 		%s`, strings.Join(periodsListString, ", ")))
 }
+
+// A "schedule" is an increasing step function of Coins over time.
+// It's specified as an absolute start time and a sequence of relative
+// periods, with each step at the end of a period. A schedule may also
+// give the time and total value at the last step, which can speed
+// evaluation of the step function after the last step.
+
+// ReadSchedule returns the value of a schedule at readTime.
+func ReadSchedule(startTime, endTime int64, periods []Period, totalCoins sdk.Coins, readTime int64) sdk.Coins {
+	if readTime <= startTime {
+		return sdk.NewCoins()
+	}
+	if readTime >= endTime {
+		return totalCoins
+	}
+
+	coins := sdk.NewCoins() // sum of amounts for events before readTime
+	time := startTime
+
+	for _, period := range periods {
+		if readTime < time+period.Length {
+			// we're reading before the next event
+			break
+		}
+		coins = coins.Add(period.Amount...)
+		time += period.Length
+	}
+
+	return coins
+}
+
+// max64 returns the maximum of its inputs.
+func max64(i, j int64) int64 {
+	if i > j {
+		return i
+	}
+	return j
+}
+
+// min64 returns the minimum of its inputs.
+func min64(i, j int64) int64 {
+	if i < j {
+		return i
+	}
+	return j
+}
+
+// coinsMin returns the minimum of its inputs for all denominations.
+func coinsMin(a, b sdk.Coins) sdk.Coins {
+	min := sdk.NewCoins()
+	for _, coinA := range a {
+		denom := coinA.Denom
+		bAmt := b.AmountOfNoDenomValidation(denom)
+		minAmt := coinA.Amount
+		if minAmt.GT(bAmt) {
+			minAmt = bAmt
+		}
+		if minAmt.IsPositive() {
+			min = min.Add(sdk.NewCoin(denom, minAmt))
+		}
+	}
+	return min
+}
+
+// DisjunctPeriods returns the union of two vesting period schedules.
+// The returned schedule is the union of the vesting events, with simultaneous
+// events combined into a single event.
+// Input schedules P and Q are defined by their start times and periods.
+// Returns new start time, new end time, and merged vesting events, relative to
+// the new start time.
+func DisjunctPeriods(startP, startQ int64, periodsP, periodsQ []Period) (int64, int64, []Period) {
+	timeP := startP // time of last merged p event, next p event is relative to this time
+	timeQ := startQ // time of last merged q event, next q event is relative to this time
+	iP := 0         // p indexes before this have been merged
+	iQ := 0         // q indexes before this have been merged
+	lenP := len(periodsP)
+	lenQ := len(periodsQ)
+	startTime := min64(startP, startQ) // we pick the earlier time
+	time := startTime                  // time of last merged event, or the start time
+	merged := []Period{}
+
+	// emit adds an output period and updates the last event time
+	emit := func(nextTime int64, amount sdk.Coins) {
+		period := Period{
+			Length: nextTime - time,
+			Amount: amount,
+		}
+		merged = append(merged, period)
+		time = nextTime
+	}
+
+	// consumeP emits the next period from p, updating indexes
+	consumeP := func(nextP int64) {
+		emit(nextP, periodsP[iP].Amount)
+		timeP = nextP
+		iP++
+	}
+
+	// consumeQ emits the next period from q, updating indexes
+	consumeQ := func(nextQ int64) {
+		emit(nextQ, periodsQ[iQ].Amount)
+		timeQ = nextQ
+		iQ++
+	}
+
+	// consumeBoth emits a merge of the next periods from p and q, updating indexes
+	consumeBoth := func(nextTime int64) {
+		emit(nextTime, periodsP[iP].Amount.Add(periodsQ[iQ].Amount...))
+		timeP = nextTime
+		timeQ = nextTime
+		iP++
+		iQ++
+	}
+
+	// while there are more events in both schedules, handle the next one, merge if concurrent
+	for iP < lenP && iQ < lenQ {
+		nextP := timeP + periodsP[iP].Length // next p event in absolute time
+		nextQ := timeQ + periodsQ[iQ].Length // next q event in absolute time
+		switch {
+		case nextP < nextQ:
+			consumeP(nextP)
+		case nextP > nextQ:
+			consumeQ(nextQ)
+		default: // nextP == nextQ
+			consumeBoth(nextP)
+		}
+	}
+	// consume remaining events in schedule P
+	for iP < lenP {
+		nextP := timeP + periodsP[iP].Length
+		consumeP(nextP)
+	}
+	// consume remaining events in schedule Q
+	for iQ < lenQ {
+		nextQ := timeQ + periodsQ[iQ].Length
+		consumeQ(nextQ)
+	}
+	return startTime, time, merged
+}
+
+// ConjunctPeriods returns the combination of two period schedules where the result is the minimum of the two schedules.
+func ConjunctPeriods(startP, startQ int64, periodsP, periodsQ []Period) (int64, int64, []Period) {
+	startTime := min64(startP, startQ)
+	time := startTime
+
+	timeP := startP
+	timeQ := startQ
+	iP := 0
+	iQ := 0
+	lenP := len(periodsP)
+	lenQ := len(periodsQ)
+	merged := []Period{}
+	amount := sdk.NewCoins()
+	amountP := amount
+	amountQ := amount
+
+	// emit adds an output period and updates the last event time
+	emit := func(nextTime int64, coins sdk.Coins) {
+		period := Period{
+			Length: nextTime - time,
+			Amount: coins,
+		}
+		merged = append(merged, period)
+		time = nextTime
+		amount = amount.Add(coins...)
+	}
+
+	// consumeP processes the next event in P and emits an event
+	// if the minimum of P and Q changes
+	consumeP := func(nextTime int64) {
+		amountP = amountP.Add(periodsP[iP].Amount...)
+		min := coinsMin(amountP, amountQ)
+		if amount.IsAllLTE(min) {
+			diff := min.Sub(amount...)
+			if !diff.IsZero() {
+				emit(nextTime, diff)
+			}
+		}
+		timeP = nextTime
+		iP++
+	}
+
+	// consumeQ processes the next event in Q and emits an event
+	// if the minimum of P and Q changes
+	consumeQ := func(nextTime int64) {
+		amountQ = amountQ.Add(periodsQ[iQ].Amount...)
+		min := coinsMin(amountP, amountQ)
+		if amount.IsAllLTE(min) {
+			diff := min.Sub(amount...)
+			if !diff.IsZero() {
+				emit(nextTime, diff)
+			}
+		}
+		timeQ = nextTime
+		iQ++
+	}
+
+	// consumeBoth processes simultaneous events in P and Q and emits an
+	// event if the minimum of P and Q changes
+	consumeBoth := func(nextTime int64) {
+		amountP = amountP.Add(periodsP[iP].Amount...)
+		amountQ = amountQ.Add(periodsQ[iQ].Amount...)
+		min := coinsMin(amountP, amountQ)
+		if amount.IsAllLTE(min) {
+			diff := min.Sub(amount...)
+			if !diff.IsZero() {
+				emit(nextTime, diff)
+			}
+		}
+		timeP = nextTime
+		timeQ = nextTime
+		iP++
+		iQ++
+	}
+
+	// while there are events left in both schedules, process the next one
+	for iP < lenP && iQ < lenQ {
+		nextP := timeP + periodsP[iP].Length // next p event in absolute time
+		nextQ := timeQ + periodsQ[iQ].Length // next q event in absolute time
+		switch {
+		case nextP < nextQ:
+			consumeP(nextP)
+		case nextP > nextQ:
+			consumeQ(nextQ)
+		default: // nextP == nextQ
+			consumeBoth(nextP)
+		}
+	}
+
+	// consume remaining events in schedule P
+	for iP < lenP {
+		nextP := timeP + periodsP[iP].Length
+		consumeP(nextP)
+	}
+
+	// consume remaining events in schedule Q
+	for iQ < lenQ {
+		nextQ := timeQ + periodsQ[iQ].Length
+		consumeQ(nextQ)
+	}
+
+	return startTime, time, merged
+}
+
+// AlignSchedules rewrites the first period length to align the two arguments to the same start time.
+func AlignSchedules(startP, startQ int64, p, q []Period) (startTime, endTime int64) {
+	startTime = min64(startP, startQ)
+
+	if len(p) > 0 {
+		p[0].Length += startP - startTime
+	}
+	if len(q) > 0 {
+		q[0].Length += startQ - startTime
+	}
+
+	endP := startTime
+	for _, period := range p {
+		endP += period.Length
+	}
+	endQ := startTime
+	for _, period := range q {
+		endQ += period.Length
+	}
+	endTime = max64(endP, endQ)
+	return
+}
diff --git a/x/auth/vesting/types/period_test.go b/x/auth/vesting/types/period_test.go
new file mode 100644
index 0000000000..a9983ba793
--- /dev/null
+++ b/x/auth/vesting/types/period_test.go
@@ -0,0 +1,280 @@
+package types
+
+import (
+	"testing"
+
+	sdk "github.com/cosmos/cosmos-sdk/types"
+)
+
+func mkper(length int64, amount int64) Period {
+	return Period{
+		Length: length,
+		Amount: sdk.NewCoins(sdk.NewInt64Coin("test", amount)),
+	}
+}
+
+func TestReadSchedule(t *testing.T) {
+	periods := []Period{
+		mkper(10, 10), mkper(20, 20), mkper(40, 40),
+	}
+	total := sdk.NewCoins(sdk.NewInt64Coin("test", 70))
+	for _, tt := range []struct {
+		time int64
+		want int64
+	}{
+		{0, 0},
+		{100, 0},
+		{105, 0},
+		{110, 10},
+		{120, 10},
+		{130, 30},
+		{150, 30},
+		{170, 70},
+		{180, 70},
+	} {
+		gotCoins := ReadSchedule(100, 170, periods, total, tt.time)
+		got := gotCoins.AmountOf("test").Int64()
+		if got != tt.want {
+			t.Errorf("ReadSchedule at %d want %d, got %d", tt.time, tt.want, got)
+		}
+	}
+}
+
+func TestDisjunctPeriods(t *testing.T) {
+	for _, tt := range []struct {
+		name      string
+		startP    int64
+		p         []Period
+		startQ    int64
+		q         []Period
+		wantStart int64
+		wantEnd   int64
+		want      []Period
+	}{
+		{
+			name:      "empty_empty",
+			startP:    0,
+			p:         []Period{},
+			startQ:    0,
+			q:         []Period{},
+			wantStart: 0,
+			want:      []Period{},
+		},
+		{
+			name:      "some_empty",
+			startP:    -123,
+			p:         []Period{mkper(45, 8), mkper(67, 13)},
+			startQ:    -124,
+			q:         []Period{},
+			wantStart: -124,
+			wantEnd:   -11,
+			want:      []Period{mkper(46, 8), mkper(67, 13)},
+		},
+		{
+			name:      "one_one",
+			startP:    0,
+			p:         []Period{mkper(12, 34)},
+			startQ:    0,
+			q:         []Period{mkper(25, 68)},
+			wantStart: 0,
+			wantEnd:   25,
+			want:      []Period{mkper(12, 34), mkper(13, 68)},
+		},
+		{
+			name:      "tied",
+			startP:    12,
+			p:         []Period{mkper(24, 3)},
+			startQ:    0,
+			q:         []Period{mkper(36, 7)},
+			wantStart: 0,
+			wantEnd:   36,
+			want:      []Period{mkper(36, 10)},
+		},
+		{
+			name:      "residual",
+			startP:    105,
+			p:         []Period{mkper(45, 309), mkper(80, 243), mkper(30, 401)},
+			startQ:    120,
+			q:         []Period{mkper(40, 823)},
+			wantStart: 105,
+			wantEnd:   260,
+			want:      []Period{mkper(45, 309), mkper(10, 823), mkper(70, 243), mkper(30, 401)},
+		},
+		{
+			name:      "typical",
+			startP:    1000,
+			p:         []Period{mkper(100, 25), mkper(100, 25), mkper(100, 25), mkper(100, 25)},
+			startQ:    1200,
+			q:         []Period{mkper(100, 10), mkper(100, 10), mkper(100, 10), mkper(100, 10)},
+			wantStart: 1000,
+			wantEnd:   1600,
+			want:      []Period{mkper(100, 25), mkper(100, 25), mkper(100, 35), mkper(100, 35), mkper(100, 10), mkper(100, 10)},
+		},
+	} {
+		t.Run(tt.name, func(t *testing.T) {
+			// Function is commutative in its arguments, so get two tests
+			// for the price of one.  TODO: sub-t.Run() for distinct names.
+			for i := 0; i < 2; i++ {
+				var gotStart, gotEnd int64
+				var got []Period
+				if i == 0 {
+					gotStart, gotEnd, got = DisjunctPeriods(tt.startP, tt.startQ, tt.p, tt.q)
+				} else {
+					gotStart, gotEnd, got = DisjunctPeriods(tt.startQ, tt.startP, tt.q, tt.p)
+				}
+				if gotStart != tt.wantStart {
+					t.Errorf("wrong start time: got %d, want %d", gotStart, tt.wantStart)
+				}
+				if gotEnd != tt.wantEnd {
+					t.Errorf("wrong end time: got %d, want %d", gotEnd, tt.wantEnd)
+				}
+				if len(got) != len(tt.want) {
+					t.Fatalf("wrong number of periods: got %v, want %v", got, tt.want)
+				}
+				for i, gotPeriod := range got {
+					wantPeriod := tt.want[i]
+					if gotPeriod.Length != wantPeriod.Length {
+						t.Errorf("period %d length: got %d, want %d", i, gotPeriod.Length, wantPeriod.Length)
+					}
+					if !gotPeriod.Amount.IsEqual(wantPeriod.Amount) {
+						t.Errorf("period %d amount: got %v, want %v", i, gotPeriod.Amount, wantPeriod.Amount)
+					}
+				}
+			}
+		})
+	}
+}
+
+func TestConjunctPeriods(t *testing.T) {
+	for _, tt := range []struct {
+		name      string
+		startP    int64
+		p         []Period
+		startQ    int64
+		q         []Period
+		wantStart int64
+		wantEnd   int64
+		want      []Period
+	}{
+		{
+			name:      "empty_empty",
+			startP:    0,
+			p:         []Period{},
+			startQ:    0,
+			q:         []Period{},
+			wantStart: 0,
+			wantEnd:   0,
+			want:      []Period{},
+		},
+		{
+			name:      "some_empty",
+			startP:    -123,
+			p:         []Period{mkper(45, 8), mkper(67, 13)},
+			startQ:    -124,
+			q:         []Period{},
+			wantStart: -124,
+			wantEnd:   -124,
+			want:      []Period{},
+		},
+		{
+			name:      "one_one",
+			startP:    0,
+			p:         []Period{mkper(12, 34)},
+			startQ:    0,
+			q:         []Period{mkper(25, 68)},
+			wantStart: 0,
+			wantEnd:   25,
+			want:      []Period{mkper(25, 34)},
+		},
+		{
+			name:      "tied",
+			startP:    12,
+			p:         []Period{mkper(24, 3)},
+			startQ:    0,
+			q:         []Period{mkper(36, 7)},
+			wantStart: 0,
+			wantEnd:   36,
+			want:      []Period{mkper(36, 3)},
+		},
+		{
+			name:      "residual",
+			startP:    105,
+			p:         []Period{mkper(45, 309), mkper(80, 243), mkper(30, 401)},
+			startQ:    120,
+			q:         []Period{mkper(40, 823)},
+			wantStart: 105,
+			wantEnd:   260,
+			want:      []Period{mkper(55, 309), mkper(70, 243), mkper(30, 271)},
+		},
+		{
+			name:      "overlap",
+			startP:    1000,
+			p:         []Period{mkper(100, 25), mkper(100, 25), mkper(100, 25), mkper(100, 25)},
+			startQ:    1200,
+			q:         []Period{mkper(100, 10), mkper(100, 10), mkper(100, 10), mkper(100, 10)},
+			wantStart: 1000,
+			wantEnd:   1600,
+			want:      []Period{mkper(300, 10), mkper(100, 10), mkper(100, 10), mkper(100, 10)},
+		},
+		{
+			name:      "clip",
+			startP:    100,
+			p:         []Period{mkper(10, 1), mkper(10, 1), mkper(10, 1), mkper(10, 1), mkper(10, 1)},
+			startQ:    100,
+			q:         []Period{mkper(1, 3)},
+			wantStart: 100,
+			wantEnd:   130,
+			want:      []Period{mkper(10, 1), mkper(10, 1), mkper(10, 1)},
+		},
+	} {
+		t.Run(tt.name, func(t *testing.T) {
+			// Function is commutative in its arguments, so get two tests
+			// for the price of one.  TODO: sub-t.Run() for distinct names.
+			for i := 0; i < 2; i++ {
+				var gotStart, gotEnd int64
+				var got []Period
+				if i == 0 {
+					gotStart, gotEnd, got = ConjunctPeriods(tt.startP, tt.startQ, tt.p, tt.q)
+				} else {
+					gotStart, gotEnd, got = ConjunctPeriods(tt.startQ, tt.startP, tt.q, tt.p)
+				}
+				if gotStart != tt.wantStart {
+					t.Errorf("wrong start time: got %d, want %d", gotStart, tt.wantStart)
+				}
+				if gotEnd != tt.wantEnd {
+					t.Errorf("wrong end time: got %d, want %d", gotEnd, tt.wantEnd)
+				}
+				if len(got) != len(tt.want) {
+					t.Fatalf("wrong number of periods: got %v, want %v", got, tt.want)
+				}
+				for i, gotPeriod := range got {
+					wantPeriod := tt.want[i]
+					if gotPeriod.Length != wantPeriod.Length {
+						t.Errorf("period %d length: got %d, want %d", i, gotPeriod.Length, wantPeriod.Length)
+					}
+					if !gotPeriod.Amount.IsEqual(wantPeriod.Amount) {
+						t.Errorf("period %d amount: got %v, want %v", i, gotPeriod.Amount, wantPeriod.Amount)
+					}
+				}
+			}
+		})
+	}
+}
+
+func TestAlignSchedules(t *testing.T) {
+	p := []Period{mkper(10, 50), mkper(30, 7)}
+	q := []Period{mkper(40, 6), mkper(10, 8), mkper(5, 3)}
+	start, end := AlignSchedules(100, 200, p, q)
+	if start != 100 {
+		t.Errorf("want start 100, got %d", start)
+	}
+	if end != 255 {
+		t.Errorf("want end 255, got %d", end)
+	}
+	if p[0].Length != 10 {
+		t.Errorf("want p first length unchanged, got %d", p[0].Length)
+	}
+	if q[0].Length != 140 {
+		t.Errorf("want q first length 140, got %d", q[0].Length)
+	}
+}
diff --git a/x/auth/vesting/types/tx.pb.go b/x/auth/vesting/types/tx.pb.go
index 0165ea8331..bc512f5826 100644
--- a/x/auth/vesting/types/tx.pb.go
+++ b/x/auth/vesting/types/tx.pb.go
@@ -263,6 +263,10 @@ type MsgCreatePeriodicVestingAccount struct {
 	// start of vesting as unix time (in seconds).
 	StartTime      int64    `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
 	VestingPeriods []Period `protobuf:"bytes,4,rep,name=vesting_periods,json=vestingPeriods,proto3" json:"vesting_periods"`
+	// If true, merge this new grant into an existing PeriodicVestingAccount,
+	// or create it if it does not exist. If false, creates a new account,
+	// or fails if an account already exists
+	Merge bool `protobuf:"varint,5,opt,name=merge,proto3" json:"merge,omitempty"`
 }
 
 func (m *MsgCreatePeriodicVestingAccount) Reset()         { *m = MsgCreatePeriodicVestingAccount{} }
@@ -326,6 +330,13 @@ func (m *MsgCreatePeriodicVestingAccount) GetVestingPeriods() []Period {
 	return nil
 }
 
+func (m *MsgCreatePeriodicVestingAccount) GetMerge() bool {
+	if m != nil {
+		return m.Merge
+	}
+	return false
+}
+
 // MsgCreateVestingAccountResponse defines the Msg/CreatePeriodicVestingAccount
 // response type.
 //
@@ -368,6 +379,327 @@ func (m *MsgCreatePeriodicVestingAccountResponse) XXX_DiscardUnknown() {
 
 var xxx_messageInfo_MsgCreatePeriodicVestingAccountResponse proto.InternalMessageInfo
 
+// MsgCreateClawbackVestingAccount defines a message that enables creating a ClawbackVestingAccount.
+type MsgCreateClawbackVestingAccount struct {
+	// Address of the account providing the funds, which must also sign the request.
+	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty" yaml:"from_address"`
+	// Address of the account to receive the funds.
+	ToAddress string `protobuf:"bytes,2,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty" yaml:"to_address"`
+	// Start time of the vesting. Periods start relative to this time.
+	StartTime int64 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty" yaml:"start_time"`
+	// Unlocking events as a sequence of durations and amounts, starting relative to start_time.
+	LockupPeriods []Period `protobuf:"bytes,4,rep,name=lockup_periods,json=lockupPeriods,proto3" json:"lockup_periods"`
+	// Vesting events as a sequence of durations and amounts, starting relative to start_time.
+	VestingPeriods []Period `protobuf:"bytes,5,rep,name=vesting_periods,json=vestingPeriods,proto3" json:"vesting_periods"`
+	// If true, merge this new grant into an existing ClawbackVestingAccount,
+	// or create it if it does not exist. If false, creates a new account.
+	// New grants to an existing account must be from the same from_address.
+	Merge bool `protobuf:"varint,6,opt,name=merge,proto3" json:"merge,omitempty"`
+}
+
+func (m *MsgCreateClawbackVestingAccount) Reset()         { *m = MsgCreateClawbackVestingAccount{} }
+func (m *MsgCreateClawbackVestingAccount) String() string { return proto.CompactTextString(m) }
+func (*MsgCreateClawbackVestingAccount) ProtoMessage()    {}
+func (*MsgCreateClawbackVestingAccount) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5338ca97811f9792, []int{6}
+}
+func (m *MsgCreateClawbackVestingAccount) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MsgCreateClawbackVestingAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MsgCreateClawbackVestingAccount.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MsgCreateClawbackVestingAccount) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MsgCreateClawbackVestingAccount.Merge(m, src)
+}
+func (m *MsgCreateClawbackVestingAccount) XXX_Size() int {
+	return m.Size()
+}
+func (m *MsgCreateClawbackVestingAccount) XXX_DiscardUnknown() {
+	xxx_messageInfo_MsgCreateClawbackVestingAccount.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MsgCreateClawbackVestingAccount proto.InternalMessageInfo
+
+func (m *MsgCreateClawbackVestingAccount) GetFromAddress() string {
+	if m != nil {
+		return m.FromAddress
+	}
+	return ""
+}
+
+func (m *MsgCreateClawbackVestingAccount) GetToAddress() string {
+	if m != nil {
+		return m.ToAddress
+	}
+	return ""
+}
+
+func (m *MsgCreateClawbackVestingAccount) GetStartTime() int64 {
+	if m != nil {
+		return m.StartTime
+	}
+	return 0
+}
+
+func (m *MsgCreateClawbackVestingAccount) GetLockupPeriods() []Period {
+	if m != nil {
+		return m.LockupPeriods
+	}
+	return nil
+}
+
+func (m *MsgCreateClawbackVestingAccount) GetVestingPeriods() []Period {
+	if m != nil {
+		return m.VestingPeriods
+	}
+	return nil
+}
+
+func (m *MsgCreateClawbackVestingAccount) GetMerge() bool {
+	if m != nil {
+		return m.Merge
+	}
+	return false
+}
+
+// MsgCreateClawbackVestingAccountResponse defines the MsgCreateClawbackVestingAccount response type.
+type MsgCreateClawbackVestingAccountResponse struct {
+}
+
+func (m *MsgCreateClawbackVestingAccountResponse) Reset() {
+	*m = MsgCreateClawbackVestingAccountResponse{}
+}
+func (m *MsgCreateClawbackVestingAccountResponse) String() string { return proto.CompactTextString(m) }
+func (*MsgCreateClawbackVestingAccountResponse) ProtoMessage()    {}
+func (*MsgCreateClawbackVestingAccountResponse) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5338ca97811f9792, []int{7}
+}
+func (m *MsgCreateClawbackVestingAccountResponse) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MsgCreateClawbackVestingAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MsgCreateClawbackVestingAccountResponse.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MsgCreateClawbackVestingAccountResponse) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MsgCreateClawbackVestingAccountResponse.Merge(m, src)
+}
+func (m *MsgCreateClawbackVestingAccountResponse) XXX_Size() int {
+	return m.Size()
+}
+func (m *MsgCreateClawbackVestingAccountResponse) XXX_DiscardUnknown() {
+	xxx_messageInfo_MsgCreateClawbackVestingAccountResponse.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MsgCreateClawbackVestingAccountResponse proto.InternalMessageInfo
+
+// MsgClawback defines a message that removes unvested tokens from a ClawbackVestingAccount.
+type MsgClawback struct {
+	// funder_address is the address which funded the account
+	FunderAddress string `protobuf:"bytes,1,opt,name=funder_address,json=funderAddress,proto3" json:"funder_address,omitempty"`
+	// address is the address of the ClawbackVestingAccount to claw back from.
+	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
+	// dest_address specifies where the clawed-back tokens should be transferred.
+	// If empty, the tokens will be transferred back to the original funder of the account.
+	DestAddress string `protobuf:"bytes,3,opt,name=dest_address,json=destAddress,proto3" json:"dest_address,omitempty"`
+}
+
+func (m *MsgClawback) Reset()         { *m = MsgClawback{} }
+func (m *MsgClawback) String() string { return proto.CompactTextString(m) }
+func (*MsgClawback) ProtoMessage()    {}
+func (*MsgClawback) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5338ca97811f9792, []int{8}
+}
+func (m *MsgClawback) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MsgClawback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MsgClawback.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MsgClawback) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MsgClawback.Merge(m, src)
+}
+func (m *MsgClawback) XXX_Size() int {
+	return m.Size()
+}
+func (m *MsgClawback) XXX_DiscardUnknown() {
+	xxx_messageInfo_MsgClawback.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MsgClawback proto.InternalMessageInfo
+
+func (m *MsgClawback) GetFunderAddress() string {
+	if m != nil {
+		return m.FunderAddress
+	}
+	return ""
+}
+
+func (m *MsgClawback) GetAddress() string {
+	if m != nil {
+		return m.Address
+	}
+	return ""
+}
+
+func (m *MsgClawback) GetDestAddress() string {
+	if m != nil {
+		return m.DestAddress
+	}
+	return ""
+}
+
+// MsgClawbackResponse defines the MsgClawback response type.
+type MsgClawbackResponse struct {
+}
+
+func (m *MsgClawbackResponse) Reset()         { *m = MsgClawbackResponse{} }
+func (m *MsgClawbackResponse) String() string { return proto.CompactTextString(m) }
+func (*MsgClawbackResponse) ProtoMessage()    {}
+func (*MsgClawbackResponse) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5338ca97811f9792, []int{9}
+}
+func (m *MsgClawbackResponse) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MsgClawbackResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MsgClawbackResponse.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MsgClawbackResponse) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MsgClawbackResponse.Merge(m, src)
+}
+func (m *MsgClawbackResponse) XXX_Size() int {
+	return m.Size()
+}
+func (m *MsgClawbackResponse) XXX_DiscardUnknown() {
+	xxx_messageInfo_MsgClawbackResponse.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MsgClawbackResponse proto.InternalMessageInfo
+
+// MsgReturnGrants defines a message for a grantee to return all granted assets,
+// including delegated, undelegated and unbonding, vested and unvested,
+// are transferred to the original funder of the account. Might not be complete if
+// some vested assets have been transferred out of the account. Currently only applies to
+// ClawbackVesting accounts.
+type MsgReturnGrants struct {
+	// address is the address of the grantee account returning the grant.
+	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
+}
+
+func (m *MsgReturnGrants) Reset()         { *m = MsgReturnGrants{} }
+func (m *MsgReturnGrants) String() string { return proto.CompactTextString(m) }
+func (*MsgReturnGrants) ProtoMessage()    {}
+func (*MsgReturnGrants) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5338ca97811f9792, []int{10}
+}
+func (m *MsgReturnGrants) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MsgReturnGrants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MsgReturnGrants.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MsgReturnGrants) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MsgReturnGrants.Merge(m, src)
+}
+func (m *MsgReturnGrants) XXX_Size() int {
+	return m.Size()
+}
+func (m *MsgReturnGrants) XXX_DiscardUnknown() {
+	xxx_messageInfo_MsgReturnGrants.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MsgReturnGrants proto.InternalMessageInfo
+
+func (m *MsgReturnGrants) GetAddress() string {
+	if m != nil {
+		return m.Address
+	}
+	return ""
+}
+
+// MsgReturnGrantsResponse defines the ReturnGrants response type.
+type MsgReturnGrantsResponse struct {
+}
+
+func (m *MsgReturnGrantsResponse) Reset()         { *m = MsgReturnGrantsResponse{} }
+func (m *MsgReturnGrantsResponse) String() string { return proto.CompactTextString(m) }
+func (*MsgReturnGrantsResponse) ProtoMessage()    {}
+func (*MsgReturnGrantsResponse) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5338ca97811f9792, []int{11}
+}
+func (m *MsgReturnGrantsResponse) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MsgReturnGrantsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MsgReturnGrantsResponse.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MsgReturnGrantsResponse) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MsgReturnGrantsResponse.Merge(m, src)
+}
+func (m *MsgReturnGrantsResponse) XXX_Size() int {
+	return m.Size()
+}
+func (m *MsgReturnGrantsResponse) XXX_DiscardUnknown() {
+	xxx_messageInfo_MsgReturnGrantsResponse.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MsgReturnGrantsResponse proto.InternalMessageInfo
+
 func init() {
 	proto.RegisterType((*MsgCreateVestingAccount)(nil), "cosmos.vesting.v1beta1.MsgCreateVestingAccount")
 	proto.RegisterType((*MsgCreateVestingAccountResponse)(nil), "cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse")
@@ -375,51 +707,69 @@ func init() {
 	proto.RegisterType((*MsgCreatePermanentLockedAccountResponse)(nil), "cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse")
 	proto.RegisterType((*MsgCreatePeriodicVestingAccount)(nil), "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount")
 	proto.RegisterType((*MsgCreatePeriodicVestingAccountResponse)(nil), "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse")
+	proto.RegisterType((*MsgCreateClawbackVestingAccount)(nil), "cosmos.vesting.v1beta1.MsgCreateClawbackVestingAccount")
+	proto.RegisterType((*MsgCreateClawbackVestingAccountResponse)(nil), "cosmos.vesting.v1beta1.MsgCreateClawbackVestingAccountResponse")
+	proto.RegisterType((*MsgClawback)(nil), "cosmos.vesting.v1beta1.MsgClawback")
+	proto.RegisterType((*MsgClawbackResponse)(nil), "cosmos.vesting.v1beta1.MsgClawbackResponse")
+	proto.RegisterType((*MsgReturnGrants)(nil), "cosmos.vesting.v1beta1.MsgReturnGrants")
+	proto.RegisterType((*MsgReturnGrantsResponse)(nil), "cosmos.vesting.v1beta1.MsgReturnGrantsResponse")
 }
 
 func init() { proto.RegisterFile("cosmos/vesting/v1beta1/tx.proto", fileDescriptor_5338ca97811f9792) }
 
 var fileDescriptor_5338ca97811f9792 = []byte{
-	// 609 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x94, 0xb1, 0x6f, 0xd3, 0x40,
-	0x14, 0xc6, 0x73, 0x75, 0x68, 0x9b, 0x2b, 0x02, 0x61, 0x52, 0xe2, 0x44, 0xd4, 0x4e, 0x2d, 0x24,
-	0x0c, 0x52, 0x6d, 0x52, 0x90, 0x2a, 0x85, 0x01, 0x35, 0x1d, 0x21, 0x12, 0x32, 0x88, 0x81, 0x25,
-	0x72, 0xec, 0xc3, 0xb5, 0x5a, 0xfb, 0x22, 0xdf, 0xa5, 0x6a, 0x36, 0xc4, 0x5f, 0xc0, 0xc8, 0xc8,
-	0xcc, 0xc4, 0xc0, 0x8c, 0x18, 0x3b, 0x56, 0x4c, 0x4c, 0x01, 0x25, 0x03, 0x9d, 0xfb, 0x07, 0x20,
-	0x64, 0xdf, 0x39, 0x34, 0xe9, 0x25, 0x29, 0x0c, 0x4c, 0x4e, 0xee, 0x7d, 0xdf, 0xdd, 0xbb, 0x9f,
-	0xbf, 0x67, 0xa8, 0xb9, 0x98, 0x84, 0x98, 0x58, 0x07, 0x88, 0xd0, 0x20, 0xf2, 0xad, 0x83, 0x5a,
-	0x1b, 0x51, 0xa7, 0x66, 0xd1, 0x43, 0xb3, 0x13, 0x63, 0x8a, 0xe5, 0x1b, 0x4c, 0x60, 0x72, 0x81,
-	0xc9, 0x05, 0x95, 0xa2, 0x8f, 0x7d, 0x9c, 0x4a, 0xac, 0xe4, 0x17, 0x53, 0x57, 0x54, 0xbe, 0x5d,
-	0xdb, 0x21, 0x68, 0xb4, 0x97, 0x8b, 0x83, 0x88, 0xd7, 0xcb, 0xac, 0xde, 0x62, 0x46, 0xbe, 0x35,
-	0x2b, 0xdd, 0x9a, 0xd2, 0x49, 0x76, 0x30, 0x53, 0x95, 0xb8, 0x2a, 0x24, 0x89, 0x22, 0x79, 0xb0,
-	0x82, 0xfe, 0x65, 0x01, 0x96, 0x9a, 0xc4, 0xdf, 0x89, 0x91, 0x43, 0xd1, 0x0b, 0xe6, 0xd9, 0x76,
-	0x5d, 0xdc, 0x8d, 0xa8, 0xfc, 0x10, 0x5e, 0x7e, 0x15, 0xe3, 0xb0, 0xe5, 0x78, 0x5e, 0x8c, 0x08,
-	0x51, 0x40, 0x15, 0x18, 0x85, 0x86, 0xf2, 0xf5, 0xd3, 0x46, 0x91, 0xb7, 0xb0, 0xcd, 0x2a, 0xcf,
-	0x68, 0x1c, 0x44, 0xbe, 0xbd, 0x92, 0xa8, 0xf9, 0x92, 0xbc, 0x05, 0x21, 0xc5, 0x23, 0xeb, 0xc2,
-	0x1c, 0x6b, 0x81, 0xe2, 0xcc, 0xe8, 0xc2, 0x45, 0x27, 0x4c, 0xce, 0x57, 0xa4, 0xaa, 0x64, 0xac,
-	0x6c, 0x96, 0x4d, 0xee, 0x48, 0xe0, 0x64, 0x1c, 0xcd, 0x1d, 0x1c, 0x44, 0x8d, 0x7b, 0x47, 0x7d,
-	0x2d, 0xf7, 0xe1, 0xbb, 0x66, 0xf8, 0x01, 0xdd, 0xed, 0xb6, 0x4d, 0x17, 0x87, 0x1c, 0x0e, 0x7f,
-	0x6c, 0x10, 0x6f, 0xcf, 0xa2, 0xbd, 0x0e, 0x22, 0xa9, 0x81, 0xd8, 0x7c, 0x6b, 0xb9, 0x0c, 0x97,
-	0x51, 0xe4, 0xb5, 0x68, 0x10, 0x22, 0x25, 0x5f, 0x05, 0x86, 0x64, 0x2f, 0xa1, 0xc8, 0x7b, 0x1e,
-	0x84, 0x48, 0x56, 0xe0, 0x92, 0x87, 0xf6, 0x9d, 0x1e, 0xf2, 0x94, 0x4b, 0x55, 0x60, 0x2c, 0xdb,
-	0xd9, 0xdf, 0xfa, 0xea, 0xc9, 0x7b, 0x0d, 0xbc, 0xf9, 0xf9, 0xf1, 0xee, 0x18, 0x16, 0x7d, 0x1d,
-	0x6a, 0x53, 0x08, 0xda, 0x88, 0x74, 0x70, 0x44, 0x90, 0xfe, 0x0b, 0x9c, 0xd1, 0x3c, 0x45, 0x71,
-	0xe8, 0x44, 0x28, 0xa2, 0x4f, 0xb0, 0xbb, 0x87, 0xbc, 0x8c, 0x76, 0x5d, 0x48, 0xbb, 0x74, 0xda,
-	0xd7, 0xae, 0xf7, 0x9c, 0x70, 0xbf, 0xae, 0x8f, 0x1d, 0x3a, 0x0e, 0xfb, 0x81, 0x00, 0xf6, 0xea,
-	0x69, 0x5f, 0xbb, 0xc6, 0x9c, 0x7f, 0x6a, 0xfa, 0xff, 0x26, 0x5d, 0xcf, 0x27, 0xd0, 0xf4, 0x3b,
-	0xf0, 0xf6, 0x9c, 0xfb, 0x8f, 0x58, 0x9d, 0x4c, 0xb0, 0x0a, 0xb0, 0x17, 0xb8, 0x13, 0xc9, 0x5c,
-	0x17, 0xb1, 0x1a, 0x47, 0xb2, 0x76, 0x1e, 0xc9, 0xd9, 0xbb, 0xaf, 0x41, 0x48, 0xa8, 0x13, 0x53,
-	0x16, 0x01, 0x29, 0x8d, 0x40, 0x21, 0x5d, 0x49, 0x43, 0xd0, 0x84, 0x57, 0xf9, 0x00, 0xb5, 0x3a,
-	0x69, 0x0b, 0x44, 0xc9, 0xa7, 0x8c, 0x54, 0x53, 0x3c, 0xd8, 0x26, 0xeb, 0xb4, 0x91, 0x4f, 0x40,
-	0xd9, 0x57, 0x78, 0x95, 0x2d, 0x92, 0x34, 0x39, 0xb9, 0xf3, 0xc9, 0x99, 0xa0, 0x22, 0xb8, 0x69,
-	0x46, 0x65, 0xf3, 0xb3, 0x04, 0xa5, 0x26, 0xf1, 0xe5, 0xd7, 0x00, 0x16, 0x85, 0xc3, 0x6a, 0x4d,
-	0x6b, 0x6c, 0x4a, 0x36, 0x2b, 0x5b, 0x7f, 0x69, 0xc8, 0x5a, 0x91, 0xdf, 0x01, 0x78, 0x73, 0x66,
-	0x92, 0xe7, 0xef, 0x2c, 0x36, 0x56, 0x1e, 0xfd, 0xa3, 0x51, 0xdc, 0x9a, 0x28, 0x38, 0x17, 0x6a,
-	0x4d, 0x60, 0xbc, 0x58, 0x6b, 0x33, 0x5e, 0x60, 0xe3, 0xf1, 0xd1, 0x40, 0x05, 0xc7, 0x03, 0x15,
-	0xfc, 0x18, 0xa8, 0xe0, 0xed, 0x50, 0xcd, 0x1d, 0x0f, 0xd5, 0xdc, 0xb7, 0xa1, 0x9a, 0x7b, 0x59,
-	0x9b, 0x39, 0x53, 0x87, 0x96, 0xd3, 0xa5, 0xbb, 0xa3, 0xcf, 0x7b, 0x3a, 0x62, 0xed, 0xc5, 0xf4,
-	0xe3, 0x7d, 0xff, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3d, 0xa4, 0x06, 0x42, 0x87, 0x06, 0x00,
-	0x00,
+	// 812 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x96, 0xcd, 0x6e, 0xd3, 0x4a,
+	0x14, 0xc7, 0xe3, 0x26, 0x4d, 0xdb, 0xe9, 0x97, 0xae, 0x9b, 0xde, 0x3a, 0xd1, 0xad, 0x93, 0xfa,
+	0xde, 0xab, 0x06, 0xaa, 0xda, 0xb4, 0x54, 0xaa, 0x14, 0x16, 0xa8, 0xe9, 0x82, 0x45, 0x89, 0x84,
+	0x0c, 0x62, 0x81, 0x90, 0x22, 0xc7, 0x9e, 0xba, 0x56, 0x62, 0x4f, 0xf0, 0x4c, 0x4a, 0xbb, 0x03,
+	0x9e, 0x80, 0x25, 0x4b, 0xd8, 0xb2, 0x62, 0xc1, 0x03, 0xb0, 0xec, 0xb2, 0x62, 0xc5, 0xaa, 0xa0,
+	0x76, 0x01, 0xeb, 0x3e, 0x00, 0x42, 0xf6, 0x8c, 0x5d, 0x3b, 0x75, 0x3e, 0xa8, 0x50, 0x57, 0x89,
+	0xe7, 0xfc, 0xff, 0x67, 0x8e, 0x7f, 0x73, 0x66, 0xc6, 0xa0, 0xa8, 0x23, 0x6c, 0x23, 0xac, 0xec,
+	0x43, 0x4c, 0x2c, 0xc7, 0x54, 0xf6, 0xd7, 0x1a, 0x90, 0x68, 0x6b, 0x0a, 0x39, 0x90, 0xdb, 0x2e,
+	0x22, 0x88, 0xff, 0x9b, 0x0a, 0x64, 0x26, 0x90, 0x99, 0xa0, 0x90, 0x33, 0x91, 0x89, 0x7c, 0x89,
+	0xe2, 0xfd, 0xa3, 0xea, 0x82, 0xc8, 0xd2, 0x35, 0x34, 0x0c, 0xc3, 0x5c, 0x3a, 0xb2, 0x1c, 0x16,
+	0xcf, 0xd3, 0x78, 0x9d, 0x1a, 0x59, 0x6a, 0x1a, 0xfa, 0xaf, 0x47, 0x25, 0xc1, 0xc4, 0x54, 0xb5,
+	0xc0, 0x54, 0x36, 0xf6, 0x14, 0xde, 0x0f, 0x0d, 0x48, 0x9f, 0x46, 0xc0, 0x42, 0x0d, 0x9b, 0xdb,
+	0x2e, 0xd4, 0x08, 0x7c, 0x4c, 0x3d, 0x5b, 0xba, 0x8e, 0x3a, 0x0e, 0xe1, 0xef, 0x80, 0xa9, 0x5d,
+	0x17, 0xd9, 0x75, 0xcd, 0x30, 0x5c, 0x88, 0xb1, 0xc0, 0x95, 0xb8, 0xf2, 0x44, 0x55, 0xf8, 0xfc,
+	0x71, 0x35, 0xc7, 0x4a, 0xd8, 0xa2, 0x91, 0x87, 0xc4, 0xb5, 0x1c, 0x53, 0x9d, 0xf4, 0xd4, 0x6c,
+	0x88, 0xdf, 0x04, 0x80, 0xa0, 0xd0, 0x3a, 0x32, 0xc0, 0x3a, 0x41, 0x50, 0x60, 0xd4, 0x41, 0x56,
+	0xb3, 0xbd, 0xf9, 0x85, 0x74, 0x29, 0x5d, 0x9e, 0x5c, 0xcf, 0xcb, 0xcc, 0xe1, 0xc1, 0x09, 0x38,
+	0xca, 0xdb, 0xc8, 0x72, 0xaa, 0xb7, 0x8e, 0x4e, 0x8a, 0xa9, 0xf7, 0x5f, 0x8b, 0x65, 0xd3, 0x22,
+	0x7b, 0x9d, 0x86, 0xac, 0x23, 0x9b, 0xc1, 0x61, 0x3f, 0xab, 0xd8, 0x68, 0x2a, 0xe4, 0xb0, 0x0d,
+	0xb1, 0x6f, 0xc0, 0x2a, 0x4b, 0xcd, 0xe7, 0xc1, 0x38, 0x74, 0x8c, 0x3a, 0xb1, 0x6c, 0x28, 0x64,
+	0x4a, 0x5c, 0x39, 0xad, 0x8e, 0x41, 0xc7, 0x78, 0x64, 0xd9, 0x90, 0x17, 0xc0, 0x98, 0x01, 0x5b,
+	0xda, 0x21, 0x34, 0x84, 0xd1, 0x12, 0x57, 0x1e, 0x57, 0x83, 0xc7, 0xca, 0xfc, 0x8f, 0xb7, 0x45,
+	0xee, 0xd5, 0xf7, 0x0f, 0x37, 0x63, 0x58, 0xa4, 0x25, 0x50, 0xec, 0x41, 0x50, 0x85, 0xb8, 0x8d,
+	0x1c, 0x0c, 0xa5, 0x9f, 0x5c, 0x44, 0xf3, 0x00, 0xba, 0xb6, 0xe6, 0x40, 0x87, 0xdc, 0x47, 0x7a,
+	0x13, 0x1a, 0x01, 0xed, 0x4a, 0x22, 0xed, 0x85, 0xf3, 0x93, 0xe2, 0xdc, 0xa1, 0x66, 0xb7, 0x2a,
+	0x52, 0x6c, 0xd2, 0x38, 0xec, 0x8d, 0x04, 0xd8, 0xf3, 0xe7, 0x27, 0xc5, 0xbf, 0xa8, 0xf3, 0x22,
+	0x26, 0x5d, 0x37, 0xe9, 0x4a, 0xc6, 0x83, 0x26, 0xdd, 0x00, 0xcb, 0x03, 0xde, 0xbf, 0x27, 0x2b,
+	0x0b, 0x19, 0x96, 0xde, 0xd5, 0x99, 0x4b, 0x49, 0xac, 0xe2, 0x48, 0x16, 0x2f, 0x23, 0x89, 0xbe,
+	0xfb, 0x22, 0x00, 0x98, 0x68, 0x2e, 0xa1, 0x2d, 0x90, 0xf6, 0x5b, 0x60, 0xc2, 0x1f, 0xf1, 0x9b,
+	0xa0, 0x06, 0x66, 0xd9, 0x06, 0xaa, 0xb7, 0xfd, 0x12, 0xb0, 0x90, 0xf1, 0x19, 0x89, 0x72, 0xf2,
+	0xc6, 0x96, 0x69, 0xa5, 0xd5, 0x8c, 0x07, 0x4a, 0x9d, 0x61, 0x51, 0x3a, 0x88, 0xf9, 0x1c, 0x18,
+	0xb5, 0xa1, 0x6b, 0x42, 0xd6, 0x51, 0xf4, 0xc1, 0xef, 0xa7, 0xd4, 0xe5, 0x7e, 0xea, 0x62, 0x95,
+	0xf0, 0xfe, 0x21, 0xab, 0x97, 0xe9, 0x08, 0xab, 0xed, 0x96, 0xf6, 0xbc, 0xa1, 0xe9, 0xcd, 0x2e,
+	0x56, 0xd7, 0xdf, 0x57, 0x1b, 0x97, 0xd9, 0x46, 0x5d, 0x17, 0x31, 0x29, 0x8a, 0x7c, 0x07, 0xcc,
+	0xb4, 0x90, 0xde, 0xec, 0xb4, 0xaf, 0x44, 0x7c, 0x9a, 0x7a, 0x03, 0xe0, 0x09, 0xeb, 0x37, 0xfa,
+	0x27, 0xd6, 0x2f, 0x1b, 0x5d, 0x3f, 0xaf, 0xb5, 0x53, 0xb1, 0xe5, 0x4a, 0x5e, 0x82, 0x70, 0xb9,
+	0x9e, 0x81, 0x49, 0x4f, 0xca, 0x44, 0xfc, 0xff, 0x60, 0x66, 0xb7, 0xe3, 0x18, 0xd0, 0xed, 0xea,
+	0xe3, 0x69, 0x3a, 0x1a, 0xe0, 0x14, 0xc0, 0x58, 0xbc, 0x8d, 0x83, 0x47, 0x6f, 0x1b, 0x18, 0x10,
+	0x93, 0xd0, 0x9e, 0xa6, 0xdb, 0xc0, 0x1b, 0x63, 0x66, 0x69, 0x1e, 0xcc, 0x45, 0xa6, 0x0c, 0x2b,
+	0x59, 0x01, 0xb3, 0x35, 0x6c, 0xaa, 0x90, 0x74, 0x5c, 0xe7, 0x9e, 0xab, 0x39, 0x24, 0x36, 0x0d,
+	0x17, 0x9b, 0x46, 0xca, 0xfb, 0x57, 0x44, 0x54, 0x1c, 0xe4, 0x59, 0x7f, 0x97, 0x05, 0xe9, 0x1a,
+	0x36, 0xf9, 0x17, 0x1c, 0xc8, 0x25, 0xde, 0x21, 0x4a, 0x2f, 0xde, 0x3d, 0x8e, 0xcc, 0xc2, 0xe6,
+	0x6f, 0x1a, 0x82, 0x52, 0xf8, 0x37, 0x1c, 0xf8, 0xa7, 0xef, 0x01, 0x3b, 0x38, 0x73, 0xb2, 0xb1,
+	0x70, 0xf7, 0x8a, 0xc6, 0xe4, 0xd2, 0x92, 0xce, 0xb3, 0xa1, 0x4a, 0x4b, 0x30, 0x0e, 0x57, 0x5a,
+	0x9f, 0x13, 0x24, 0x52, 0x5a, 0x8f, 0xe3, 0x63, 0x70, 0x69, 0xc9, 0xc6, 0x21, 0x4a, 0xeb, 0xbf,
+	0x5b, 0xf8, 0xa7, 0x60, 0x3c, 0xdc, 0x2a, 0xff, 0xf6, 0x4b, 0xc6, 0x44, 0x85, 0x95, 0x21, 0x44,
+	0x61, 0xf6, 0x3d, 0x30, 0x15, 0x6b, 0xff, 0xe5, 0x3e, 0xe6, 0xa8, 0xb0, 0xa0, 0x0c, 0x29, 0x0c,
+	0x66, 0xaa, 0xee, 0x1c, 0x9d, 0x8a, 0xdc, 0xf1, 0xa9, 0xc8, 0x7d, 0x3b, 0x15, 0xb9, 0xd7, 0x67,
+	0x62, 0xea, 0xf8, 0x4c, 0x4c, 0x7d, 0x39, 0x13, 0x53, 0x4f, 0xd6, 0xfa, 0xde, 0xa6, 0x07, 0x8a,
+	0xd6, 0x21, 0x7b, 0xe1, 0x87, 0x9d, 0x7f, 0xb9, 0x36, 0xb2, 0xfe, 0x67, 0xdb, 0xed, 0x5f, 0x01,
+	0x00, 0x00, 0xff, 0xff, 0xa2, 0x69, 0x07, 0x2e, 0x81, 0x0a, 0x00, 0x00,
 }
 
 func (this *MsgCreateVestingAccount) Equal(that interface{}) bool {
@@ -524,6 +874,13 @@ type MsgClient interface {
 	//
 	// Since: cosmos-sdk 0.46
 	CreatePeriodicVestingAccount(ctx context.Context, in *MsgCreatePeriodicVestingAccount, opts ...grpc.CallOption) (*MsgCreatePeriodicVestingAccountResponse, error)
+	// CreateClawbackVestingAccount defines a method that enables creating a
+	// vesting account that is subject to clawback.
+	CreateClawbackVestingAccount(ctx context.Context, in *MsgCreateClawbackVestingAccount, opts ...grpc.CallOption) (*MsgCreateClawbackVestingAccountResponse, error)
+	// Clawback removes the unvested tokens from a ClawbackVestingAccount.
+	Clawback(ctx context.Context, in *MsgClawback, opts ...grpc.CallOption) (*MsgClawbackResponse, error)
+	// ReturnGrants returns vesting grants to the funder.
+	ReturnGrants(ctx context.Context, in *MsgReturnGrants, opts ...grpc.CallOption) (*MsgReturnGrantsResponse, error)
 }
 
 type msgClient struct {
@@ -561,6 +918,33 @@ func (c *msgClient) CreatePeriodicVestingAccount(ctx context.Context, in *MsgCre
 	return out, nil
 }
 
+func (c *msgClient) CreateClawbackVestingAccount(ctx context.Context, in *MsgCreateClawbackVestingAccount, opts ...grpc.CallOption) (*MsgCreateClawbackVestingAccountResponse, error) {
+	out := new(MsgCreateClawbackVestingAccountResponse)
+	err := c.cc.Invoke(ctx, "/cosmos.vesting.v1beta1.Msg/CreateClawbackVestingAccount", in, out, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+func (c *msgClient) Clawback(ctx context.Context, in *MsgClawback, opts ...grpc.CallOption) (*MsgClawbackResponse, error) {
+	out := new(MsgClawbackResponse)
+	err := c.cc.Invoke(ctx, "/cosmos.vesting.v1beta1.Msg/Clawback", in, out, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+func (c *msgClient) ReturnGrants(ctx context.Context, in *MsgReturnGrants, opts ...grpc.CallOption) (*MsgReturnGrantsResponse, error) {
+	out := new(MsgReturnGrantsResponse)
+	err := c.cc.Invoke(ctx, "/cosmos.vesting.v1beta1.Msg/ReturnGrants", in, out, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
 // MsgServer is the server API for Msg service.
 type MsgServer interface {
 	// CreateVestingAccount defines a method that enables creating a vesting
@@ -576,6 +960,13 @@ type MsgServer interface {
 	//
 	// Since: cosmos-sdk 0.46
 	CreatePeriodicVestingAccount(context.Context, *MsgCreatePeriodicVestingAccount) (*MsgCreatePeriodicVestingAccountResponse, error)
+	// CreateClawbackVestingAccount defines a method that enables creating a
+	// vesting account that is subject to clawback.
+	CreateClawbackVestingAccount(context.Context, *MsgCreateClawbackVestingAccount) (*MsgCreateClawbackVestingAccountResponse, error)
+	// Clawback removes the unvested tokens from a ClawbackVestingAccount.
+	Clawback(context.Context, *MsgClawback) (*MsgClawbackResponse, error)
+	// ReturnGrants returns vesting grants to the funder.
+	ReturnGrants(context.Context, *MsgReturnGrants) (*MsgReturnGrantsResponse, error)
 }
 
 // UnimplementedMsgServer can be embedded to have forward compatible implementations.
@@ -591,6 +982,15 @@ func (*UnimplementedMsgServer) CreatePermanentLockedAccount(ctx context.Context,
 func (*UnimplementedMsgServer) CreatePeriodicVestingAccount(ctx context.Context, req *MsgCreatePeriodicVestingAccount) (*MsgCreatePeriodicVestingAccountResponse, error) {
 	return nil, status.Errorf(codes.Unimplemented, "method CreatePeriodicVestingAccount not implemented")
 }
+func (*UnimplementedMsgServer) CreateClawbackVestingAccount(ctx context.Context, req *MsgCreateClawbackVestingAccount) (*MsgCreateClawbackVestingAccountResponse, error) {
+	return nil, status.Errorf(codes.Unimplemented, "method CreateClawbackVestingAccount not implemented")
+}
+func (*UnimplementedMsgServer) Clawback(ctx context.Context, req *MsgClawback) (*MsgClawbackResponse, error) {
+	return nil, status.Errorf(codes.Unimplemented, "method Clawback not implemented")
+}
+func (*UnimplementedMsgServer) ReturnGrants(ctx context.Context, req *MsgReturnGrants) (*MsgReturnGrantsResponse, error) {
+	return nil, status.Errorf(codes.Unimplemented, "method ReturnGrants not implemented")
+}
 
 func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
 	s.RegisterService(&_Msg_serviceDesc, srv)
@@ -650,6 +1050,60 @@ func _Msg_CreatePeriodicVestingAccount_Handler(srv interface{}, ctx context.Cont
 	return interceptor(ctx, in, info, handler)
 }
 
+func _Msg_CreateClawbackVestingAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(MsgCreateClawbackVestingAccount)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(MsgServer).CreateClawbackVestingAccount(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/cosmos.vesting.v1beta1.Msg/CreateClawbackVestingAccount",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(MsgServer).CreateClawbackVestingAccount(ctx, req.(*MsgCreateClawbackVestingAccount))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+func _Msg_Clawback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(MsgClawback)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(MsgServer).Clawback(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/cosmos.vesting.v1beta1.Msg/Clawback",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(MsgServer).Clawback(ctx, req.(*MsgClawback))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+func _Msg_ReturnGrants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(MsgReturnGrants)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(MsgServer).ReturnGrants(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/cosmos.vesting.v1beta1.Msg/ReturnGrants",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(MsgServer).ReturnGrants(ctx, req.(*MsgReturnGrants))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
 var _Msg_serviceDesc = grpc.ServiceDesc{
 	ServiceName: "cosmos.vesting.v1beta1.Msg",
 	HandlerType: (*MsgServer)(nil),
@@ -666,6 +1120,18 @@ var _Msg_serviceDesc = grpc.ServiceDesc{
 			MethodName: "CreatePeriodicVestingAccount",
 			Handler:    _Msg_CreatePeriodicVestingAccount_Handler,
 		},
+		{
+			MethodName: "CreateClawbackVestingAccount",
+			Handler:    _Msg_CreateClawbackVestingAccount_Handler,
+		},
+		{
+			MethodName: "Clawback",
+			Handler:    _Msg_Clawback_Handler,
+		},
+		{
+			MethodName: "ReturnGrants",
+			Handler:    _Msg_ReturnGrants_Handler,
+		},
 	},
 	Streams:  []grpc.StreamDesc{},
 	Metadata: "cosmos/vesting/v1beta1/tx.proto",
@@ -854,13 +1320,23 @@ func (m *MsgCreatePeriodicVestingAccount) MarshalToSizedBuffer(dAtA []byte) (int
 	_ = i
 	var l int
 	_ = l
-	if len(m.VestingPeriods) > 0 {
-		for iNdEx := len(m.VestingPeriods) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.VestingPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
+	if m.Merge {
+		i--
+		if m.Merge {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x28
+	}
+	if len(m.VestingPeriods) > 0 {
+		for iNdEx := len(m.VestingPeriods) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.VestingPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
 				i -= size
 				i = encodeVarintTx(dAtA, i, uint64(size))
 			}
@@ -913,6 +1389,229 @@ func (m *MsgCreatePeriodicVestingAccountResponse) MarshalToSizedBuffer(dAtA []by
 	return len(dAtA) - i, nil
 }
 
+func (m *MsgCreateClawbackVestingAccount) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MsgCreateClawbackVestingAccount) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MsgCreateClawbackVestingAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.Merge {
+		i--
+		if m.Merge {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x30
+	}
+	if len(m.VestingPeriods) > 0 {
+		for iNdEx := len(m.VestingPeriods) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.VestingPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintTx(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x2a
+		}
+	}
+	if len(m.LockupPeriods) > 0 {
+		for iNdEx := len(m.LockupPeriods) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.LockupPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintTx(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x22
+		}
+	}
+	if m.StartTime != 0 {
+		i = encodeVarintTx(dAtA, i, uint64(m.StartTime))
+		i--
+		dAtA[i] = 0x18
+	}
+	if len(m.ToAddress) > 0 {
+		i -= len(m.ToAddress)
+		copy(dAtA[i:], m.ToAddress)
+		i = encodeVarintTx(dAtA, i, uint64(len(m.ToAddress)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.FromAddress) > 0 {
+		i -= len(m.FromAddress)
+		copy(dAtA[i:], m.FromAddress)
+		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *MsgCreateClawbackVestingAccountResponse) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MsgCreateClawbackVestingAccountResponse) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MsgCreateClawbackVestingAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	return len(dAtA) - i, nil
+}
+
+func (m *MsgClawback) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MsgClawback) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MsgClawback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.DestAddress) > 0 {
+		i -= len(m.DestAddress)
+		copy(dAtA[i:], m.DestAddress)
+		i = encodeVarintTx(dAtA, i, uint64(len(m.DestAddress)))
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Address) > 0 {
+		i -= len(m.Address)
+		copy(dAtA[i:], m.Address)
+		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.FunderAddress) > 0 {
+		i -= len(m.FunderAddress)
+		copy(dAtA[i:], m.FunderAddress)
+		i = encodeVarintTx(dAtA, i, uint64(len(m.FunderAddress)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *MsgClawbackResponse) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MsgClawbackResponse) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MsgClawbackResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	return len(dAtA) - i, nil
+}
+
+func (m *MsgReturnGrants) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MsgReturnGrants) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MsgReturnGrants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.Address) > 0 {
+		i -= len(m.Address)
+		copy(dAtA[i:], m.Address)
+		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *MsgReturnGrantsResponse) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MsgReturnGrantsResponse) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MsgReturnGrantsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	return len(dAtA) - i, nil
+}
+
 func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
 	offset -= sovTx(v)
 	base := offset
@@ -1017,25 +1716,796 @@ func (m *MsgCreatePeriodicVestingAccount) Size() (n int) {
 			n += 1 + l + sovTx(uint64(l))
 		}
 	}
-	return n
-}
+	if m.Merge {
+		n += 2
+	}
+	return n
+}
+
+func (m *MsgCreatePeriodicVestingAccountResponse) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	return n
+}
+
+func (m *MsgCreateClawbackVestingAccount) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.FromAddress)
+	if l > 0 {
+		n += 1 + l + sovTx(uint64(l))
+	}
+	l = len(m.ToAddress)
+	if l > 0 {
+		n += 1 + l + sovTx(uint64(l))
+	}
+	if m.StartTime != 0 {
+		n += 1 + sovTx(uint64(m.StartTime))
+	}
+	if len(m.LockupPeriods) > 0 {
+		for _, e := range m.LockupPeriods {
+			l = e.Size()
+			n += 1 + l + sovTx(uint64(l))
+		}
+	}
+	if len(m.VestingPeriods) > 0 {
+		for _, e := range m.VestingPeriods {
+			l = e.Size()
+			n += 1 + l + sovTx(uint64(l))
+		}
+	}
+	if m.Merge {
+		n += 2
+	}
+	return n
+}
+
+func (m *MsgCreateClawbackVestingAccountResponse) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	return n
+}
+
+func (m *MsgClawback) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.FunderAddress)
+	if l > 0 {
+		n += 1 + l + sovTx(uint64(l))
+	}
+	l = len(m.Address)
+	if l > 0 {
+		n += 1 + l + sovTx(uint64(l))
+	}
+	l = len(m.DestAddress)
+	if l > 0 {
+		n += 1 + l + sovTx(uint64(l))
+	}
+	return n
+}
+
+func (m *MsgClawbackResponse) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	return n
+}
+
+func (m *MsgReturnGrants) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Address)
+	if l > 0 {
+		n += 1 + l + sovTx(uint64(l))
+	}
+	return n
+}
+
+func (m *MsgReturnGrantsResponse) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	return n
+}
+
+func sovTx(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozTx(x uint64) (n int) {
+	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowTx
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: MsgCreateVestingAccount: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: MsgCreateVestingAccount: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FromAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ToAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Amount = append(m.Amount, types.Coin{})
+			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
+			}
+			m.EndTime = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.EndTime |= int64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Delayed", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Delayed = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipTx(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthTx
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *MsgCreateVestingAccountResponse) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowTx
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: MsgCreateVestingAccountResponse: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: MsgCreateVestingAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipTx(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthTx
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *MsgCreatePermanentLockedAccount) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowTx
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: MsgCreatePermanentLockedAccount: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: MsgCreatePermanentLockedAccount: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FromAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ToAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Amount = append(m.Amount, types.Coin{})
+			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipTx(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthTx
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *MsgCreatePermanentLockedAccountResponse) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowTx
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: MsgCreatePermanentLockedAccountResponse: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: MsgCreatePermanentLockedAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipTx(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthTx
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *MsgCreatePeriodicVestingAccount) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowTx
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccount: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccount: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FromAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ToAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
+			}
+			m.StartTime = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.StartTime |= int64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field VestingPeriods", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.VestingPeriods = append(m.VestingPeriods, Period{})
+			if err := m.VestingPeriods[len(m.VestingPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Merge = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipTx(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthTx
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
 
-func (m *MsgCreatePeriodicVestingAccountResponse) Size() (n int) {
-	if m == nil {
-		return 0
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
 	}
-	var l int
-	_ = l
-	return n
+	return nil
 }
+func (m *MsgCreatePeriodicVestingAccountResponse) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowTx
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccountResponse: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipTx(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthTx
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
 
-func sovTx(x uint64) (n int) {
-	return (math_bits.Len64(x|1) + 6) / 7
-}
-func sozTx(x uint64) (n int) {
-	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
 }
-func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
+func (m *MsgCreateClawbackVestingAccount) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -1058,10 +2528,10 @@ func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: MsgCreateVestingAccount: wiretype end group for non-group")
+			return fmt.Errorf("proto: MsgCreateClawbackVestingAccount: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MsgCreateVestingAccount: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: MsgCreateClawbackVestingAccount: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
@@ -1129,8 +2599,27 @@ func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
 			m.ToAddress = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
+			}
+			m.StartTime = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTx
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.StartTime |= int64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field LockupPeriods", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -1157,16 +2646,16 @@ func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Amount = append(m.Amount, types.Coin{})
-			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.LockupPeriods = append(m.LockupPeriods, Period{})
+			if err := m.LockupPeriods[len(m.LockupPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field VestingPeriods", wireType)
 			}
-			m.EndTime = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowTx
@@ -1176,14 +2665,29 @@ func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.EndTime |= int64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 5:
+			if msglen < 0 {
+				return ErrInvalidLengthTx
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthTx
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.VestingPeriods = append(m.VestingPeriods, Period{})
+			if err := m.VestingPeriods[len(m.VestingPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Delayed", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
 			}
 			var v int
 			for shift := uint(0); ; shift += 7 {
@@ -1200,7 +2704,7 @@ func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
 					break
 				}
 			}
-			m.Delayed = bool(v != 0)
+			m.Merge = bool(v != 0)
 		default:
 			iNdEx = preIndex
 			skippy, err := skipTx(dAtA[iNdEx:])
@@ -1222,7 +2726,7 @@ func (m *MsgCreateVestingAccount) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *MsgCreateVestingAccountResponse) Unmarshal(dAtA []byte) error {
+func (m *MsgCreateClawbackVestingAccountResponse) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -1245,10 +2749,10 @@ func (m *MsgCreateVestingAccountResponse) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: MsgCreateVestingAccountResponse: wiretype end group for non-group")
+			return fmt.Errorf("proto: MsgCreateClawbackVestingAccountResponse: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MsgCreateVestingAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: MsgCreateClawbackVestingAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		default:
@@ -1272,7 +2776,7 @@ func (m *MsgCreateVestingAccountResponse) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *MsgCreatePermanentLockedAccount) Unmarshal(dAtA []byte) error {
+func (m *MsgClawback) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -1295,15 +2799,15 @@ func (m *MsgCreatePermanentLockedAccount) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: MsgCreatePermanentLockedAccount: wiretype end group for non-group")
+			return fmt.Errorf("proto: MsgClawback: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MsgCreatePermanentLockedAccount: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: MsgClawback: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field FunderAddress", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -1331,11 +2835,11 @@ func (m *MsgCreatePermanentLockedAccount) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.FromAddress = string(dAtA[iNdEx:postIndex])
+			m.FunderAddress = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -1363,13 +2867,13 @@ func (m *MsgCreatePermanentLockedAccount) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ToAddress = string(dAtA[iNdEx:postIndex])
+			m.Address = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field DestAddress", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowTx
@@ -1379,25 +2883,23 @@ func (m *MsgCreatePermanentLockedAccount) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthTx
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthTx
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Amount = append(m.Amount, types.Coin{})
-			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.DestAddress = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -1420,7 +2922,7 @@ func (m *MsgCreatePermanentLockedAccount) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *MsgCreatePermanentLockedAccountResponse) Unmarshal(dAtA []byte) error {
+func (m *MsgClawbackResponse) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -1443,10 +2945,10 @@ func (m *MsgCreatePermanentLockedAccountResponse) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: MsgCreatePermanentLockedAccountResponse: wiretype end group for non-group")
+			return fmt.Errorf("proto: MsgClawbackResponse: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MsgCreatePermanentLockedAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: MsgClawbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		default:
@@ -1470,7 +2972,7 @@ func (m *MsgCreatePermanentLockedAccountResponse) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *MsgCreatePeriodicVestingAccount) Unmarshal(dAtA []byte) error {
+func (m *MsgReturnGrants) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -1493,47 +2995,15 @@ func (m *MsgCreatePeriodicVestingAccount) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccount: wiretype end group for non-group")
+			return fmt.Errorf("proto: MsgReturnGrants: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccount: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: MsgReturnGrants: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowTx
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthTx
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthTx
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.FromAddress = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -1561,60 +3031,7 @@ func (m *MsgCreatePeriodicVestingAccount) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ToAddress = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
-			}
-			m.StartTime = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowTx
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.StartTime |= int64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field VestingPeriods", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowTx
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthTx
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthTx
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.VestingPeriods = append(m.VestingPeriods, Period{})
-			if err := m.VestingPeriods[len(m.VestingPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Address = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -1637,7 +3054,7 @@ func (m *MsgCreatePeriodicVestingAccount) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *MsgCreatePeriodicVestingAccountResponse) Unmarshal(dAtA []byte) error {
+func (m *MsgReturnGrantsResponse) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -1660,10 +3077,10 @@ func (m *MsgCreatePeriodicVestingAccountResponse) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccountResponse: wiretype end group for non-group")
+			return fmt.Errorf("proto: MsgReturnGrantsResponse: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: MsgCreatePeriodicVestingAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: MsgReturnGrantsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		default:
diff --git a/x/auth/vesting/types/vesting.pb.go b/x/auth/vesting/types/vesting.pb.go
index 9c05fa2dff..948acf6de3 100644
--- a/x/auth/vesting/types/vesting.pb.go
+++ b/x/auth/vesting/types/vesting.pb.go
@@ -149,6 +149,9 @@ func (m *DelayedVestingAccount) XXX_DiscardUnknown() {
 var xxx_messageInfo_DelayedVestingAccount proto.InternalMessageInfo
 
 // Period defines a length of time and amount of coins that will vest.
+// A sequence of periods defines a sequence of vesting events, with the
+// first period relative to an externally-provided start time,
+// and subsequent periods relatie to their predecessor.
 type Period struct {
 	// Period duration in seconds.
 	Length int64                                    `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty"`
@@ -282,6 +285,53 @@ func (m *PermanentLockedAccount) XXX_DiscardUnknown() {
 
 var xxx_messageInfo_PermanentLockedAccount proto.InternalMessageInfo
 
+// ClawbackVestingAccount implements the VestingAccount interface. It provides
+// an account that can hold contributions subject to "lockup" (like a
+// PeriodicVestingAccount), or vesting which is subject to clawback
+// of unvested tokens, or a combination (tokens vest, but are still locked).
+type ClawbackVestingAccount struct {
+	*BaseVestingAccount `protobuf:"bytes,1,opt,name=base_vesting_account,json=baseVestingAccount,proto3,embedded=base_vesting_account" json:"base_vesting_account,omitempty"`
+	// funder_address specifies the account which can perform clawback.
+	FunderAddress string `protobuf:"bytes,2,opt,name=funder_address,json=funderAddress,proto3" json:"funder_address,omitempty" yaml:"funder_address"`
+	StartTime     int64  `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty" yaml:"start_time"`
+	// unlocking schedule relative to the BaseVestingAccount start_time.
+	LockupPeriods []Period `protobuf:"bytes,4,rep,name=lockup_periods,json=lockupPeriods,proto3" json:"lockup_periods" yaml:"lockup_periods"`
+	// vesting (i.e. immunity from clawback) schedule relative to the BaseVestingAccount start_time.
+	VestingPeriods []Period `protobuf:"bytes,5,rep,name=vesting_periods,json=vestingPeriods,proto3" json:"vesting_periods" yaml:"vesting_periods"`
+}
+
+func (m *ClawbackVestingAccount) Reset()      { *m = ClawbackVestingAccount{} }
+func (*ClawbackVestingAccount) ProtoMessage() {}
+func (*ClawbackVestingAccount) Descriptor() ([]byte, []int) {
+	return fileDescriptor_89e80273ca606d6e, []int{6}
+}
+func (m *ClawbackVestingAccount) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *ClawbackVestingAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_ClawbackVestingAccount.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *ClawbackVestingAccount) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_ClawbackVestingAccount.Merge(m, src)
+}
+func (m *ClawbackVestingAccount) XXX_Size() int {
+	return m.Size()
+}
+func (m *ClawbackVestingAccount) XXX_DiscardUnknown() {
+	xxx_messageInfo_ClawbackVestingAccount.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_ClawbackVestingAccount proto.InternalMessageInfo
+
 func init() {
 	proto.RegisterType((*BaseVestingAccount)(nil), "cosmos.vesting.v1beta1.BaseVestingAccount")
 	proto.RegisterType((*ContinuousVestingAccount)(nil), "cosmos.vesting.v1beta1.ContinuousVestingAccount")
@@ -289,6 +339,7 @@ func init() {
 	proto.RegisterType((*Period)(nil), "cosmos.vesting.v1beta1.Period")
 	proto.RegisterType((*PeriodicVestingAccount)(nil), "cosmos.vesting.v1beta1.PeriodicVestingAccount")
 	proto.RegisterType((*PermanentLockedAccount)(nil), "cosmos.vesting.v1beta1.PermanentLockedAccount")
+	proto.RegisterType((*ClawbackVestingAccount)(nil), "cosmos.vesting.v1beta1.ClawbackVestingAccount")
 }
 
 func init() {
@@ -296,41 +347,48 @@ func init() {
 }
 
 var fileDescriptor_89e80273ca606d6e = []byte{
-	// 537 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x54, 0x3f, 0x6f, 0xd3, 0x40,
-	0x14, 0xf7, 0x35, 0x21, 0x94, 0x2b, 0xb4, 0xe5, 0x54, 0xa2, 0xb4, 0x12, 0x4e, 0x54, 0x31, 0x44,
-	0x48, 0x38, 0xa4, 0x6c, 0xdd, 0x70, 0x11, 0x12, 0x02, 0x24, 0x64, 0x21, 0x06, 0x96, 0xe8, 0x6c,
-	0x3f, 0x9c, 0x53, 0xe3, 0xbb, 0xc8, 0x77, 0x8e, 0xda, 0x0f, 0x00, 0x42, 0x62, 0x61, 0x64, 0xec,
-	0x86, 0xc4, 0x27, 0xe9, 0x98, 0x91, 0xa9, 0xa0, 0x64, 0x63, 0xe6, 0x03, 0x20, 0xdf, 0x9d, 0xdd,
-	0x2a, 0x05, 0xa6, 0xf2, 0x67, 0xb2, 0xdf, 0x9f, 0xfb, 0xfd, 0xf1, 0x7b, 0x3e, 0x7c, 0x2b, 0x12,
-	0x32, 0x15, 0xb2, 0x37, 0x01, 0xa9, 0x18, 0x4f, 0x7a, 0x93, 0x7e, 0x08, 0x8a, 0xf6, 0xcb, 0xd8,
-	0x1b, 0x67, 0x42, 0x09, 0xd2, 0x34, 0x5d, 0x5e, 0x99, 0xb5, 0x5d, 0x5b, 0x1b, 0x89, 0x48, 0x84,
-	0x6e, 0xe9, 0x15, 0x6f, 0xa6, 0x7b, 0xcb, 0xb5, 0x98, 0x21, 0x95, 0x50, 0x01, 0x46, 0x82, 0xf1,
-	0x85, 0x3a, 0xcd, 0xd5, 0xb0, 0xaa, 0x17, 0x81, 0xa9, 0x6f, 0x7f, 0xab, 0x61, 0xe2, 0x53, 0x09,
-	0x2f, 0x0c, 0xdb, 0xfd, 0x28, 0x12, 0x39, 0x57, 0xe4, 0x11, 0xbe, 0x5a, 0x20, 0x0e, 0xa8, 0x89,
-	0x5b, 0xa8, 0x83, 0xba, 0x2b, 0x3b, 0x1d, 0xcf, 0x6a, 0xd3, 0x00, 0x16, 0xcd, 0x2b, 0x8e, 0xdb,
-	0x73, 0x7e, 0x7d, 0x7a, 0xd2, 0x46, 0xc1, 0x4a, 0x78, 0x9a, 0x22, 0x13, 0xbc, 0x2e, 0x32, 0x96,
-	0x30, 0x4e, 0x47, 0x03, 0xeb, 0xa9, 0xb5, 0xd4, 0xa9, 0x75, 0x57, 0x76, 0x36, 0x4b, 0xb8, 0xa2,
-	0xbd, 0x82, 0xdb, 0x13, 0x8c, 0xfb, 0x77, 0x8f, 0x4f, 0xda, 0xce, 0xa7, 0x2f, 0xed, 0x6e, 0xc2,
-	0xd4, 0x30, 0x0f, 0xbd, 0x48, 0xa4, 0x3d, 0xeb, 0xc4, 0x3c, 0xee, 0xc8, 0x78, 0xbf, 0xa7, 0x0e,
-	0xc7, 0x20, 0xf5, 0x01, 0x19, 0xac, 0x95, 0x24, 0xd6, 0x09, 0xc9, 0xf0, 0x6a, 0x0c, 0x23, 0x48,
-	0xa8, 0x82, 0x78, 0xf0, 0x2a, 0x03, 0x68, 0xd5, 0x2e, 0x9e, 0xf5, 0x5a, 0x45, 0xf1, 0x30, 0x03,
-	0x20, 0x07, 0xf8, 0xfa, 0x29, 0x67, 0x69, 0xb6, 0x7e, 0xf1, 0xb4, 0xeb, 0x15, 0x4b, 0xe9, 0x76,
-	0x13, 0x2f, 0x03, 0x8f, 0x07, 0x8a, 0xa5, 0xd0, 0xba, 0xd4, 0x41, 0xdd, 0x5a, 0x70, 0x19, 0x78,
-	0xfc, 0x9c, 0xa5, 0xb0, 0xbb, 0xfc, 0xf6, 0xa8, 0xed, 0x7c, 0x38, 0x6a, 0x3b, 0xdb, 0x1f, 0x11,
-	0x6e, 0xed, 0x09, 0xae, 0x18, 0xcf, 0x45, 0x2e, 0x17, 0x46, 0x1e, 0xe2, 0x0d, 0x3d, 0x72, 0x2b,
-	0x7b, 0x61, 0xf4, 0xb7, 0xbd, 0x9f, 0xaf, 0xa5, 0x77, 0x7e, 0x79, 0xec, 0x12, 0x90, 0xf0, 0xfc,
-	0x5a, 0xdd, 0xc4, 0x58, 0x2a, 0x9a, 0x29, 0xa3, 0x73, 0x49, 0xeb, 0xbc, 0xa2, 0x33, 0x0b, 0x4a,
-	0x5f, 0x23, 0x7c, 0xe3, 0x01, 0x8c, 0xe8, 0x61, 0xe5, 0xf0, 0x2f, 0xca, 0x3c, 0xa3, 0xe3, 0x1d,
-	0xc2, 0x8d, 0x67, 0x90, 0x31, 0x11, 0x93, 0x26, 0x6e, 0x8c, 0x80, 0x27, 0x6a, 0xa8, 0xa9, 0x6a,
-	0x81, 0x8d, 0x48, 0x84, 0x1b, 0x34, 0xd5, 0x12, 0xfe, 0xc0, 0x56, 0x5b, 0xe8, 0xdd, 0xba, 0x56,
-	0xf3, 0x1d, 0xe1, 0xa6, 0x51, 0xc3, 0xa2, 0xff, 0x6e, 0x7a, 0xe4, 0x29, 0x5e, 0x2b, 0xd9, 0xc7,
-	0x5a, 0xa4, 0xb4, 0x7f, 0x9c, 0xfb, 0x2b, 0x76, 0xe3, 0xc5, 0xaf, 0x17, 0x9f, 0x25, 0x58, 0xb5,
-	0x55, 0x93, 0x94, 0x67, 0x86, 0xf0, 0xc6, 0xd8, 0x4e, 0x29, 0x07, 0xae, 0x9e, 0x88, 0x68, 0x1f,
-	0xe2, 0x7f, 0xb2, 0x0d, 0xfe, 0xe3, 0xe3, 0x99, 0x8b, 0xa6, 0x33, 0x17, 0x7d, 0x9d, 0xb9, 0xe8,
-	0xfd, 0xdc, 0x75, 0xa6, 0x73, 0xd7, 0xf9, 0x3c, 0x77, 0x9d, 0x97, 0xfd, 0xdf, 0x4e, 0xf4, 0xc0,
-	0x5e, 0xbf, 0xf6, 0xde, 0xd7, 0x03, 0x0e, 0x1b, 0xfa, 0x02, 0xbe, 0xf7, 0x23, 0x00, 0x00, 0xff,
-	0xff, 0xd0, 0x5c, 0x2d, 0x10, 0x16, 0x06, 0x00, 0x00,
+	// 656 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0x4f, 0x4f, 0xd4, 0x40,
+	0x1c, 0xdd, 0xd2, 0x65, 0x85, 0x41, 0x16, 0x98, 0xc0, 0x66, 0x21, 0xa1, 0xdd, 0x34, 0x1e, 0x36,
+	0x26, 0x76, 0x05, 0x3d, 0x71, 0x92, 0x62, 0x4c, 0x8c, 0x9a, 0x98, 0xc6, 0x78, 0xf0, 0xb2, 0x99,
+	0xb6, 0x43, 0x69, 0xb6, 0x9d, 0xd9, 0x74, 0xa6, 0x08, 0x1f, 0x40, 0x63, 0xe2, 0xc5, 0xa3, 0x47,
+	0x6e, 0x26, 0x7e, 0x12, 0x2e, 0x26, 0x1c, 0x3d, 0xad, 0x06, 0x6e, 0x1e, 0x89, 0x1f, 0xc0, 0x74,
+	0x66, 0xda, 0x85, 0x5d, 0x31, 0x1c, 0x50, 0x3c, 0xed, 0xfe, 0xfe, 0xcc, 0x7b, 0xef, 0xd7, 0xf7,
+	0x9b, 0x0c, 0xb8, 0xe5, 0x53, 0x96, 0x50, 0xd6, 0xd9, 0xc5, 0x8c, 0x47, 0x24, 0xec, 0xec, 0xae,
+	0x79, 0x98, 0xa3, 0xb5, 0x22, 0xb6, 0xfb, 0x29, 0xe5, 0x14, 0x36, 0x64, 0x97, 0x5d, 0x64, 0x55,
+	0xd7, 0xca, 0x62, 0x48, 0x43, 0x2a, 0x5a, 0x3a, 0xf9, 0x3f, 0xd9, 0xbd, 0x62, 0x28, 0x4c, 0x0f,
+	0x31, 0x5c, 0x02, 0xfa, 0x34, 0x22, 0x23, 0x75, 0x94, 0xf1, 0x9d, 0xb2, 0x9e, 0x07, 0xb2, 0x6e,
+	0xfd, 0xd0, 0x01, 0x74, 0x10, 0xc3, 0x2f, 0x25, 0xdb, 0xa6, 0xef, 0xd3, 0x8c, 0x70, 0xf8, 0x18,
+	0xdc, 0xcc, 0x11, 0xbb, 0x48, 0xc6, 0x4d, 0xad, 0xa5, 0xb5, 0x67, 0xd6, 0x5b, 0xb6, 0xd2, 0x26,
+	0x00, 0x14, 0x9a, 0x9d, 0x1f, 0x57, 0xe7, 0x9c, 0xea, 0xd1, 0xc0, 0xd4, 0xdc, 0x19, 0x6f, 0x98,
+	0x82, 0xbb, 0x60, 0x9e, 0xa6, 0x51, 0x18, 0x11, 0x14, 0x77, 0xd5, 0x4c, 0xcd, 0x89, 0x96, 0xde,
+	0x9e, 0x59, 0x5f, 0x2e, 0xe0, 0xf2, 0xf6, 0x12, 0x6e, 0x8b, 0x46, 0xc4, 0xb9, 0x7b, 0x38, 0x30,
+	0x2b, 0x9f, 0xbf, 0x99, 0xed, 0x30, 0xe2, 0x3b, 0x99, 0x67, 0xfb, 0x34, 0xe9, 0xa8, 0x49, 0xe4,
+	0xcf, 0x1d, 0x16, 0xf4, 0x3a, 0x7c, 0xbf, 0x8f, 0x99, 0x38, 0xc0, 0xdc, 0xb9, 0x82, 0x44, 0x4d,
+	0x02, 0x53, 0x50, 0x0f, 0x70, 0x8c, 0x43, 0xc4, 0x71, 0xd0, 0xdd, 0x4e, 0x31, 0x6e, 0xea, 0x57,
+	0xcf, 0x3a, 0x5b, 0x52, 0x3c, 0x4a, 0x31, 0x86, 0x7b, 0x60, 0x61, 0xc8, 0x59, 0x0c, 0x5b, 0xbd,
+	0x7a, 0xda, 0xf9, 0x92, 0xa5, 0x98, 0x76, 0x19, 0x4c, 0x61, 0x12, 0x74, 0x79, 0x94, 0xe0, 0xe6,
+	0x64, 0x4b, 0x6b, 0xeb, 0xee, 0x0d, 0x4c, 0x82, 0x17, 0x51, 0x82, 0x37, 0xa6, 0xde, 0x1d, 0x98,
+	0x95, 0x8f, 0x07, 0x66, 0xc5, 0xfa, 0xa4, 0x81, 0xe6, 0x16, 0x25, 0x3c, 0x22, 0x19, 0xcd, 0xd8,
+	0x88, 0xe5, 0x1e, 0x58, 0x14, 0x96, 0x2b, 0xd9, 0x23, 0xd6, 0xdf, 0xb6, 0x7f, 0xbf, 0x96, 0xf6,
+	0xf8, 0xf2, 0xa8, 0x25, 0x80, 0xde, 0xf8, 0x5a, 0xad, 0x02, 0xc0, 0x38, 0x4a, 0xb9, 0xd4, 0x39,
+	0x21, 0x74, 0x4e, 0x8b, 0xcc, 0x88, 0xd2, 0x37, 0x1a, 0x58, 0x7a, 0x88, 0x63, 0xb4, 0x5f, 0x4e,
+	0xf8, 0x0f, 0x65, 0x9e, 0xd1, 0xf1, 0x5e, 0x03, 0xb5, 0xe7, 0x38, 0x8d, 0x68, 0x00, 0x1b, 0xa0,
+	0x16, 0x63, 0x12, 0xf2, 0x1d, 0x41, 0xa5, 0xbb, 0x2a, 0x82, 0x3e, 0xa8, 0xa1, 0x44, 0x48, 0xf8,
+	0x0b, 0x5b, 0xad, 0xa0, 0x37, 0xaa, 0x42, 0xcd, 0x4f, 0x0d, 0x34, 0xa4, 0x9a, 0xc8, 0xff, 0xef,
+	0xdc, 0x83, 0xcf, 0xc0, 0x5c, 0xc1, 0xde, 0x17, 0x22, 0x99, 0xba, 0x71, 0xc6, 0x45, 0xec, 0x72,
+	0x16, 0xa7, 0x9a, 0x7f, 0x16, 0xb7, 0xae, 0xaa, 0x32, 0xc9, 0xce, 0x98, 0xf0, 0x56, 0x8e, 0x9d,
+	0x20, 0x82, 0x09, 0x7f, 0x4a, 0xfd, 0x1e, 0x0e, 0xae, 0x67, 0x1b, 0xbe, 0xe8, 0xa0, 0xb1, 0x15,
+	0xa3, 0xd7, 0x1e, 0xf2, 0x7b, 0xd7, 0xf0, 0xfd, 0x1f, 0x80, 0xfa, 0x76, 0x46, 0x02, 0x9c, 0x76,
+	0x51, 0x10, 0xa4, 0x98, 0x31, 0xe1, 0xc1, 0xb4, 0xb3, 0x7c, 0x3a, 0x30, 0x97, 0xf6, 0x51, 0x12,
+	0x6f, 0x58, 0xe7, 0xeb, 0x96, 0x3b, 0x2b, 0x13, 0x9b, 0x32, 0x86, 0xf7, 0xcf, 0x39, 0xa8, 0xe7,
+	0x0e, 0x3a, 0x4b, 0xa7, 0x03, 0x73, 0x41, 0x9e, 0x1e, 0xd6, 0xac, 0xb3, 0xc6, 0x06, 0xa0, 0x1e,
+	0x53, 0xbf, 0x97, 0xf5, 0x4b, 0x5f, 0xab, 0x97, 0xf2, 0x75, 0x35, 0xf7, 0x75, 0xa8, 0xed, 0x3c,
+	0x86, 0xe5, 0xce, 0xca, 0x84, 0xf2, 0x1b, 0x86, 0xe3, 0xeb, 0x33, 0x79, 0x29, 0x1a, 0x43, 0xd1,
+	0x34, 0x24, 0xcd, 0x08, 0x88, 0x75, 0xf1, 0x62, 0x39, 0x4f, 0x0e, 0x8f, 0x0d, 0xed, 0xe8, 0xd8,
+	0xd0, 0xbe, 0x1f, 0x1b, 0xda, 0x87, 0x13, 0xa3, 0x72, 0x74, 0x62, 0x54, 0xbe, 0x9e, 0x18, 0x95,
+	0x57, 0x6b, 0x7f, 0xbc, 0xa1, 0x7b, 0xea, 0x39, 0x55, 0xef, 0xb8, 0xb8, 0xb0, 0x5e, 0x4d, 0x3c,
+	0xa8, 0xf7, 0x7e, 0x05, 0x00, 0x00, 0xff, 0xff, 0x11, 0xd3, 0xae, 0x7c, 0xe6, 0x07, 0x00, 0x00,
 }
 
 func (m *BaseVestingAccount) Marshal() (dAtA []byte, err error) {
@@ -621,6 +679,81 @@ func (m *PermanentLockedAccount) MarshalToSizedBuffer(dAtA []byte) (int, error)
 	return len(dAtA) - i, nil
 }
 
+func (m *ClawbackVestingAccount) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ClawbackVestingAccount) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ClawbackVestingAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.VestingPeriods) > 0 {
+		for iNdEx := len(m.VestingPeriods) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.VestingPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVesting(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x2a
+		}
+	}
+	if len(m.LockupPeriods) > 0 {
+		for iNdEx := len(m.LockupPeriods) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.LockupPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVesting(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x22
+		}
+	}
+	if m.StartTime != 0 {
+		i = encodeVarintVesting(dAtA, i, uint64(m.StartTime))
+		i--
+		dAtA[i] = 0x18
+	}
+	if len(m.FunderAddress) > 0 {
+		i -= len(m.FunderAddress)
+		copy(dAtA[i:], m.FunderAddress)
+		i = encodeVarintVesting(dAtA, i, uint64(len(m.FunderAddress)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.BaseVestingAccount != nil {
+		{
+			size, err := m.BaseVestingAccount.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVesting(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
 func encodeVarintVesting(dAtA []byte, offset int, v uint64) int {
 	offset -= sovVesting(v)
 	base := offset
@@ -748,6 +881,38 @@ func (m *PermanentLockedAccount) Size() (n int) {
 	return n
 }
 
+func (m *ClawbackVestingAccount) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.BaseVestingAccount != nil {
+		l = m.BaseVestingAccount.Size()
+		n += 1 + l + sovVesting(uint64(l))
+	}
+	l = len(m.FunderAddress)
+	if l > 0 {
+		n += 1 + l + sovVesting(uint64(l))
+	}
+	if m.StartTime != 0 {
+		n += 1 + sovVesting(uint64(m.StartTime))
+	}
+	if len(m.LockupPeriods) > 0 {
+		for _, e := range m.LockupPeriods {
+			l = e.Size()
+			n += 1 + l + sovVesting(uint64(l))
+		}
+	}
+	if len(m.VestingPeriods) > 0 {
+		for _, e := range m.VestingPeriods {
+			l = e.Size()
+			n += 1 + l + sovVesting(uint64(l))
+		}
+	}
+	return n
+}
+
 func sovVesting(x uint64) (n int) {
 	return (math_bits.Len64(x|1) + 6) / 7
 }
@@ -1480,6 +1645,211 @@ func (m *PermanentLockedAccount) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *ClawbackVestingAccount) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVesting
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ClawbackVestingAccount: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ClawbackVestingAccount: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field BaseVestingAccount", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVesting
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVesting
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVesting
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.BaseVestingAccount == nil {
+				m.BaseVestingAccount = &BaseVestingAccount{}
+			}
+			if err := m.BaseVestingAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FunderAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVesting
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVesting
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVesting
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FunderAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
+			}
+			m.StartTime = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVesting
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.StartTime |= int64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LockupPeriods", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVesting
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVesting
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVesting
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.LockupPeriods = append(m.LockupPeriods, Period{})
+			if err := m.LockupPeriods[len(m.LockupPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field VestingPeriods", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVesting
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVesting
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVesting
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.VestingPeriods = append(m.VestingPeriods, Period{})
+			if err := m.VestingPeriods[len(m.VestingPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVesting(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVesting
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func skipVesting(dAtA []byte) (n int, err error) {
 	l := len(dAtA)
 	iNdEx := 0
diff --git a/x/auth/vesting/types/vesting_account.go b/x/auth/vesting/types/vesting_account.go
index 6db8d7b299..5c7922e268 100644
--- a/x/auth/vesting/types/vesting_account.go
+++ b/x/auth/vesting/types/vesting_account.go
@@ -2,12 +2,14 @@ package types
 
 import (
 	"errors"
+	"math"
 	"time"
 
 	"sigs.k8s.io/yaml"
 
 	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
 	sdk "github.com/cosmos/cosmos-sdk/types"
+	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
 	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
 	vestexported "github.com/cosmos/cosmos-sdk/x/auth/vesting/exported"
 )
@@ -255,8 +257,8 @@ func (cva ContinuousVestingAccount) GetVestingCoins(blockTime time.Time) sdk.Coi
 
 // LockedCoins returns the set of coins that are not spendable (i.e. locked),
 // defined as the vesting coins that are not delegated.
-func (cva ContinuousVestingAccount) LockedCoins(blockTime time.Time) sdk.Coins {
-	return cva.BaseVestingAccount.LockedCoinsFromVesting(cva.GetVestingCoins(blockTime))
+func (cva ContinuousVestingAccount) LockedCoins(ctx sdk.Context) sdk.Coins {
+	return cva.BaseVestingAccount.LockedCoinsFromVesting(cva.GetVestingCoins(ctx.BlockTime()))
 }
 
 // TrackDelegation tracks a desired delegation amount by setting the appropriate
@@ -345,34 +347,11 @@ func NewPeriodicVestingAccount(baseAcc *authtypes.BaseAccount, originalVesting s
 // GetVestedCoins returns the total number of vested coins. If no coins are vested,
 // nil is returned.
 func (pva PeriodicVestingAccount) GetVestedCoins(blockTime time.Time) sdk.Coins {
-	var vestedCoins sdk.Coins
-
-	// We must handle the case where the start time for a vesting account has
-	// been set into the future or when the start of the chain is not exactly
-	// known.
-	if blockTime.Unix() <= pva.StartTime {
-		return vestedCoins
-	} else if blockTime.Unix() >= pva.EndTime {
-		return pva.OriginalVesting
-	}
-
-	// track the start time of the next period
-	currentPeriodStartTime := pva.StartTime
-
-	// for each period, if the period is over, add those coins as vested and check the next period.
-	for _, period := range pva.VestingPeriods {
-		x := blockTime.Unix() - currentPeriodStartTime
-		if x < period.Length {
-			break
-		}
-
-		vestedCoins = vestedCoins.Add(period.Amount...)
-
-		// update the start time of the next period
-		currentPeriodStartTime += period.Length
+	coins := ReadSchedule(pva.StartTime, pva.EndTime, pva.VestingPeriods, pva.OriginalVesting, blockTime.Unix())
+	if coins.IsZero() {
+		return nil
 	}
-
-	return vestedCoins
+	return coins
 }
 
 // GetVestingCoins returns the total number of vesting coins. If no coins are
@@ -383,8 +362,8 @@ func (pva PeriodicVestingAccount) GetVestingCoins(blockTime time.Time) sdk.Coins
 
 // LockedCoins returns the set of coins that are not spendable (i.e. locked),
 // defined as the vesting coins that are not delegated.
-func (pva PeriodicVestingAccount) LockedCoins(blockTime time.Time) sdk.Coins {
-	return pva.BaseVestingAccount.LockedCoinsFromVesting(pva.GetVestingCoins(blockTime))
+func (pva PeriodicVestingAccount) LockedCoins(ctx sdk.Context) sdk.Coins {
+	return pva.BaseVestingAccount.LockedCoinsFromVesting(pva.GetVestingCoins(ctx.BlockTime()))
 }
 
 // TrackDelegation tracks a desired delegation amount by setting the appropriate
@@ -407,8 +386,8 @@ func (pva PeriodicVestingAccount) GetVestingPeriods() Periods {
 
 // Validate checks for errors on the account fields
 func (pva PeriodicVestingAccount) Validate() error {
-	if pva.GetStartTime() >= pva.GetEndTime() {
-		return errors.New("vesting start-time cannot be before end-time")
+	if pva.GetStartTime() > pva.GetEndTime() {
+		return errors.New("vesting end-time cannot precede start-time")
 	}
 	endTime := pva.StartTime
 	originalVesting := sdk.NewCoins()
@@ -453,6 +432,78 @@ func (pva PeriodicVestingAccount) MarshalYAML() (interface{}, error) {
 	return marshalYaml(out)
 }
 
+// periodicGrantAction is a vestexported.AddGrantAction for PeriodicVestingAccount.
+type periodicGrantAction struct {
+	sk                  StakingKeeper
+	grantStartTime      int64
+	grantVestingPeriods []Period
+	grantCoins          sdk.Coins
+}
+
+// NewPeriodicGrantAction returns an AddGrantAction for a PeriodicVestingAccount
+func NewPeriodicGrantAction(
+	sk StakingKeeper,
+	grantStartTime int64,
+	grantVestingPeriods []Period,
+	grantCoins sdk.Coins,
+) vestexported.AddGrantAction {
+	return periodicGrantAction{
+		sk:                  sk,
+		grantStartTime:      grantStartTime,
+		grantVestingPeriods: grantVestingPeriods,
+		grantCoins:          grantCoins,
+	}
+}
+
+// AddToAccount implements the vestexported.AddGrantAction interface.
+// It checks that rawAccount is a PeriodicVestingAccount, then adds the described grant to it.
+func (pga periodicGrantAction) AddToAccount(ctx sdk.Context, rawAccount vestexported.VestingAccount) error {
+	pva, ok := rawAccount.(*PeriodicVestingAccount)
+	if !ok {
+		return sdkerrors.Wrapf(sdkerrors.ErrNotSupported,
+			"account %s must be a PeriodicVestingAccount, got %T",
+			rawAccount.GetAddress(), rawAccount)
+	}
+	pva.addGrant(ctx, pga.sk, pga.grantStartTime, pga.grantVestingPeriods, pga.grantCoins)
+	return nil
+}
+
+// AddGrant implements the vestexported.GrantAccount interface.
+func (pva *PeriodicVestingAccount) AddGrant(ctx sdk.Context, action vestexported.AddGrantAction) error {
+	return action.AddToAccount(ctx, pva)
+}
+
+// addGrant merges a new periodic vesting grant into an existing PeriodicVestingAccount.
+func (pva *PeriodicVestingAccount) addGrant(ctx sdk.Context, sk StakingKeeper, grantStartTime int64, grantVestingPeriods []Period, grantCoins sdk.Coins) {
+	// how much is really delegated?
+	bondedAmt := sk.GetDelegatorBonded(ctx, pva.GetAddress())
+	unbondingAmt := sk.GetDelegatorUnbonding(ctx, pva.GetAddress())
+	delegatedAmt := bondedAmt.Add(unbondingAmt)
+	delegated := sdk.NewCoins(sdk.NewCoin(sk.BondDenom(ctx), delegatedAmt))
+
+	// discover what has been slashed
+	oldDelegated := pva.DelegatedVesting.Add(pva.DelegatedFree...)
+	slashed := oldDelegated.Sub(coinsMin(oldDelegated, delegated)...)
+
+	// rebase the DV+DF by capping slashed at the current unvested amount
+	unvested := pva.GetVestingCoins(ctx.BlockTime())
+	newSlashed := coinsMin(unvested, slashed)
+	newTotalDelegated := delegated.Add(newSlashed...)
+
+	// modify vesting schedule for the new grant
+	newStart, newEnd, newPeriods := DisjunctPeriods(pva.StartTime, grantStartTime,
+		pva.GetVestingPeriods(), grantVestingPeriods)
+	pva.StartTime = newStart
+	pva.EndTime = newEnd
+	pva.VestingPeriods = newPeriods
+	pva.OriginalVesting = pva.OriginalVesting.Add(grantCoins...)
+
+	// cap DV at the current unvested amount, DF rounds out to newTotalDelegated
+	unvested2 := pva.GetVestingCoins(ctx.BlockTime())
+	pva.DelegatedVesting = coinsMin(newTotalDelegated, unvested2)
+	pva.DelegatedFree = newTotalDelegated.Sub(pva.DelegatedVesting...)
+}
+
 // Delayed Vesting Account
 
 var (
@@ -496,8 +547,8 @@ func (dva DelayedVestingAccount) GetVestingCoins(blockTime time.Time) sdk.Coins
 
 // LockedCoins returns the set of coins that are not spendable (i.e. locked),
 // defined as the vesting coins that are not delegated.
-func (dva DelayedVestingAccount) LockedCoins(blockTime time.Time) sdk.Coins {
-	return dva.BaseVestingAccount.LockedCoinsFromVesting(dva.GetVestingCoins(blockTime))
+func (dva DelayedVestingAccount) LockedCoins(ctx sdk.Context) sdk.Coins {
+	return dva.BaseVestingAccount.LockedCoinsFromVesting(dva.GetVestingCoins(ctx.BlockTime()))
 }
 
 // TrackDelegation tracks a desired delegation amount by setting the appropriate
@@ -555,7 +606,7 @@ func (plva PermanentLockedAccount) GetVestingCoins(_ time.Time) sdk.Coins {
 
 // LockedCoins returns the set of coins that are not spendable (i.e. locked),
 // defined as the vesting coins that are not delegated.
-func (plva PermanentLockedAccount) LockedCoins(_ time.Time) sdk.Coins {
+func (plva PermanentLockedAccount) LockedCoins(_ sdk.Context) sdk.Coins {
 	return plva.BaseVestingAccount.LockedCoinsFromVesting(plva.OriginalVesting)
 }
 
@@ -609,3 +660,738 @@ func marshalYaml(i interface{}) (interface{}, error) {
 	}
 	return string(bz), nil
 }
+
+// Clawback Vesting Account
+
+var (
+	_ vestexported.VestingAccount          = (*ClawbackVestingAccount)(nil)
+	_ authtypes.GenesisAccount             = (*ClawbackVestingAccount)(nil)
+	_ vestexported.ClawbackVestingAccountI = (*ClawbackVestingAccount)(nil)
+)
+
+// NewClawbackVestingAccount returns a new ClawbackVestingAccount
+func NewClawbackVestingAccount(baseAcc *authtypes.BaseAccount, funder sdk.AccAddress, originalVesting sdk.Coins, startTime int64, lockupPeriods, vestingPeriods Periods) *ClawbackVestingAccount {
+	// copy and align schedules to avoid mutating inputs
+	lp := make(Periods, len(lockupPeriods))
+	copy(lp, lockupPeriods)
+	vp := make(Periods, len(vestingPeriods))
+	copy(vp, vestingPeriods)
+	_, endTime := AlignSchedules(startTime, startTime, lp, vp)
+	baseVestingAcc := &BaseVestingAccount{
+		BaseAccount:     baseAcc,
+		OriginalVesting: originalVesting,
+		EndTime:         endTime,
+	}
+
+	return &ClawbackVestingAccount{
+		BaseVestingAccount: baseVestingAcc,
+		FunderAddress:      funder.String(),
+		StartTime:          startTime,
+		LockupPeriods:      lp,
+		VestingPeriods:     vp,
+	}
+}
+
+// GetVestedCoins returns the total number of vested coins. If no coins are vested,
+// nil is returned.
+func (va ClawbackVestingAccount) GetVestedCoins(blockTime time.Time) sdk.Coins {
+	// It's likely that one or the other schedule will be nearly trivial,
+	// so there should be little overhead in recomputing the conjunction each time.
+	coins := coinsMin(va.GetUnlockedOnly(blockTime), va.GetVestedOnly(blockTime))
+	if coins.IsZero() {
+		return nil
+	}
+	return coins
+}
+
+// GetVestingCoins returns the total number of vesting coins. If no coins are
+// vesting, nil is returned.
+func (va ClawbackVestingAccount) GetVestingCoins(blockTime time.Time) sdk.Coins {
+	return va.OriginalVesting.Sub(va.GetVestedCoins(blockTime)...)
+}
+
+// LockedCoins returns the set of coins that are not spendable (i.e. locked),
+// defined as the vesting coins that are not delegated.
+func (va ClawbackVestingAccount) LockedCoins(ctx sdk.Context) sdk.Coins {
+	return va.BaseVestingAccount.LockedCoinsFromVesting(va.GetVestingCoins(ctx.BlockTime()))
+}
+
+// TrackDelegation tracks a desired delegation amount by setting the appropriate
+// values for the amount of delegated vesting, delegated free, and reducing the
+// overall amount of base coins.
+func (va *ClawbackVestingAccount) TrackDelegation(blockTime time.Time, balance, amount sdk.Coins) {
+	va.BaseVestingAccount.TrackDelegation(balance, va.GetVestingCoins(blockTime), amount)
+}
+
+// GetStartTime returns the time when vesting starts for a periodic vesting
+// account.
+func (va ClawbackVestingAccount) GetStartTime() int64 {
+	return va.StartTime
+}
+
+// GetVestingPeriods returns vesting periods associated with periodic vesting account.
+func (va ClawbackVestingAccount) GetVestingPeriods() Periods {
+	return va.VestingPeriods
+}
+
+// coinEq returns whether two Coins are equal.
+// The IsEqual() method can panic.
+func coinEq(a, b sdk.Coins) bool {
+	return a.IsAllLTE(b) && b.IsAllLTE(a)
+}
+
+// Validate checks for errors on the account fields
+func (va ClawbackVestingAccount) Validate() error {
+	if va.GetStartTime() > va.GetEndTime() {
+		return errors.New("vesting end-time cannot precede start-time")
+	}
+
+	lockupEnd := va.StartTime
+	lockupCoins := sdk.NewCoins()
+	for _, p := range va.LockupPeriods {
+		lockupEnd += p.Length
+		lockupCoins = lockupCoins.Add(p.Amount...)
+	}
+	if lockupEnd > va.EndTime {
+		return errors.New("lockup schedule extends beyond account end time")
+	}
+	if !coinEq(lockupCoins, va.OriginalVesting) {
+		return errors.New("original vesting coins does not match the sum of all coins in lockup periods")
+	}
+
+	vestingEnd := va.StartTime
+	vestingCoins := sdk.NewCoins()
+	for _, p := range va.VestingPeriods {
+		vestingEnd += p.Length
+		vestingCoins = vestingCoins.Add(p.Amount...)
+	}
+	if vestingEnd > va.EndTime {
+		return errors.New("vesting schedule exteds beyond account end time")
+	}
+	if !coinEq(vestingCoins, va.OriginalVesting) {
+		return errors.New("original vesting coins does not match the sum of all coins in vesting periods")
+	}
+
+	return va.BaseVestingAccount.Validate()
+}
+
+func (va ClawbackVestingAccount) String() string {
+	out, _ := va.MarshalYAML()
+	return out.(string)
+}
+
+// MarshalYAML returns the YAML representation of a ClawbackVestingAccount.
+func (va ClawbackVestingAccount) MarshalYAML() (interface{}, error) {
+	accAddr, err := sdk.AccAddressFromBech32(va.Address)
+	if err != nil {
+		return nil, err
+	}
+
+	out := vestingAccountYAML{
+		Address:          accAddr,
+		AccountNumber:    va.AccountNumber,
+		PubKey:           getPKString(va),
+		Sequence:         va.Sequence,
+		OriginalVesting:  va.OriginalVesting,
+		DelegatedFree:    va.DelegatedFree,
+		DelegatedVesting: va.DelegatedVesting,
+		EndTime:          va.EndTime,
+		StartTime:        va.StartTime,
+		VestingPeriods:   va.VestingPeriods,
+	}
+	return marshalYaml(out)
+}
+
+// clawbackGrantAction is a vestexported.AddGrantAction for ClawbackVestingAccount.
+type clawbackGrantAction struct {
+	funderAddress       string
+	sk                  StakingKeeper
+	grantStartTime      int64
+	grantLockupPeriods  []Period
+	grantVestingPeriods []Period
+	grantCoins          sdk.Coins
+}
+
+// NewClawbackGrantAction returns an AddGrantAction for a ClawbackVestingAccount.
+func NewClawbackGrantAction(
+	funderAddress string,
+	sk StakingKeeper,
+	grantStartTime int64,
+	grantLockupPeriods, grantVestingPeriods []Period,
+	grantCoins sdk.Coins,
+) vestexported.AddGrantAction {
+	return clawbackGrantAction{
+		funderAddress:       funderAddress,
+		sk:                  sk,
+		grantStartTime:      grantStartTime,
+		grantLockupPeriods:  grantLockupPeriods,
+		grantVestingPeriods: grantVestingPeriods,
+		grantCoins:          grantCoins,
+	}
+}
+
+// AddToAccount implements the vestexported.AddGrantAction interface.
+// It checks that rawAccount is a ClawbackVestingAccount with the same funder
+// and adds the described Grant to it.
+func (cga clawbackGrantAction) AddToAccount(ctx sdk.Context, rawAccount vestexported.VestingAccount) error {
+	cva, ok := rawAccount.(*ClawbackVestingAccount)
+	if !ok {
+		return sdkerrors.Wrapf(sdkerrors.ErrNotSupported,
+			"account %s must be a ClawbackVestingAccount, got %T",
+			rawAccount.GetAddress(), rawAccount)
+	}
+	if cga.funderAddress != cva.FunderAddress {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s can only accept grants from account %s",
+			rawAccount.GetAddress(), cva.FunderAddress)
+	}
+	cva.addGrant(ctx, cga.sk, cga.grantStartTime, cga.grantLockupPeriods, cga.grantVestingPeriods, cga.grantCoins)
+	return nil
+}
+
+func (va *ClawbackVestingAccount) AddGrant(ctx sdk.Context, action vestexported.AddGrantAction) error {
+	return action.AddToAccount(ctx, va)
+}
+
+// addGrant merges a new clawback vesting grant into an existing ClawbackVestingAccount.
+func (va *ClawbackVestingAccount) addGrant(ctx sdk.Context, sk StakingKeeper, grantStartTime int64, grantLockupPeriods, grantVestingPeriods []Period, grantCoins sdk.Coins) {
+	// how much is really delegated?
+	bondedAmt := sk.GetDelegatorBonded(ctx, va.GetAddress())
+	unbondingAmt := sk.GetDelegatorUnbonding(ctx, va.GetAddress())
+	delegatedAmt := bondedAmt.Add(unbondingAmt)
+	delegated := sdk.NewCoins(sdk.NewCoin(sk.BondDenom(ctx), delegatedAmt))
+
+	// discover what has been slashed
+	oldDelegated := va.DelegatedVesting.Add(va.DelegatedFree...)
+	slashed := oldDelegated.Sub(coinsMin(oldDelegated, delegated)...)
+
+	// rebase the DV + DF by capping slashed at the current unvested amount
+	unvested := va.OriginalVesting.Sub(va.GetVestedOnly(ctx.BlockTime())...)
+	newSlashed := coinsMin(slashed, unvested)
+	newDelegated := delegated.Add(newSlashed...)
+
+	// modify schedules for the new grant
+	newLockupStart, newLockupEnd, newLockupPeriods := DisjunctPeriods(va.StartTime, grantStartTime, va.LockupPeriods, grantLockupPeriods)
+	newVestingStart, newVestingEnd, newVestingPeriods := DisjunctPeriods(va.StartTime, grantStartTime,
+		va.GetVestingPeriods(), grantVestingPeriods)
+	if newLockupStart != newVestingStart {
+		panic("bad start time calculation")
+	}
+	va.StartTime = newLockupStart
+	va.EndTime = max64(newLockupEnd, newVestingEnd)
+	va.LockupPeriods = newLockupPeriods
+	va.VestingPeriods = newVestingPeriods
+	va.OriginalVesting = va.OriginalVesting.Add(grantCoins...)
+
+	// cap DV at the current unvested amount, DF rounds out to newDelegated
+	unvested2 := va.GetVestingCoins(ctx.BlockTime())
+	va.DelegatedVesting = coinsMin(newDelegated, unvested2)
+	va.DelegatedFree = newDelegated.Sub(va.DelegatedVesting...)
+}
+
+// GetFunder implements the vestexported.ClawbackVestingAccountI interface.
+func (va ClawbackVestingAccount) GetFunder() sdk.AccAddress {
+	addr, err := sdk.AccAddressFromBech32(va.FunderAddress)
+	if err != nil {
+		panic(err)
+	}
+	return addr
+}
+
+// GetUnlockedOnly implements the vestexported.ClawbackVestingAccountI interface.
+// It returns the unlocking schedule at blockTIme.
+// Like GetVestedCoins, but only for the lockup component.
+func (va ClawbackVestingAccount) GetUnlockedOnly(blockTime time.Time) sdk.Coins {
+	return ReadSchedule(va.StartTime, va.EndTime, va.LockupPeriods, va.OriginalVesting, blockTime.Unix())
+}
+
+// GetVestedOnly implements the vestexported.ClawbackVestingAccountI interface.
+// It returns the vesting schedule and blockTime.
+// Like GetVestedCoins, but only for the vesting (in the clawback sense) component.
+func (va ClawbackVestingAccount) GetVestedOnly(blockTime time.Time) sdk.Coins {
+	return ReadSchedule(va.StartTime, va.EndTime, va.VestingPeriods, va.OriginalVesting, blockTime.Unix())
+}
+
+// computeClawback removes all future vesting events from the account,
+// returns the total sum of these events. When removing the future vesting events,
+// the lockup schedule will also have to be capped to keep the total sums the same.
+// (But future unlocking events might be preserved if they unlock currently vested coins.)
+// If the amount returned is zero, then the returned account should be unchanged.
+// Does not adjust DelegatedVesting
+func (va *ClawbackVestingAccount) computeClawback(clawbackTime int64) sdk.Coins {
+	// Compute the truncated vesting schedule and amounts.
+	// Work with the schedule as the primary data and recompute derived fields, e.g. OriginalVesting.
+	vestTime := va.StartTime
+	totalVested := sdk.NewCoins()
+	totalUnvested := sdk.NewCoins()
+	unvestedIdx := 0
+	for i, period := range va.VestingPeriods {
+		vestTime += period.Length
+		// tie in time goes to clawback
+		if vestTime < clawbackTime {
+			totalVested = totalVested.Add(period.Amount...)
+			unvestedIdx = i + 1
+		} else {
+			totalUnvested = totalUnvested.Add(period.Amount...)
+		}
+	}
+	lastVestTime := vestTime
+	newVestingPeriods := va.VestingPeriods[:unvestedIdx]
+
+	// To cap the unlocking schedule to the new total vested, conjunct with a limiting schedule
+	capPeriods := []Period{
+		{
+			Length: 0,
+			Amount: totalVested,
+		},
+	}
+	_, lastLockTime, newLockupPeriods := ConjunctPeriods(va.StartTime, va.StartTime, va.LockupPeriods, capPeriods)
+
+	// Now construct the new account state
+	va.OriginalVesting = totalVested
+	va.EndTime = max64(lastVestTime, lastLockTime)
+	va.LockupPeriods = newLockupPeriods
+	va.VestingPeriods = newVestingPeriods
+	// DelegatedVesting and DelegatedFree will be adjusted elsewhere
+
+	return totalUnvested
+}
+
+// updateDelegation returns an account with its delegation bookkeeping modified for clawback,
+// given the current disposition of the account's bank and staking state. Also returns
+// the modified amount to claw back.
+//
+// Computation steps:
+// - first, compute the total amount in bonded and unbonding states, used for BaseAccount bookkeeping;
+// - based on the old bookkeeping, determine the amount lost to slashing since origin;
+// - clip the amount to claw back to be at most the full funds in the account;
+// - first claw back the unbonded funds, then go after what's delegated;
+// - to the remaining delegated amount, add what's slashed;
+// - the "encumbered" (locked up and/or vesting) amount of this goes in DV;
+// - the remainder of the new delegated amount goes in DF.
+func (va *ClawbackVestingAccount) updateDelegation(encumbered, toClawBack, bonded, unbonding, unbonded sdk.Coins) sdk.Coins {
+	delegated := bonded.Add(unbonding...)
+	oldDelegated := va.DelegatedVesting.Add(va.DelegatedFree...)
+	slashed := oldDelegated.Sub(coinsMin(delegated, oldDelegated)...)
+	total := delegated.Add(unbonded...)
+	toClawBack = coinsMin(toClawBack, total) // might have been slashed
+	newDelegated := coinsMin(delegated, total.Sub(toClawBack...)).Add(slashed...)
+	va.DelegatedVesting = coinsMin(encumbered, newDelegated)
+	va.DelegatedFree = newDelegated.Sub(va.DelegatedVesting...)
+	return toClawBack
+}
+
+// clawbackAction implements vestexported.ClawbackAction for ClawbackVestingAccount.
+type clawbackAction struct {
+	requestor sdk.AccAddress
+	dest      sdk.AccAddress
+	ak        AccountKeeper
+	bk        BankKeeper
+	sk        StakingKeeper
+}
+
+// NewClawbackAction returns an vestexported.ClawbackAction for ClawbackVestingAccount.
+func NewClawbackAction(requestor, dest sdk.AccAddress, ak AccountKeeper, bk BankKeeper, sk StakingKeeper) vestexported.ClawbackAction {
+	return clawbackAction{
+		requestor: requestor,
+		dest:      dest,
+		ak:        ak,
+		bk:        bk,
+		sk:        sk,
+	}
+}
+
+// TakeFromAccount implements the vestexported.ClawbackAction interface.
+// It returns an error if the account is not at ClawbackVestingAccount
+// or if the funder does not match.
+func (ca clawbackAction) TakeFromAccount(ctx sdk.Context, rawAccount vestexported.VestingAccount) error {
+	cva, ok := rawAccount.(*ClawbackVestingAccount)
+	if !ok {
+		return sdkerrors.Wrapf(sdkerrors.ErrNotSupported, "clawback expects *ClawbackVestingAccount, got %T", rawAccount)
+	}
+	if ca.requestor.String() != cva.FunderAddress {
+		return sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "clawback can only be requested by original funder %s", cva.FunderAddress)
+	}
+	return cva.clawback(ctx, ca.dest, ca.ak, ca.bk, ca.sk)
+}
+
+// Clawback implements vestexported.ClawbackVestingAccountI.
+func (va *ClawbackVestingAccount) Clawback(ctx sdk.Context, action vestexported.ClawbackAction) error {
+	return action.TakeFromAccount(ctx, va)
+}
+
+// Clawback transfers unvested tokens in a ClawbackVestingAccount to dest.
+// Future vesting events are removed. Unstaked tokens are simply sent.
+// Unbonding and staked tokens are transferred with their staking state
+// intact.  Account state is updated to reflect the removals.
+func (va *ClawbackVestingAccount) clawback(ctx sdk.Context, dest sdk.AccAddress, ak AccountKeeper, bk BankKeeper, sk StakingKeeper) error {
+	// Compute the clawback based on the account state only, and update account
+	toClawBack := va.computeClawback(ctx.BlockTime().Unix())
+	if toClawBack.IsZero() {
+		return nil
+	}
+	addr := va.GetAddress()
+	bondDenom := sk.BondDenom(ctx)
+
+	// Compute the clawback based on bank balance and delegation, and update account
+	encumbered := va.GetVestingCoins(ctx.BlockTime())
+	bondedAmt := sk.GetDelegatorBonded(ctx, addr)
+	unbondingAmt := sk.GetDelegatorUnbonding(ctx, addr)
+	bonded := sdk.NewCoins(sdk.NewCoin(bondDenom, bondedAmt))
+	unbonding := sdk.NewCoins(sdk.NewCoin(bondDenom, unbondingAmt))
+	unbonded := bk.GetAllBalances(ctx, addr)
+	toClawBack = va.updateDelegation(encumbered, toClawBack, bonded, unbonding, unbonded)
+
+	// Write now now so that the bank module sees unvested tokens are unlocked.
+	// Note that all store writes are aborted if there is a panic, so there is
+	// no danger in writing incomplete results.
+	ak.SetAccount(ctx, va)
+
+	// Now that future vesting events (and associated lockup) are removed,
+	// the balance of the account is unlocked and can be freely transferred.
+	spendable := bk.SpendableCoins(ctx, addr)
+	toXfer := coinsMin(toClawBack, spendable)
+	err := bk.SendCoins(ctx, addr, dest, toXfer)
+	if err != nil {
+		return err // shouldn't happen, given spendable check
+	}
+	toClawBack = toClawBack.Sub(toXfer...)
+
+	// We need to traverse the staking data structures to update the
+	// vesting account bookkeeping, and to recover more funds if necessary.
+	// Staking is the only way unvested tokens should be missing from the bank balance.
+
+	// If we need more, transfer UnbondingDelegations.
+	want := toClawBack.AmountOf(bondDenom)
+	unbondings := sk.GetUnbondingDelegations(ctx, addr, math.MaxUint16)
+	for _, unbonding := range unbondings {
+		valAddr, err := sdk.ValAddressFromBech32(unbonding.ValidatorAddress)
+		if err != nil {
+			panic(err)
+		}
+		transferred := sk.TransferUnbonding(ctx, addr, dest, valAddr, want)
+		want = want.Sub(transferred)
+		if !want.IsPositive() {
+			break
+		}
+	}
+
+	// If we need more, transfer Delegations.
+	if want.IsPositive() {
+		delegations := sk.GetDelegatorDelegations(ctx, addr, math.MaxUint16)
+		for _, delegation := range delegations {
+			validatorAddr, err := sdk.ValAddressFromBech32(delegation.ValidatorAddress)
+			if err != nil {
+				panic(err) // shouldn't happen
+			}
+			validator, found := sk.GetValidator(ctx, validatorAddr)
+			if !found {
+				// validator has been removed
+				continue
+			}
+			wantShares, err := validator.SharesFromTokensTruncated(want)
+			if err != nil {
+				// validator has no tokens
+				continue
+			}
+			transferredShares := sk.TransferDelegation(ctx, addr, dest, delegation.GetValidatorAddr(), wantShares)
+			// to be conservative in what we're clawing back, round transferred shares up
+			transferred := validator.TokensFromSharesRoundUp(transferredShares).RoundInt()
+			want = want.Sub(transferred)
+			if !want.IsPositive() {
+				// Could be slightly negative, due to rounding?
+				// Don't think so, due to the precautions above.
+				break
+			}
+		}
+	}
+
+	// If we've transferred everything and still haven't transferred the desired clawback amount,
+	// then the account must have most some unvested tokens from slashing.
+	return nil
+}
+
+// forceTransfer sends up to amt  assets to the dest account.
+// It will first send spendable coins, then unbonding tokens,
+// and finally staked tokens. The tokens must not be otherwise
+// encumbered - e.g. they cannot be locked or unvested.
+// Any changes to the account encumbrance must be written to the store
+// before calling this method so that bank.SendCoins() will work.
+// Any unbonding or staked tokens transferred are deducted from
+// the DelegatedFree/Vesting fields.
+// TODO: refactor to de-dup with clawback()
+func (va *BaseVestingAccount) forceTransfer(ctx sdk.Context, amt sdk.Coins, dest sdk.AccAddress, ak AccountKeeper, bk BankKeeper, sk StakingKeeper) {
+	if amt.IsZero() {
+		return
+	}
+	addr := va.GetAddress()
+
+	// Now that future vesting events (and associated lockup) are removed,
+	// the balance of the account is unlocked and can be freely transferred.
+	spendable := bk.SpendableCoins(ctx, addr)
+	toXfer := coinsMin(amt, spendable)
+	err := bk.SendCoins(ctx, addr, dest, toXfer)
+	if err != nil {
+		panic(err) // shouldn't happen, given spendable check
+	}
+	amt = amt.Sub(toXfer...)
+
+	// We need to traverse the staking data structures to update the
+	// vesting account bookkeeping, and to recover more funds if necessary.
+	// Staking is the only way unvested tokens should be missing from the bank balance.
+
+	// If we need more, transfer UnbondingDelegations.
+	bondDenom := sk.BondDenom(ctx)
+	want := amt.AmountOf(bondDenom)
+	if !want.IsPositive() {
+		return
+	}
+	got := sdk.NewInt(0)
+	unbondings := sk.GetUnbondingDelegations(ctx, addr, math.MaxUint16)
+	for _, unbonding := range unbondings {
+		valAddr, err := sdk.ValAddressFromBech32(unbonding.ValidatorAddress)
+		if err != nil {
+			panic(err)
+		}
+		transferred := sk.TransferUnbonding(ctx, addr, dest, valAddr, want)
+		want = want.Sub(transferred)
+		got = got.Add(transferred)
+		if !want.IsPositive() {
+			break
+		}
+	}
+
+	// If we need more, transfer Delegations.
+	if want.IsPositive() {
+		delegations := sk.GetDelegatorDelegations(ctx, addr, math.MaxUint16)
+		for _, delegation := range delegations {
+			validatorAddr, err := sdk.ValAddressFromBech32(delegation.ValidatorAddress)
+			if err != nil {
+				panic(err) // shouldn't happen
+			}
+			validator, found := sk.GetValidator(ctx, validatorAddr)
+			if !found {
+				// validator has been removed
+				continue
+			}
+			wantShares, err := validator.SharesFromTokensTruncated(want)
+			if err != nil {
+				// validator has no tokens
+				continue
+			}
+			// the following might transfer fewer shares than wanted
+			transferredShares := sk.TransferDelegation(ctx, addr, dest, delegation.GetValidatorAddr(), wantShares)
+			// to be conservative in what we're clawing back, round transferred shares up
+			transferred := validator.TokensFromSharesRoundUp(transferredShares).RoundInt()
+			want = want.Sub(transferred)
+			got = got.Add(transferred)
+			if !want.IsPositive() {
+				// Could be slightly negative, due to rounding?
+				// Don't think so, due to the precautions above.
+				break
+			}
+		}
+	}
+
+	// Reduce DelegatedFree/Vesting by actual unbonding/staked amount transferred.
+	// The distinction between DF and DV is not significant in practice - only the
+	// sum is meaningful. Furthermore, DF/DV is not updated on each vesting event,
+	// so the distinction isn't required to be exact. Nevertheless, we'll prefer to
+	// overlap the "delegated" and "vesting" encumbrances as much as possible, so
+	// we'll decrement DF first.
+
+	gotCoins := sdk.NewCoins(sdk.NewCoin(bondDenom, got))
+	decrFree := coinsMin(gotCoins, va.DelegatedFree)
+	va.DelegatedFree = va.DelegatedFree.Sub(decrFree...)
+	gotCoins = gotCoins.Sub(decrFree...)
+	decrVesting := coinsMin(gotCoins, va.DelegatedVesting)
+	va.DelegatedVesting = va.DelegatedVesting.Sub(decrVesting...)
+	gotCoins = gotCoins.Sub(decrVesting...)
+	ak.SetAccount(ctx, va)
+	// gotCoins should be zero at this point, unless DF+DV was not accurate
+
+	// If we've transferred everything and still haven't transferred the desired clawback amount,
+	// then the account must have lost some unvested tokens from slashing.
+}
+
+// returnGrantAction implements vestexported.ReturnGrantAction.
+type returnGrantAction struct {
+	ak AccountKeeper
+	bk BankKeeper
+	sk StakingKeeper
+}
+
+// NewReturnGrantAction returns a new vestexported.ReturnGrantAction.
+func NewReturnGrantAction(ak AccountKeeper, bk BankKeeper, sk StakingKeeper) vestexported.ReturnGrantAction {
+	return returnGrantAction{
+		ak: ak,
+		bk: bk,
+		sk: sk,
+	}
+}
+
+// TakeGrants implements the vestexported.ReturnGrantAction interface.
+// It returns an error if the account does not support returning grants.
+func (rga returnGrantAction) TakeGrants(ctx sdk.Context, rawAccount vestexported.VestingAccount) error {
+	cva, ok := rawAccount.(*ClawbackVestingAccount)
+	if !ok {
+		return sdkerrors.Wrapf(sdkerrors.ErrNotSupported, "return-grants not supported on account type %T", rawAccount)
+	}
+	cva.returnGrants(ctx, rga.ak, rga.bk, rga.sk)
+	return nil
+}
+
+// ReturnGrants implements vestexported.ReturnGrantsAccount.
+func (va *ClawbackVestingAccount) ReturnGrants(ctx sdk.Context, action vestexported.ReturnGrantAction) error {
+	return action.TakeGrants(ctx, va)
+}
+
+// returnGrants transfers the original vesting tokens back to the funder, zeroing out all grant-related accounting.
+// It prefers to transfer unbonded tokens from the account, but will transfer unbonding or staked tokens
+// if necessary.
+func (va *ClawbackVestingAccount) returnGrants(ctx sdk.Context, ak AccountKeeper, bk BankKeeper, sk StakingKeeper) {
+	// TODO withdraw rewards - requires integration with DistributionKeeper
+	toReturn := va.OriginalVesting
+	if toReturn.IsZero() {
+		return
+	}
+	va.OriginalVesting = sdk.NewCoins()
+	va.LockupPeriods = []Period{}
+	va.VestingPeriods = []Period{}
+	va.DelegatedFree = va.DelegatedFree.Add(va.DelegatedVesting...)
+	va.DelegatedVesting = sdk.NewCoins()
+	va.EndTime = va.StartTime
+
+	// Store the modified account so that all funds are vested and unlocked,
+	// which will allow funds to be transferred via normal means.
+	ak.SetAccount(ctx, va)
+
+	va.forceTransfer(ctx, toReturn, va.GetFunder(), ak, bk, sk)
+}
+
+// distributeReward adds the reward to the future vesting schedule in proportion to the future vesting
+// staking tokens.
+func (va ClawbackVestingAccount) distributeReward(ctx sdk.Context, ak AccountKeeper, bondDenom string, reward sdk.Coins) {
+	now := ctx.BlockTime().Unix()
+	t := va.StartTime
+	firstUnvestedPeriod := 0
+	unvestedTokens := sdk.ZeroInt()
+	for i, period := range va.VestingPeriods {
+		t += period.Length
+		if t <= now {
+			firstUnvestedPeriod = i + 1
+			continue
+		}
+		unvestedTokens = unvestedTokens.Add(period.Amount.AmountOf(bondDenom))
+	}
+
+	runningTotReward := sdk.NewCoins()
+	runningTotStaking := sdk.ZeroInt()
+	for i := firstUnvestedPeriod; i < len(va.VestingPeriods); i++ {
+		period := va.VestingPeriods[i]
+		runningTotStaking = runningTotStaking.Add(period.Amount.AmountOf(bondDenom))
+		runningTotRatio := sdk.NewDecFromInt(runningTotStaking).Quo(sdk.NewDecFromInt(unvestedTokens))
+		targetCoins := scaleCoins(reward, runningTotRatio)
+		thisReward := targetCoins.Sub(runningTotReward...)
+		runningTotReward = targetCoins
+		period.Amount = period.Amount.Add(thisReward...)
+		va.VestingPeriods[i] = period
+	}
+
+	va.OriginalVesting = va.OriginalVesting.Add(reward...)
+	ak.SetAccount(ctx, &va)
+}
+
+// scaleCoins scales the given coins, rounding down.
+func scaleCoins(coins sdk.Coins, scale sdk.Dec) sdk.Coins {
+	scaledCoins := sdk.NewCoins()
+	for _, coin := range coins {
+		amt := sdk.NewDecFromInt(coin.Amount).Mul(scale).TruncateInt() // round down
+		scaledCoins = scaledCoins.Add(sdk.NewCoin(coin.Denom, amt))
+	}
+	return scaledCoins
+}
+
+// intMin returns the minimum of its arguments.
+func intMin(a, b sdk.Int) sdk.Int {
+	if a.GT(b) {
+		return b
+	}
+	return a
+}
+
+// clawbackRewardAction implements vestexported.RewardAction for ClawbackVestingAccount.
+type clawbackRewardAction struct {
+	ak AccountKeeper
+	bk BankKeeper
+	sk StakingKeeper
+}
+
+// NewClawbackRewardAction returns an vestexported.RewardAction for a ClawbackVestingAccount.
+func NewClawbackRewardAction(ak AccountKeeper, bk BankKeeper, sk StakingKeeper) vestexported.RewardAction {
+	return clawbackRewardAction{
+		ak: ak,
+		bk: bk,
+		sk: sk,
+	}
+}
+
+// ProcessReward implements the vestexported.RewardAction interface.
+func (cra clawbackRewardAction) ProcessReward(ctx sdk.Context, reward sdk.Coins, rawAccount vestexported.VestingAccount) error {
+	cva, ok := rawAccount.(*ClawbackVestingAccount)
+	if !ok {
+		return sdkerrors.Wrapf(sdkerrors.ErrNotSupported, "expected *ClawbackVestingAccount, got %T", rawAccount)
+	}
+	cva.postReward(ctx, reward, cra.ak, cra.bk, cra.sk)
+	return nil
+}
+
+// PostReward implements the vestexported.ClawbackVestingAccountI interface.
+func (va *ClawbackVestingAccount) PostReward(ctx sdk.Context, reward sdk.Coins, action vestexported.RewardAction) error {
+	return action.ProcessReward(ctx, reward, va)
+}
+
+// postReward encumbers a previously-deposited reward according to the current vesting apportionment of staking.
+// Note that rewards might be unvested, but are unlocked.
+func (va ClawbackVestingAccount) postReward(ctx sdk.Context, reward sdk.Coins, ak AccountKeeper, bk BankKeeper, sk StakingKeeper) {
+	// Find the scheduled amount of vested and unvested staking tokens
+	bondDenom := sk.BondDenom(ctx)
+	vested := ReadSchedule(va.StartTime, va.EndTime, va.VestingPeriods, va.OriginalVesting, ctx.BlockTime().Unix()).AmountOf(bondDenom)
+	unvested := va.OriginalVesting.AmountOf(bondDenom).Sub(vested)
+
+	if unvested.IsZero() {
+		// no need to adjust the vesting schedule
+		return
+	}
+
+	if vested.IsZero() {
+		// all staked tokens must be unvested
+		va.distributeReward(ctx, ak, bondDenom, reward)
+		return
+	}
+
+	// Find current split of account balance on staking axis
+	bonded := sk.GetDelegatorBonded(ctx, va.GetAddress())
+	unbonding := sk.GetDelegatorUnbonding(ctx, va.GetAddress())
+	delegated := bonded.Add(unbonding)
+
+	// discover what has been slashed and remove from delegated amount
+	oldDelegated := va.DelegatedVesting.AmountOf(bondDenom).Add(va.DelegatedFree.AmountOf(bondDenom))
+	slashed := oldDelegated.Sub(intMin(oldDelegated, delegated))
+	delegated = delegated.Sub(intMin(delegated, slashed))
+
+	// Prefer delegated tokens to be unvested
+	unvested = intMin(unvested, delegated)
+	vested = delegated.Sub(unvested)
+
+	// Compute the unvested amount of reward and add to vesting schedule
+	if unvested.IsZero() {
+		return
+	}
+	if vested.IsZero() {
+		va.distributeReward(ctx, ak, bondDenom, reward)
+		return
+	}
+	unvestedRatio := sdk.NewDecFromInt(unvested).QuoTruncate(sdk.NewDecFromInt(bonded)) // round down
+	unvestedReward := scaleCoins(reward, unvestedRatio)
+	va.distributeReward(ctx, ak, bondDenom, unvestedReward)
+}
diff --git a/x/auth/vesting/types/vesting_account_internal_test.go b/x/auth/vesting/types/vesting_account_internal_test.go
new file mode 100644
index 0000000000..f93dbb2122
--- /dev/null
+++ b/x/auth/vesting/types/vesting_account_internal_test.go
@@ -0,0 +1,66 @@
+package types
+
+import (
+	"testing"
+	"time"
+
+	"github.com/cosmos/cosmos-sdk/testutil/testdata"
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
+	"github.com/stretchr/testify/require"
+
+	tmtime "github.com/tendermint/tendermint/types/time"
+)
+
+var (
+	stakeDenom = "stake"
+	feeDenom   = "fee"
+)
+
+func initBaseAccount() (*authtypes.BaseAccount, sdk.Coins) {
+	_, _, addr := testdata.KeyTestPubAddr()
+	origCoins := sdk.Coins{sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100)}
+	bacc := authtypes.NewBaseAccountWithAddress(addr)
+
+	return bacc, origCoins
+}
+
+func TestComputeClawback(t *testing.T) {
+	c := sdk.NewCoins
+	fee := func(x int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, x) }
+	stake := func(x int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, x) }
+	now := tmtime.Now()
+	lockupPeriods := Periods{
+		{Length: int64(12 * 3600), Amount: c(fee(1000), stake(100))}, // noon
+	}
+	vestingPeriods := Periods{
+		{Length: int64(8 * 3600), Amount: c(fee(200))},            // 8am
+		{Length: int64(1 * 3600), Amount: c(fee(200), stake(50))}, // 9am
+		{Length: int64(6 * 3600), Amount: c(fee(200), stake(50))}, // 3pm
+		{Length: int64(2 * 3600), Amount: c(fee(200))},            // 5pm
+		{Length: int64(1 * 3600), Amount: c(fee(200))},            // 6pm
+	}
+
+	bacc, origCoins := initBaseAccount()
+	va := NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+
+	amt := va.computeClawback(now.Unix())
+	require.Equal(t, c(fee(1000), stake(100)), amt)
+	require.Equal(t, c(), va.OriginalVesting)
+	require.Equal(t, 0, len(va.LockupPeriods))
+	require.Equal(t, 0, len(va.VestingPeriods))
+
+	va2 := NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	amt = va2.computeClawback(now.Add(11 * time.Hour).Unix())
+	require.Equal(t, c(fee(600), stake(50)), amt)
+	require.Equal(t, c(fee(400), stake(50)), va2.OriginalVesting)
+	require.Equal(t, []Period{{Length: int64(12 * 3600), Amount: c(fee(400), stake(50))}}, va2.LockupPeriods)
+	require.Equal(t, []Period{
+		{Length: int64(8 * 3600), Amount: c(fee(200))},            // 8am
+		{Length: int64(1 * 3600), Amount: c(fee(200), stake(50))}, // 9am
+	}, va2.VestingPeriods)
+
+	va3 := NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	amt = va3.computeClawback(now.Add(23 * time.Hour).Unix())
+	require.Equal(t, c(), amt)
+}
diff --git a/x/auth/vesting/types/vesting_account_test.go b/x/auth/vesting/types/vesting_account_test.go
index 56ae59b05b..95a8f38317 100644
--- a/x/auth/vesting/types/vesting_account_test.go
+++ b/x/auth/vesting/types/vesting_account_test.go
@@ -15,6 +15,10 @@ import (
 	sdk "github.com/cosmos/cosmos-sdk/types"
 	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
 	"github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
+	"github.com/cosmos/cosmos-sdk/x/bank/testutil"
+	"github.com/cosmos/cosmos-sdk/x/staking"
+	stakingkeeper "github.com/cosmos/cosmos-sdk/x/staking/keeper"
+	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
 )
 
 var (
@@ -36,6 +40,10 @@ func (s *VestingAccountTestSuite) SetupTest() {
 	s.ctx = s.app.BaseApp.NewContext(checkTx, tmproto.Header{Height: 1})
 }
 
+func contextAt(t time.Time) sdk.Context {
+	return sdk.Context{}.WithBlockTime(t)
+}
+
 func TestGetVestedCoinsContVestingAcc(t *testing.T) {
 	now := tmtime.Now()
 	endTime := now.Add(24 * time.Hour)
@@ -89,15 +97,15 @@ func TestSpendableCoinsContVestingAcc(t *testing.T) {
 
 	// require that all original coins are locked at the end of the vesting
 	// schedule
-	lockedCoins := cva.LockedCoins(now)
+	lockedCoins := cva.LockedCoins(contextAt(now))
 	require.Equal(t, origCoins, lockedCoins)
 
 	// require that there exist no locked coins in the beginning of the
-	lockedCoins = cva.LockedCoins(endTime)
+	lockedCoins = cva.LockedCoins(contextAt(endTime))
 	require.Equal(t, sdk.NewCoins(), lockedCoins)
 
 	// require that all vested coins (50%) are spendable
-	lockedCoins = cva.LockedCoins(now.Add(12 * time.Hour))
+	lockedCoins = cva.LockedCoins(contextAt(now.Add(12 * time.Hour)))
 	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}, lockedCoins)
 }
 
@@ -225,23 +233,23 @@ func TestSpendableCoinsDelVestingAcc(t *testing.T) {
 	// require that all coins are locked in the beginning of the vesting
 	// schedule
 	dva := types.NewDelayedVestingAccount(bacc, origCoins, endTime.Unix())
-	lockedCoins := dva.LockedCoins(now)
+	lockedCoins := dva.LockedCoins(contextAt(now))
 	require.True(t, lockedCoins.IsEqual(origCoins))
 
 	// require that all coins are spendable after the maturation of the vesting
 	// schedule
-	lockedCoins = dva.LockedCoins(endTime)
+	lockedCoins = dva.LockedCoins(contextAt(endTime))
 	require.Equal(t, sdk.NewCoins(), lockedCoins)
 
 	// require that all coins are still vesting after some time
-	lockedCoins = dva.LockedCoins(now.Add(12 * time.Hour))
+	lockedCoins = dva.LockedCoins(contextAt(now.Add(12 * time.Hour)))
 	require.True(t, lockedCoins.IsEqual(origCoins))
 
 	// delegate some locked coins
 	// require that locked is reduced
 	delegatedAmount := sdk.NewCoins(sdk.NewInt64Coin(stakeDenom, 50))
 	dva.TrackDelegation(now.Add(12*time.Hour), origCoins, delegatedAmount)
-	lockedCoins = dva.LockedCoins(now.Add(12 * time.Hour))
+	lockedCoins = dva.LockedCoins(contextAt(now.Add(12 * time.Hour)))
 	require.True(t, lockedCoins.IsEqual(origCoins.Sub(delegatedAmount...)))
 }
 
@@ -326,6 +334,203 @@ func TestTrackUndelegationDelVestingAcc(t *testing.T) {
 	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)}, dva.DelegatedVesting)
 }
 
+func TestCreatePeriodicVestingAccBricked(t *testing.T) {
+	c := sdk.NewCoins
+	fee := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, amt) }
+	stake := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, amt) }
+	now := tmtime.Now()
+
+	// set up simapp
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	bogusPeriods := types.Periods{
+		{Length: 1, Amount: c(fee(10000), stake(100))},
+		{Length: 1000, Amount: []sdk.Coin{{Denom: feeDenom, Amount: sdk.NewInt(-9000)}}},
+	}
+	bacc, origCoins := initBaseAccount()
+	pva := types.NewPeriodicVestingAccount(bacc, origCoins, now.Unix(), bogusPeriods)
+	addr := pva.GetAddress()
+	app.AccountKeeper.SetAccount(ctx, pva)
+
+	err := testutil.FundAccount(app.BankKeeper, ctx, addr, c(fee(6000), stake(100)))
+	require.NoError(t, err)
+	require.Equal(t, int64(100), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+
+	ctx = ctx.WithBlockTime(now.Add(160 * time.Second))
+	_, _, dest := testdata.KeyTestPubAddr()
+	require.Panics(t, func() { app.BankKeeper.SendCoins(ctx, addr, dest, c(fee(750))) })
+}
+
+func TestAddGrantPeriodicVestingAcc(t *testing.T) {
+	c := sdk.NewCoins
+	fee := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, amt) }
+	stake := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, amt) }
+	now := tmtime.Now()
+
+	// set up simapp
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	// create an account with an initial grant
+	periods := types.Periods{
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+	}
+	bacc, origCoins := initBaseAccount()
+	pva := types.NewPeriodicVestingAccount(bacc, origCoins, now.Unix(), periods)
+	addr := pva.GetAddress()
+
+	// simulate 60stake (unvested) lost to slashing
+	pva.DelegatedVesting = c(stake(60))
+
+	// At now+150, 75stake unvested but only 15stake locked, due to slashing
+	ctx = ctx.WithBlockTime(now.Add(150 * time.Second))
+	require.Equal(t, int64(75), pva.GetVestingCoins(ctx.BlockTime()).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(15), pva.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant while all slashing is covered by unvested tokens
+	grantAction := types.NewPeriodicGrantAction(app.StakingKeeper, ctx.BlockTime().Unix(), periods, origCoins)
+	err := pva.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+
+	// After new grant, 115stake locked at now+150 due to slashing,
+	// delegation bookkeeping unchanged
+	require.Equal(t, int64(115), pva.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(60), pva.DelegatedVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), pva.DelegatedFree.AmountOf(stakeDenom).Int64())
+
+	// At now+425, 50stake unvested, nothing locked due to slashing
+	ctx = ctx.WithBlockTime(now.Add(425 * time.Second))
+	require.Equal(t, int64(50), pva.GetVestingCoins(ctx.BlockTime()).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), pva.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant, while slashed amount is 50 unvested, 10 vested
+	grantAction = types.NewPeriodicGrantAction(app.StakingKeeper, ctx.BlockTime().Unix(), periods, origCoins)
+	err = pva.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+
+	// After new grant, slashed amount reduced to 50 vested, locked is 100
+	require.Equal(t, int64(100), pva.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(50), pva.DelegatedVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), pva.DelegatedFree.AmountOf(stakeDenom).Int64())
+
+	// At now+1000, nothing unvested, nothing locked
+	ctx = ctx.WithBlockTime(now.Add(1000 * time.Second))
+	require.Equal(t, int64(0), pva.GetVestingCoins(ctx.BlockTime()).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), pva.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant with residual slashed amount, but no unvested
+	grantAction = types.NewPeriodicGrantAction(app.StakingKeeper, ctx.BlockTime().Unix(), periods, origCoins)
+	err = pva.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+
+	// After new grant, all 100 locked, no residual delegation bookkeeping
+	require.Equal(t, int64(100), pva.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), pva.DelegatedVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), pva.DelegatedFree.AmountOf(stakeDenom).Int64())
+
+	app.AccountKeeper.SetAccount(ctx, pva)
+
+	// fund the vesting account with new grant (old has vested and transferred out)
+	err = testutil.FundAccount(app.BankKeeper, ctx, addr, origCoins)
+	require.NoError(t, err)
+	require.Equal(t, int64(100), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+
+	// we should not be able to transfer the latest grant out until it has vested
+	_, _, dest := testdata.KeyTestPubAddr()
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, c(stake(1)))
+	require.Error(t, err)
+	ctx = ctx.WithBlockTime(now.Add(1500 * time.Second))
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, origCoins)
+	require.NoError(t, err)
+}
+
+func TestAddGrantPeriodicVestingAcc_FullSlash(t *testing.T) {
+	c := sdk.NewCoins
+	stake := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, amt) }
+	now := tmtime.Now()
+
+	// set up simapp
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	// create an account with an initial grant
+	periods := types.Periods{
+		{Length: 100, Amount: c(stake(40))},
+		{Length: 100, Amount: c(stake(60))},
+	}
+	bacc, _ := initBaseAccount()
+	origCoins := c(stake(100))
+	pva := types.NewPeriodicVestingAccount(bacc, origCoins, now.Unix(), periods)
+
+	// simulate all 100stake lost to slashing
+	pva.DelegatedVesting = c(stake(100))
+
+	// Nothing locked at now+150 since all unvested lost to slashing
+	require.Equal(t, int64(0), pva.LockedCoins(ctx.WithBlockTime(now.Add(150*time.Second))).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant of 50stake
+	newGrant := c(stake(50))
+	grantAction := types.NewPeriodicGrantAction(app.StakingKeeper, now.Add(500*time.Second).Unix(), []types.Period{{Length: 50, Amount: newGrant}}, newGrant)
+	err := pva.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+	app.AccountKeeper.SetAccount(ctx, pva)
+
+	// Only 10 of the new grant locked, since 40 fell into the "hole" of slashed-vested
+	require.Equal(t, int64(10), pva.LockedCoins(ctx.WithBlockTime(now.Add(150*time.Second))).AmountOf(stakeDenom).Int64())
+}
+
+func TestAddGrantPeriodicVestingAcc_negAmount(t *testing.T) {
+	c := sdk.NewCoins
+	fee := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, amt) }
+	stake := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, amt) }
+	now := tmtime.Now()
+
+	// set up simapp
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	// create an account with an initial grant
+	periods := types.Periods{
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+	}
+	bacc, origCoins := initBaseAccount()
+	pva := types.NewPeriodicVestingAccount(bacc, origCoins, now.Unix(), periods)
+	addr := pva.GetAddress()
+
+	// At now+150, add a new grant which attempts to prematurely vest the grant
+	bogusPeriods := types.Periods{
+		{Length: 1, Amount: c(fee(750))},
+		{Length: 1000, Amount: []sdk.Coin{{Denom: feeDenom, Amount: sdk.NewInt(-749)}}},
+	}
+	ctx = ctx.WithBlockTime(now.Add(150 * time.Second))
+	grantAction := types.NewPeriodicGrantAction(app.StakingKeeper, ctx.BlockTime().Unix(), bogusPeriods, c(fee(1)))
+	err := pva.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+	app.AccountKeeper.SetAccount(ctx, pva)
+
+	// fund the vesting account with new grant (old has vested and transferred out)
+	err = testutil.FundAccount(app.BankKeeper, ctx, addr, c(fee(1001), stake(100)))
+	require.NoError(t, err)
+	require.Equal(t, int64(100), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+
+	// try to transfer the original grant before its time
+	ctx = ctx.WithBlockTime(now.Add(160 * time.Second))
+	_, _, dest := testdata.KeyTestPubAddr()
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, c(fee(750)))
+	require.NoError(t, err)
+}
+
 func TestGetVestedCoinsPeriodicVestingAcc(t *testing.T) {
 	now := tmtime.Now()
 	endTime := now.Add(24 * time.Hour)
@@ -421,16 +626,16 @@ func TestSpendableCoinsPeriodicVestingAcc(t *testing.T) {
 
 	// require that there exist no spendable coins at the beginning of the
 	// vesting schedule
-	lockedCoins := pva.LockedCoins(now)
+	lockedCoins := pva.LockedCoins(contextAt(now))
 	require.Equal(t, origCoins, lockedCoins)
 
 	// require that all original coins are spendable at the end of the vesting
 	// schedule
-	lockedCoins = pva.LockedCoins(endTime)
+	lockedCoins = pva.LockedCoins(contextAt(endTime))
 	require.Equal(t, sdk.NewCoins(), lockedCoins)
 
 	// require that all still vesting coins (50%) are locked
-	lockedCoins = pva.LockedCoins(now.Add(12 * time.Hour))
+	lockedCoins = pva.LockedCoins(contextAt(now.Add(12 * time.Hour)))
 	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}, lockedCoins)
 }
 
@@ -589,18 +794,18 @@ func TestSpendableCoinsPermLockedVestingAcc(t *testing.T) {
 	// require that all coins are locked in the beginning of the vesting
 	// schedule
 	plva := types.NewPermanentLockedAccount(bacc, origCoins)
-	lockedCoins := plva.LockedCoins(now)
+	lockedCoins := plva.LockedCoins(contextAt(now))
 	require.True(t, lockedCoins.IsEqual(origCoins))
 
 	// require that all coins are still locked at end time
-	lockedCoins = plva.LockedCoins(endTime)
+	lockedCoins = plva.LockedCoins(contextAt(endTime))
 	require.True(t, lockedCoins.IsEqual(origCoins))
 
 	// delegate some locked coins
 	// require that locked is reduced
 	delegatedAmount := sdk.NewCoins(sdk.NewInt64Coin(stakeDenom, 50))
 	plva.TrackDelegation(now.Add(12*time.Hour), origCoins, delegatedAmount)
-	lockedCoins = plva.LockedCoins(now.Add(12 * time.Hour))
+	lockedCoins = plva.LockedCoins(contextAt(now.Add(12 * time.Hour)))
 	require.True(t, lockedCoins.IsEqual(origCoins.Sub(delegatedAmount...)))
 }
 
@@ -677,6 +882,795 @@ func TestTrackUndelegationPermLockedVestingAcc(t *testing.T) {
 	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)}, plva.DelegatedVesting)
 }
 
+func TestGetVestedCoinsClawbackVestingAcc(t *testing.T) {
+	now := tmtime.Now()
+	endTime := now.Add(24 * time.Hour)
+	lockupPeriods := types.Periods{
+		types.Period{Length: int64(16 * 60 * 60), Amount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100))},
+	}
+	vestingPeriods := types.Periods{
+		types.Period{Length: int64(12 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+	}
+
+	bacc, origCoins := initBaseAccount()
+	va := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+
+	// require no coins vested at the beginning of the vesting schedule
+	vestedCoins := va.GetVestedCoins(now)
+	require.Nil(t, vestedCoins)
+
+	// require all coins vested at the end of the vesting schedule
+	vestedCoins = va.GetVestedCoins(endTime)
+	require.Equal(t, origCoins, vestedCoins)
+
+	// require no coins vested during first vesting period
+	vestedCoins = va.GetVestedCoins(now.Add(6 * time.Hour))
+	require.Nil(t, vestedCoins)
+
+	// require no coins vested after period1 before unlocking
+	vestedCoins = va.GetVestedCoins(now.Add(14 * time.Hour))
+	require.Nil(t, vestedCoins)
+
+	// require 50% of coins vested after period 1 at unlocking
+	vestedCoins = va.GetVestedCoins(now.Add(16 * time.Hour))
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}, vestedCoins)
+
+	// require period 2 coins don't vest until period is over
+	vestedCoins = va.GetVestedCoins(now.Add(17 * time.Hour))
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}, vestedCoins)
+
+	// require 75% of coins vested after period 2
+	vestedCoins = va.GetVestedCoins(now.Add(18 * time.Hour))
+	require.Equal(t,
+		sdk.Coins{
+			sdk.NewInt64Coin(feeDenom, 750), sdk.NewInt64Coin(stakeDenom, 75),
+		}, vestedCoins)
+
+	// require 100% of coins vested
+	vestedCoins = va.GetVestedCoins(now.Add(48 * time.Hour))
+	require.Equal(t, origCoins, vestedCoins)
+}
+
+func TestGetVestingCoinsClawbackVestingAcc(t *testing.T) {
+	now := tmtime.Now()
+	endTime := now.Add(24 * time.Hour)
+	lockupPeriods := types.Periods{
+		types.Period{Length: int64(16 * 60 * 60), Amount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100))},
+	}
+	vestingPeriods := types.Periods{
+		types.Period{Length: int64(12 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+	}
+
+	bacc, origCoins := initBaseAccount()
+	va := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+
+	// require all coins vesting at the beginning of the vesting schedule
+	vestingCoins := va.GetVestingCoins(now)
+	require.Equal(t, origCoins, vestingCoins)
+
+	// require no coins vesting at the end of the vesting schedule
+	vestingCoins = va.GetVestingCoins(endTime)
+	require.Nil(t, vestingCoins)
+
+	// require all coins vesting at first vesting event
+	vestingCoins = va.GetVestingCoins(now.Add(12 * time.Hour))
+	require.Equal(t, origCoins, vestingCoins)
+
+	// require all coins vesting after period 1 before unlocking
+	vestingCoins = va.GetVestingCoins(now.Add(15 * time.Hour))
+	require.Equal(t, origCoins, vestingCoins)
+
+	// require 50% of coins vesting after period 1 at unlocking
+	vestingCoins = va.GetVestingCoins(now.Add(16 * time.Hour))
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}, vestingCoins)
+
+	// require 50% of coins vesting after period 1, after unlocking
+	vestingCoins = va.GetVestingCoins(now.Add(17 * time.Hour))
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}, vestingCoins)
+
+	// require 25% of coins vesting after period 2
+	vestingCoins = va.GetVestingCoins(now.Add(18 * time.Hour))
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}, vestingCoins)
+
+	// require 0% of coins vesting after vesting complete
+	vestingCoins = va.GetVestingCoins(now.Add(48 * time.Hour))
+	require.Nil(t, vestingCoins)
+}
+
+func TestSpendableCoinsClawbackVestingAcc(t *testing.T) {
+	now := tmtime.Now()
+	endTime := now.Add(24 * time.Hour)
+	lockupPeriods := types.Periods{
+		types.Period{Length: int64(16 * 60 * 60), Amount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100))},
+	}
+	vestingPeriods := types.Periods{
+		types.Period{Length: int64(12 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+	}
+
+	bacc, origCoins := initBaseAccount()
+	va := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+
+	// require that there exist no spendable coins at the beginning of the
+	// vesting schedule
+	lockedCoins := va.LockedCoins(contextAt(now))
+	require.Equal(t, origCoins, lockedCoins)
+
+	// require that all original coins are spendable at the end of the vesting
+	// schedule
+	lockedCoins = va.LockedCoins(contextAt(endTime))
+	require.Equal(t, sdk.NewCoins(), lockedCoins)
+
+	// require that all still vesting coins (50%) are locked
+	lockedCoins = va.LockedCoins(contextAt(now.Add(17 * time.Hour)))
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}, lockedCoins)
+}
+
+func TestTrackDelegationClawbackVestingAcc(t *testing.T) {
+	now := tmtime.Now()
+	endTime := now.Add(24 * time.Hour)
+	lockupPeriods := types.Periods{
+		types.Period{Length: int64(16 * 60 * 60), Amount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100))},
+	}
+	vestingPeriods := types.Periods{
+		types.Period{Length: int64(12 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+	}
+
+	bacc, origCoins := initBaseAccount()
+
+	// require the ability to delegate all vesting coins
+	va := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(now, origCoins, origCoins)
+	require.Equal(t, origCoins, va.DelegatedVesting)
+	require.Nil(t, va.DelegatedFree)
+
+	// require the ability to delegate all vested coins
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(endTime, origCoins, origCoins)
+	require.Nil(t, va.DelegatedVesting)
+	require.Equal(t, origCoins, va.DelegatedFree)
+
+	// delegate half of vesting coins
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(now, origCoins, vestingPeriods[0].Amount)
+	// require that all delegated coins are delegated vesting
+	require.Equal(t, va.DelegatedVesting, vestingPeriods[0].Amount)
+	require.Nil(t, va.DelegatedFree)
+
+	// delegate 75% of coins, split between vested and vesting
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(now.Add(17*time.Hour), origCoins, vestingPeriods[0].Amount.Add(vestingPeriods[1].Amount...))
+	// require that the maximum possible amount of vesting coins are chosen for delegation.
+	require.Equal(t, va.DelegatedFree, vestingPeriods[1].Amount)
+	require.Equal(t, va.DelegatedVesting, vestingPeriods[0].Amount)
+
+	// require the ability to delegate all vesting coins (50%) and all vested coins (50%)
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)}, va.DelegatedVesting)
+	require.Nil(t, va.DelegatedFree)
+
+	va.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)}, va.DelegatedVesting)
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)}, va.DelegatedFree)
+
+	// require no modifications when delegation amount is zero or not enough funds
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	require.Panics(t, func() {
+		va.TrackDelegation(endTime, origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 1000000)})
+	})
+	require.Nil(t, va.DelegatedVesting)
+	require.Nil(t, va.DelegatedFree)
+}
+
+func TestTrackUndelegationClawbackVestingAcc(t *testing.T) {
+	now := tmtime.Now()
+	endTime := now.Add(24 * time.Hour)
+	lockupPeriods := types.Periods{
+		types.Period{Length: int64(16 * 60 * 60), Amount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100))},
+	}
+	vestingPeriods := types.Periods{
+		types.Period{Length: int64(12 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+		types.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},
+	}
+
+	bacc, origCoins := initBaseAccount()
+
+	// require the ability to undelegate all vesting coins at the beginning of vesting
+	va := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(now, origCoins, origCoins)
+	va.TrackUndelegation(origCoins)
+	require.Nil(t, va.DelegatedFree)
+	require.Nil(t, va.DelegatedVesting)
+
+	// require the ability to undelegate all vested coins at the end of vesting
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+
+	va.TrackDelegation(endTime, origCoins, origCoins)
+	va.TrackUndelegation(origCoins)
+	require.Nil(t, va.DelegatedFree)
+	require.Nil(t, va.DelegatedVesting)
+
+	// require the ability to undelegate half of coins
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(endTime, origCoins, vestingPeriods[0].Amount)
+	va.TrackUndelegation(vestingPeriods[0].Amount)
+	require.Nil(t, va.DelegatedFree)
+	require.Nil(t, va.DelegatedVesting)
+
+	// require no modifications when the undelegation amount is zero
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+
+	require.Panics(t, func() {
+		va.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 0)})
+	})
+	require.Nil(t, va.DelegatedFree)
+	require.Nil(t, va.DelegatedVesting)
+
+	// vest 50% and delegate to two validators
+	va = types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte("funder")), origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	va.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})
+	va.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})
+
+	// undelegate from one validator that got slashed 50%
+	va.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)})
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)}, va.DelegatedFree)
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)}, va.DelegatedVesting)
+
+	// undelegate from the other validator that did not get slashed
+	va.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})
+	require.Nil(t, va.DelegatedFree)
+	require.Equal(t, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)}, va.DelegatedVesting)
+}
+
+// createValidator creates a validator in the given SimApp.
+func createValidator(t *testing.T, ctx sdk.Context, app *simapp.SimApp, powers int64) (sdk.ValAddress, stakingtypes.Validator) {
+	valTokens := sdk.TokensFromConsensusPower(powers, sdk.DefaultPowerReduction)
+	addrs := simapp.AddTestAddrsIncremental(app, ctx, 1, valTokens)
+	valAddrs := simapp.ConvertAddrsToValAddrs(addrs)
+	pks := simapp.CreateTestPubKeys(1)
+	cdc := app.AppCodec() // simapp.MakeTestEncodingConfig().Marshaler
+
+	app.StakingKeeper = stakingkeeper.NewKeeper(
+		cdc,
+		app.GetKey(stakingtypes.StoreKey),
+		app.AccountKeeper,
+		app.BankKeeper,
+		app.GetSubspace(stakingtypes.ModuleName),
+	)
+
+	val, err := stakingtypes.NewValidator(valAddrs[0], pks[0], stakingtypes.Description{})
+	require.NoError(t, err)
+
+	app.StakingKeeper.SetValidator(ctx, val)
+	require.NoError(t, app.StakingKeeper.SetValidatorByConsAddr(ctx, val))
+	app.StakingKeeper.SetNewValidatorByPowerIndex(ctx, val)
+
+	_, err = app.StakingKeeper.Delegate(ctx, addrs[0], valTokens, stakingtypes.Unbonded, val, true)
+	require.NoError(t, err)
+
+	_ = staking.EndBlocker(ctx, app.StakingKeeper)
+
+	return valAddrs[0], val
+}
+
+func TestClawback(t *testing.T) {
+	c := sdk.NewCoins
+	fee := func(x int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, x) }
+	stake := func(x int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, x) }
+	now := tmtime.Now()
+
+	// set up simapp and validators
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	valAddr, val := createValidator(t, ctx, app, 100)
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	lockupPeriods := types.Periods{
+		{Length: int64(12 * 3600), Amount: c(fee(1000), stake(100))}, // noon
+	}
+	vestingPeriods := types.Periods{
+		{Length: int64(8 * 3600), Amount: c(fee(200))},            // 8am
+		{Length: int64(1 * 3600), Amount: c(fee(200), stake(50))}, // 9am
+		{Length: int64(6 * 3600), Amount: c(fee(200), stake(50))}, // 3pm
+		{Length: int64(2 * 3600), Amount: c(fee(200))},            // 5pm
+		{Length: int64(1 * 3600), Amount: c(fee(200))},            // 6pm
+	}
+
+	bacc, origCoins := initBaseAccount()
+	_, _, funder := testdata.KeyTestPubAddr()
+	va := types.NewClawbackVestingAccount(bacc, funder, origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	// simulate 17stake lost to slashing
+	va.DelegatedVesting = c(stake(17))
+	addr := va.GetAddress()
+	app.AccountKeeper.SetAccount(ctx, va)
+
+	// fund the vesting account with 17 take lost to slashing
+	err := testutil.FundAccount(app.BankKeeper, ctx, addr, c(fee(1000), stake(83)))
+	require.NoError(t, err)
+	require.Equal(t, int64(1000), app.BankKeeper.GetBalance(ctx, addr, feeDenom).Amount.Int64())
+	require.Equal(t, int64(83), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+	ctx = ctx.WithBlockTime(now.Add(11 * time.Hour))
+
+	// delegate 65
+	shares, err := app.StakingKeeper.Delegate(ctx, addr, sdk.NewInt(65), stakingtypes.Unbonded, val, true)
+	require.NoError(t, err)
+	require.Equal(t, sdk.NewInt(65), shares.TruncateInt())
+	require.Equal(t, int64(18), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+
+	// undelegate 5
+	_, err = app.StakingKeeper.Undelegate(ctx, addr, valAddr, sdk.NewDec(5))
+	require.NoError(t, err)
+
+	// clawback the unvested funds (600fee, 50stake)
+	_, _, dest := testdata.KeyTestPubAddr()
+	va2 := app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+	clawbackAction := types.NewClawbackAction(funder, dest, app.AccountKeeper, app.BankKeeper, app.StakingKeeper)
+	err = va2.Clawback(ctx, clawbackAction)
+	require.NoError(t, err)
+
+	// check vesting account
+	// want 400fee, 33stake (delegated), all vested
+	feeAmt := app.BankKeeper.GetBalance(ctx, addr, feeDenom).Amount
+	require.Equal(t, int64(400), feeAmt.Int64())
+	stakeAmt := app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount
+	require.Equal(t, int64(0), stakeAmt.Int64())
+	del, found := app.StakingKeeper.GetDelegation(ctx, addr, valAddr)
+	require.True(t, found)
+	shares = del.GetShares()
+	val, found = app.StakingKeeper.GetValidator(ctx, valAddr)
+	require.True(t, found)
+	stakeAmt = val.TokensFromSharesTruncated(shares).RoundInt()
+	require.Equal(t, sdk.NewInt(33), stakeAmt)
+
+	// check destination account
+	// want 600fee, 50stake (18 unbonded, 5 unboinding, 27 bonded)
+	feeAmt = app.BankKeeper.GetBalance(ctx, dest, feeDenom).Amount
+	require.Equal(t, int64(600), feeAmt.Int64())
+	stakeAmt = app.BankKeeper.GetBalance(ctx, dest, stakeDenom).Amount
+	require.Equal(t, int64(18), stakeAmt.Int64())
+	del, found = app.StakingKeeper.GetDelegation(ctx, dest, valAddr)
+	require.True(t, found)
+	shares = del.GetShares()
+	stakeAmt = val.TokensFromSharesTruncated(shares).RoundInt()
+	require.Equal(t, sdk.NewInt(27), stakeAmt)
+	ubd, found := app.StakingKeeper.GetUnbondingDelegation(ctx, dest, valAddr)
+	require.True(t, found)
+	require.Equal(t, sdk.NewInt(5), ubd.Entries[0].Balance)
+}
+
+func TestClawback_finalUnlock(t *testing.T) {
+	// tests a variant of TestClawback with unlock events after the last vesting event
+	c := sdk.NewCoins
+	fee := func(x int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, x) }
+	stake := func(x int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, x) }
+	now := tmtime.Now()
+
+	// set up simapp and validators
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	lockupPeriods := types.Periods{
+		{Length: int64(20 * 3600), Amount: c(fee(1000), stake(100))}, // 8pm
+	}
+	vestingPeriods := types.Periods{
+		{Length: int64(8 * 3600), Amount: c(fee(200))},            // 8am
+		{Length: int64(1 * 3600), Amount: c(fee(200), stake(50))}, // 9am
+		{Length: int64(6 * 3600), Amount: c(fee(200), stake(50))}, // 3pm
+		{Length: int64(2 * 3600), Amount: c(fee(200))},            // 5pm
+		{Length: int64(1 * 3600), Amount: c(fee(200))},            // 6pm
+	}
+
+	bacc, origCoins := initBaseAccount()
+	_, _, funder := testdata.KeyTestPubAddr()
+	va := types.NewClawbackVestingAccount(bacc, funder, origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	addr := va.GetAddress()
+	app.AccountKeeper.SetAccount(ctx, va)
+
+	// fund the vesting account with 17 take lost to slashing
+	err := testutil.FundAccount(app.BankKeeper, ctx, addr, c(fee(1000), stake(100)))
+	require.NoError(t, err)
+	require.Equal(t, int64(1000), app.BankKeeper.GetBalance(ctx, addr, feeDenom).Amount.Int64())
+	require.Equal(t, int64(100), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+	ctx = ctx.WithBlockTime(now.Add(11 * time.Hour))
+
+	// clawback the unvested funds (600fee, 50stake)
+	_, _, dest := testdata.KeyTestPubAddr()
+	va2 := app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+	clawbackAction := types.NewClawbackAction(funder, dest, app.AccountKeeper, app.BankKeeper, app.StakingKeeper)
+	err = va2.Clawback(ctx, clawbackAction)
+	require.NoError(t, err)
+
+	// check vesting account
+	// want 400fee, 50stake, all vested
+	feeAmt := app.BankKeeper.GetBalance(ctx, addr, feeDenom).Amount
+	require.Equal(t, int64(400), feeAmt.Int64())
+	stakeAmt := app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount
+	require.Equal(t, int64(50), stakeAmt.Int64())
+
+	// check destination account
+	// want 600fee, 50stake
+	feeAmt = app.BankKeeper.GetBalance(ctx, dest, feeDenom).Amount
+	require.Equal(t, int64(600), feeAmt.Int64())
+	stakeAmt = app.BankKeeper.GetBalance(ctx, dest, stakeDenom).Amount
+	require.Equal(t, int64(50), stakeAmt.Int64())
+
+	// Remaining funds in vesting account should still be locked at 7pm
+	ctx = ctx.WithBlockTime(now.Add(19 * time.Hour))
+	spendable := app.BankKeeper.SpendableCoins(ctx, addr)
+	require.True(t, spendable.IsZero())
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, c(fee(10)))
+	require.Error(t, err)
+}
+
+func TestRewards(t *testing.T) {
+	c := sdk.NewCoins
+	stake := func(x int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, x) }
+	now := tmtime.Now()
+
+	// set up simapp and validators
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	_, val := createValidator(t, ctx, app, 100)
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	// create vesting account
+	lockupPeriods := types.Periods{
+		{Length: 1, Amount: c(stake(4000))},
+	}
+	vestingPeriods := types.Periods{
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+	}
+	bacc, _ := initBaseAccount()
+	origCoins := c(stake(4000))
+	_, _, funder := testdata.KeyTestPubAddr()
+	va := types.NewClawbackVestingAccount(bacc, funder, origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	addr := va.GetAddress()
+	app.AccountKeeper.SetAccount(ctx, va)
+
+	// fund the vesting account with 300stake lost to transfer
+	err := testutil.FundAccount(app.BankKeeper, ctx, addr, c(stake(3700)))
+	require.NoError(t, err)
+	require.Equal(t, int64(3700), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+	ctx = ctx.WithBlockTime(now.Add(650 * time.Second))
+
+	// delegate 1600
+	shares, err := app.StakingKeeper.Delegate(ctx, addr, sdk.NewInt(1600), stakingtypes.Unbonded, val, true)
+	require.NoError(t, err)
+	require.Equal(t, sdk.NewInt(1600), shares.TruncateInt())
+	require.Equal(t, int64(2100), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+	va = app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+	require.Equal(t, int64(1000), va.GetVestingCoins(ctx.BlockTime()).AmountOf(stakeDenom).Int64())
+
+	// distribute a reward of 120stake
+	err = testutil.FundAccount(app.BankKeeper, ctx, addr, c(stake(120)))
+	require.NoError(t, err)
+	rewardAction := types.NewClawbackRewardAction(app.AccountKeeper, app.BankKeeper, app.StakingKeeper)
+	err = va.PostReward(ctx, c(stake(120)), rewardAction)
+	require.NoError(t, err)
+
+	// With 1600 delegated, 1000 unvested, reward should be 75 unvested
+	va = app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+	require.Equal(t, int64(4075), va.OriginalVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, 8, len(va.VestingPeriods))
+	for i := 0; i < 6; i++ {
+		require.Equal(t, int64(500), va.VestingPeriods[i].Amount.AmountOf(stakeDenom).Int64())
+	}
+	require.Equal(t, int64(537), va.VestingPeriods[6].Amount.AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(538), va.VestingPeriods[7].Amount.AmountOf(stakeDenom).Int64())
+}
+
+func TestRewards_PostSlash(t *testing.T) {
+	c := sdk.NewCoins
+	stake := func(x int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, x) }
+	now := tmtime.Now()
+
+	// set up simapp and validators
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	_, val := createValidator(t, ctx, app, 100)
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	// create vesting account with a simulated 350stake lost to slashing
+	lockupPeriods := types.Periods{
+		{Length: 1, Amount: c(stake(4000))},
+	}
+	vestingPeriods := types.Periods{
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+		{Length: int64(100), Amount: c(stake(500))},
+	}
+	bacc, _ := initBaseAccount()
+	origCoins := c(stake(4000))
+	_, _, funder := testdata.KeyTestPubAddr()
+	va := types.NewClawbackVestingAccount(bacc, funder, origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	addr := va.GetAddress()
+	va.DelegatedVesting = c(stake(350))
+	app.AccountKeeper.SetAccount(ctx, va)
+
+	// fund the vesting account with 350 stake lost to slashing
+	err := testutil.FundAccount(app.BankKeeper, ctx, addr, c(stake(3650)))
+	require.NoError(t, err)
+	require.Equal(t, int64(3650), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+
+	// delegate all 3650stake
+	shares, err := app.StakingKeeper.Delegate(ctx, addr, sdk.NewInt(3650), stakingtypes.Unbonded, val, true)
+	require.NoError(t, err)
+	require.Equal(t, sdk.NewInt(3650), shares.TruncateInt())
+	require.Equal(t, int64(0), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+	va = app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+
+	// distribute a reward of 160stake - should all be unvested
+	err = testutil.FundAccount(app.BankKeeper, ctx, addr, c(stake(160)))
+	require.NoError(t, err)
+	rewardAction := types.NewClawbackRewardAction(app.AccountKeeper, app.BankKeeper, app.StakingKeeper)
+	err = va.PostReward(ctx, c(stake(160)), rewardAction)
+	require.NoError(t, err)
+	va = app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+	require.Equal(t, int64(4160), va.OriginalVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, 8, len(va.VestingPeriods))
+	for i := 0; i < 8; i++ {
+		require.Equal(t, int64(520), va.VestingPeriods[i].Amount.AmountOf(stakeDenom).Int64())
+	}
+
+	// must not be able to transfer reward until it vests
+	_, _, dest := testdata.KeyTestPubAddr()
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, c(stake(1)))
+	require.Error(t, err)
+	ctx = ctx.WithBlockTime(now.Add(600 * time.Second))
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, c(stake(160)))
+	require.NoError(t, err)
+
+	// distribute another reward once everything has vested
+	ctx = ctx.WithBlockTime(now.Add(1200 * time.Second))
+	err = testutil.FundAccount(app.BankKeeper, ctx, addr, c(stake(160)))
+	require.NoError(t, err)
+	err = va.PostReward(ctx, c(stake(160)), rewardAction)
+	require.NoError(t, err)
+	va = app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+	// shouldn't be added to vesting schedule
+	require.Equal(t, int64(4160), va.OriginalVesting.AmountOf(stakeDenom).Int64())
+}
+
+func TestAddGrantClawbackVestingAcc_fullSlash(t *testing.T) {
+	c := sdk.NewCoins
+	stake := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, amt) }
+	now := tmtime.Now()
+
+	// set up simapp
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	// create an account with an initial grant
+	_, _, funder := testdata.KeyTestPubAddr()
+	lockupPeriods := types.Periods{{Length: 1, Amount: c(stake(100))}}
+	vestingPeriods := types.Periods{
+		{Length: 100, Amount: c(stake(40))},
+		{Length: 100, Amount: c(stake(60))},
+	}
+	bacc, _ := initBaseAccount()
+	origCoins := c(stake(100))
+	va := types.NewClawbackVestingAccount(bacc, funder, origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+
+	// simulate all 100stake lost to slashing
+	va.DelegatedVesting = c(stake(100))
+
+	// Nothing locked at now+150, due to slashing
+	require.Equal(t, int64(0), va.LockedCoins(ctx.WithBlockTime(now.Add(150*time.Second))).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant of 50stake
+	newGrant := c(stake(50))
+	grantAction := types.NewClawbackGrantAction(funder.String(), app.StakingKeeper, now.Add(500*time.Second).Unix(),
+		[]types.Period{{Length: 1, Amount: newGrant}},
+		[]types.Period{{Length: 50, Amount: newGrant}}, newGrant)
+	err := va.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+	app.AccountKeeper.SetAccount(ctx, va)
+
+	// Only 10 of the new grant locked, since 40 fell into the "hole" of slashed-vested.
+	require.Equal(t, int64(10), va.LockedCoins(ctx.WithBlockTime(now.Add(150*time.Second))).AmountOf(stakeDenom).Int64())
+}
+
+func TestAddGrantClawbackVestingAcc(t *testing.T) {
+	c := sdk.NewCoins
+	fee := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, amt) }
+	stake := func(amt int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, amt) }
+	now := tmtime.Now()
+
+	// set up simapp
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	// create an account with an initial grant
+	_, _, funder := testdata.KeyTestPubAddr()
+	lockupPeriods := types.Periods{{Length: 1, Amount: c(fee(1000), stake(100))}}
+	vestingPeriods := types.Periods{
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+		{Length: 100, Amount: c(fee(250), stake(25))},
+	}
+	bacc, origCoins := initBaseAccount()
+	va := types.NewClawbackVestingAccount(bacc, funder, origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	addr := va.GetAddress()
+
+	// simulate 60stake (unvested) lost to slashing
+	va.DelegatedVesting = c(stake(60))
+
+	// At now+150, 75stake unvested but only 15stake are locked, due to slashing
+	ctx = ctx.WithBlockTime(now.Add(150 * time.Second))
+	require.Equal(t, int64(75), va.GetVestingCoins(ctx.BlockTime()).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(15), va.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant while all slashing is covered by unvested tokens
+	grantAction := types.NewClawbackGrantAction(funder.String(), app.StakingKeeper, ctx.BlockTime().Unix(),
+		lockupPeriods, vestingPeriods, origCoins)
+	err := va.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+
+	// After new grant, 115stake locked at now+150, due to slashing,
+	// delegation bookkeeping unchanged
+	require.Equal(t, int64(115), va.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(60), va.DelegatedVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), va.DelegatedFree.AmountOf(stakeDenom).Int64())
+
+	// At now+425, 50stake unvested, nothing locked due to slashing
+	ctx = ctx.WithBlockTime(now.Add(425 * time.Second))
+	require.Equal(t, int64(50), va.GetVestingCoins(ctx.BlockTime()).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), va.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant, while slashed amount is 50 unvested, 10 vested
+	grantAction = types.NewClawbackGrantAction(funder.String(), app.StakingKeeper, ctx.BlockTime().Unix(), lockupPeriods, vestingPeriods, origCoins)
+	err = va.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+
+	// After new grant, slashed amount reduced to 50 vested, locked is 100
+	require.Equal(t, int64(100), va.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(50), va.DelegatedVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), va.DelegatedFree.AmountOf(stakeDenom).Int64())
+
+	// At now+1000, nothing unvested, nothing locked
+	ctx = ctx.WithBlockTime(now.Add(1000 * time.Second))
+	require.Equal(t, int64(0), va.GetVestingCoins(ctx.BlockTime()).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), va.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+
+	// Add a new grant with residual slashed amount, but no unvested
+	grantAction = types.NewClawbackGrantAction(funder.String(), app.StakingKeeper, ctx.BlockTime().Unix(), lockupPeriods, vestingPeriods, origCoins)
+	err = va.AddGrant(ctx, grantAction)
+	require.NoError(t, err)
+
+	// After new grant, all 100 locked, no residual delegation bookkeeping
+	require.Equal(t, int64(100), va.LockedCoins(ctx).AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), va.DelegatedVesting.AmountOf(stakeDenom).Int64())
+	require.Equal(t, int64(0), va.DelegatedFree.AmountOf(stakeDenom).Int64())
+
+	app.AccountKeeper.SetAccount(ctx, va)
+
+	// fund the vesting account with new grant (old has vested and transferred out)
+	err = testutil.FundAccount(app.BankKeeper, ctx, addr, origCoins)
+	require.NoError(t, err)
+	require.Equal(t, int64(100), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+
+	// we should not be able to transfer the latest grant out until it has vested
+	_, _, dest := testdata.KeyTestPubAddr()
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, c(stake(1)))
+	require.Error(t, err)
+	ctx = ctx.WithBlockTime(now.Add(1500 * time.Second))
+	err = app.BankKeeper.SendCoins(ctx, addr, dest, origCoins)
+	require.NoError(t, err)
+}
+
+func TestReturnGrants(t *testing.T) {
+	c := sdk.NewCoins
+	fee := func(x int64) sdk.Coin { return sdk.NewInt64Coin(feeDenom, x) }
+	stake := func(x int64) sdk.Coin { return sdk.NewInt64Coin(stakeDenom, x) }
+	now := tmtime.Now()
+
+	// set up simapp and validators
+	app := simapp.Setup(t, false)
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{}).WithBlockTime((now))
+	valAddr, val := createValidator(t, ctx, app, 100)
+	require.Equal(t, "stake", app.StakingKeeper.BondDenom(ctx))
+
+	lockupPeriods := types.Periods{
+		{Length: int64(12 * 3600), Amount: c(fee(1000), stake(100))}, // noon
+	}
+	vestingPeriods := types.Periods{
+		{Length: int64(8 * 3600), Amount: c(fee(200))},            // 8am
+		{Length: int64(1 * 3600), Amount: c(fee(200), stake(50))}, // 9am
+		{Length: int64(6 * 3600), Amount: c(fee(200), stake(50))}, // 3pm
+		{Length: int64(2 * 3600), Amount: c(fee(200))},            // 5pm
+		{Length: int64(1 * 3600), Amount: c(fee(200))},            // 6pm
+	}
+
+	bacc, origCoins := initBaseAccount()
+	_, _, funder := testdata.KeyTestPubAddr()
+	va := types.NewClawbackVestingAccount(bacc, funder, origCoins, now.Unix(), lockupPeriods, vestingPeriods)
+	// simulate 17stake lost to slashing
+	va.DelegatedVesting = c(stake(17))
+	addr := va.GetAddress()
+	app.AccountKeeper.SetAccount(ctx, va)
+
+	// fund the vesting account with an extra 200fee but 17stake lost to slashing
+	err := testutil.FundAccount(app.BankKeeper, ctx, addr, c(fee(1200), stake(83)))
+	require.NoError(t, err)
+	require.Equal(t, int64(1200), app.BankKeeper.GetBalance(ctx, addr, feeDenom).Amount.Int64())
+	require.Equal(t, int64(83), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+	ctx = ctx.WithBlockTime(now.Add(11 * time.Hour))
+
+	// delegate 65
+	shares, err := app.StakingKeeper.Delegate(ctx, addr, sdk.NewInt(65), stakingtypes.Unbonded, val, true)
+	require.NoError(t, err)
+	require.Equal(t, sdk.NewInt(65), shares.TruncateInt())
+	require.Equal(t, int64(18), app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount.Int64())
+
+	// undelegate 5
+	_, err = app.StakingKeeper.Undelegate(ctx, addr, valAddr, sdk.NewDec(5))
+	require.NoError(t, err)
+
+	// Return the grant (1000fee, 100stake) with (1200fee, 83stake) available
+	va2 := app.AccountKeeper.GetAccount(ctx, addr).(*types.ClawbackVestingAccount)
+	returnGrantAction := types.NewReturnGrantAction(app.AccountKeeper, app.BankKeeper, app.StakingKeeper)
+	err = va2.ReturnGrants(ctx, returnGrantAction)
+	require.NoError(t, err)
+
+	// check vesting account
+	// want 200fee all vested
+	dest := funder
+	feeAmt := app.BankKeeper.GetBalance(ctx, addr, feeDenom).Amount
+	require.Equal(t, int64(200), feeAmt.Int64())
+	stakeAmt := app.BankKeeper.GetBalance(ctx, addr, stakeDenom).Amount
+	require.Equal(t, int64(0), stakeAmt.Int64())
+	spendable := app.BankKeeper.SpendableCoins(ctx, addr)
+	require.Equal(t, int64(200), spendable.AmountOf(feeDenom).Int64())
+	_, found := app.StakingKeeper.GetDelegation(ctx, addr, valAddr)
+	require.False(t, found)
+	_, found = app.StakingKeeper.GetUnbondingDelegation(ctx, addr, valAddr)
+	require.False(t, found)
+
+	// check destination account
+	// want 1000fee, 83stake (18 unbonded, 5 unbonding, 60 bonded)
+
+	feeAmt = app.BankKeeper.GetBalance(ctx, dest, feeDenom).Amount
+	require.Equal(t, int64(1000), feeAmt.Int64())
+	stakeAmt = app.BankKeeper.GetBalance(ctx, dest, stakeDenom).Amount
+	require.Equal(t, int64(18), stakeAmt.Int64())
+	del, found := app.StakingKeeper.GetDelegation(ctx, dest, valAddr)
+	require.True(t, found)
+	shares = del.GetShares()
+	val, found = app.StakingKeeper.GetValidator(ctx, valAddr)
+	require.True(t, found)
+	stakeAmt = val.TokensFromSharesTruncated(shares).RoundInt()
+	require.Equal(t, sdk.NewInt(60), stakeAmt)
+	ubd, found := app.StakingKeeper.GetUnbondingDelegation(ctx, dest, valAddr)
+	require.True(t, found)
+	require.Equal(t, 1, len(ubd.Entries))
+	require.Equal(t, sdk.NewInt(5), ubd.Entries[0].Balance)
+}
+
 func TestGenesisAccountValidate(t *testing.T) {
 	pubkey := secp256k1.GenPrivKey().PubKey()
 	addr := sdk.AccAddress(pubkey.Address())
@@ -742,6 +1736,88 @@ func TestGenesisAccountValidate(t *testing.T) {
 			&types.PermanentLockedAccount{BaseVestingAccount: baseVestingWithCoins},
 			true,
 		},
+		{
+			"valid clawback vesting account",
+			types.NewClawbackVestingAccount(baseAcc, sdk.AccAddress([]byte("the funder")), initialVesting, 0,
+				types.Periods{types.Period{Length: 101, Amount: initialVesting}},
+				types.Periods{types.Period{Length: 201, Amount: initialVesting}}),
+			false,
+		},
+		{
+			"invalid clawback vesting end",
+			&types.ClawbackVestingAccount{
+				BaseVestingAccount: &types.BaseVestingAccount{
+					BaseAccount:     baseAcc,
+					OriginalVesting: initialVesting,
+					EndTime:         50,
+				},
+				FunderAddress:  "funder",
+				StartTime:      100,
+				LockupPeriods:  types.Periods{types.Period{Length: 10, Amount: initialVesting}},
+				VestingPeriods: types.Periods{types.Period{Length: 10, Amount: initialVesting}},
+			},
+			true,
+		},
+		{
+			"invalid clawback long lockup",
+			&types.ClawbackVestingAccount{
+				BaseVestingAccount: &types.BaseVestingAccount{
+					BaseAccount:     baseAcc,
+					OriginalVesting: initialVesting,
+					EndTime:         60,
+				},
+				FunderAddress:  "funder",
+				StartTime:      50,
+				LockupPeriods:  types.Periods{types.Period{Length: 20, Amount: initialVesting}},
+				VestingPeriods: types.Periods{types.Period{Length: 10, Amount: initialVesting}},
+			},
+			true,
+		},
+		{
+			"invalid clawback lockup coins",
+			&types.ClawbackVestingAccount{
+				BaseVestingAccount: &types.BaseVestingAccount{
+					BaseAccount:     baseAcc,
+					OriginalVesting: initialVesting,
+					EndTime:         120,
+				},
+				FunderAddress:  "funder",
+				StartTime:      100,
+				LockupPeriods:  types.Periods{types.Period{Length: 10, Amount: initialVesting.Add(initialVesting...)}},
+				VestingPeriods: types.Periods{types.Period{Length: 10, Amount: initialVesting}},
+			},
+			true,
+		},
+		{
+			"invalid clawback long vesting",
+			&types.ClawbackVestingAccount{
+				BaseVestingAccount: &types.BaseVestingAccount{
+					BaseAccount:     baseAcc,
+					OriginalVesting: initialVesting,
+					EndTime:         110,
+				},
+				FunderAddress:  "funder",
+				StartTime:      100,
+				LockupPeriods:  types.Periods{types.Period{Length: 10, Amount: initialVesting}},
+				VestingPeriods: types.Periods{types.Period{Length: 20, Amount: initialVesting}},
+			},
+			true,
+		},
+		{
+			"invalid clawback vesting coins",
+			&types.ClawbackVestingAccount{
+				BaseVestingAccount: &types.BaseVestingAccount{
+					BaseAccount:     baseAcc,
+					OriginalVesting: initialVesting,
+					EndTime:         120,
+				},
+				FunderAddress:  "funder",
+				StartTime:      100,
+				LockupPeriods:  types.Periods{types.Period{Length: 10, Amount: initialVesting}},
+				VestingPeriods: types.Periods{types.Period{Length: 10, Amount: initialVesting.Add(initialVesting...)}},
+			},
+			true,
+		},
 	}
 
 	for _, tt := range tests {
@@ -830,6 +1906,44 @@ func (s *VestingAccountTestSuite) TestPermanentLockedAccountMarshal() {
 	require.NotNil(err)
 }
 
+func (s *VestingAccountTestSuite) TestClawbackVestingAccountMarshal() {
+	app := s.app
+	require := s.Require()
+	baseAcc, coins := initBaseAccount()
+	addr := sdk.AccAddress([]byte("the funder"))
+	acc := types.NewClawbackVestingAccount(baseAcc, addr, coins, time.Now().Unix(),
+		types.Periods{types.Period{3600, coins}}, types.Periods{types.Period{3600, coins}})
+
+	bz, err := app.AccountKeeper.MarshalAccount(acc)
+	require.Nil(err)
+
+	acc2, err := app.AccountKeeper.UnmarshalAccount(bz)
+	require.Nil(err)
+	require.IsType(&types.ClawbackVestingAccount{}, acc2)
+	require.Equal(acc.String(), acc2.String())
+
+	// error on bad bytes
+	_, err = app.AccountKeeper.UnmarshalAccount(bz[:len(bz)/2])
+	require.NotNil(err)
+}
+
+func (s *VestingAccountTestSuite) TestClawbackVestingAccountStore() {
+	app := s.app
+	require := s.Require()
+	baseAcc, coins := initBaseAccount()
+	addr := sdk.AccAddress([]byte("the funder"))
+	acc := types.NewClawbackVestingAccount(baseAcc, addr, coins, time.Now().Unix(),
+		types.Periods{types.Period{3600, coins}}, types.Periods{types.Period{3600, coins}})
+
+	ctx := app.BaseApp.NewContext(false, tmproto.Header{})
+	createValidator(s.T(), ctx, app, 100)
+
+	app.AccountKeeper.SetAccount(ctx, acc)
+	acc2 := app.AccountKeeper.GetAccount(ctx, acc.GetAddress())
+	require.IsType(&types.ClawbackVestingAccount{}, acc2)
+	require.Equal(acc.String(), acc2.String())
+}
+
 func initBaseAccount() (*authtypes.BaseAccount, sdk.Coins) {
 	_, _, addr := testdata.KeyTestPubAddr()
 	origCoins := sdk.Coins{sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100)}
diff --git a/x/bank/keeper/keeper_test.go b/x/bank/keeper/keeper_test.go
index 8e6e137ed8..92298d0c95 100644
--- a/x/bank/keeper/keeper_test.go
+++ b/x/bank/keeper/keeper_test.go
@@ -44,6 +44,10 @@ var (
 	initCoins  = sdk.NewCoins(sdk.NewCoin(sdk.DefaultBondDenom, initTokens))
 )
 
+func contextAt(t time.Time) sdk.Context {
+	return sdk.Context{}.WithBlockTime(t)
+}
+
 func newFooCoin(amt int64) sdk.Coin {
 	return sdk.NewInt64Coin(fooDenom, amt)
 }
@@ -806,10 +810,10 @@ func (suite *IntegrationTestSuite) TestVestingAccountReceive() {
 	vacc = app.AccountKeeper.GetAccount(ctx, addr1).(*vesting.ContinuousVestingAccount)
 	balances := app.BankKeeper.GetAllBalances(ctx, addr1)
 	suite.Require().Equal(origCoins.Add(sendCoins...), balances)
-	suite.Require().Equal(balances.Sub(vacc.LockedCoins(now)...), sendCoins)
+	suite.Require().Equal(balances.Sub(vacc.LockedCoins(contextAt(now))...), sendCoins)
 
 	// require coins are spendable plus any that have vested
-	suite.Require().Equal(balances.Sub(vacc.LockedCoins(now.Add(12*time.Hour))...), origCoins)
+	suite.Require().Equal(balances.Sub(vacc.LockedCoins(contextAt(now.Add(12*time.Hour)))...), origCoins)
 }
 
 func (suite *IntegrationTestSuite) TestPeriodicVestingAccountReceive() {
@@ -845,10 +849,10 @@ func (suite *IntegrationTestSuite) TestPeriodicVestingAccountReceive() {
 	vacc = app.AccountKeeper.GetAccount(ctx, addr1).(*vesting.PeriodicVestingAccount)
 	balances := app.BankKeeper.GetAllBalances(ctx, addr1)
 	suite.Require().Equal(origCoins.Add(sendCoins...), balances)
-	suite.Require().Equal(balances.Sub(vacc.LockedCoins(now)...), sendCoins)
+	suite.Require().Equal(balances.Sub(vacc.LockedCoins(contextAt(now))...), sendCoins)
 
 	// require coins are spendable plus any that have vested
-	suite.Require().Equal(balances.Sub(vacc.LockedCoins(now.Add(12*time.Hour))...), origCoins)
+	suite.Require().Equal(balances.Sub(vacc.LockedCoins(contextAt(now.Add(12*time.Hour)))...), origCoins)
 }
 
 func (suite *IntegrationTestSuite) TestDelegateCoins() {
diff --git a/x/bank/keeper/view.go b/x/bank/keeper/view.go
index e189edca1d..1f371efc38 100644
--- a/x/bank/keeper/view.go
+++ b/x/bank/keeper/view.go
@@ -169,7 +169,7 @@ func (k BaseViewKeeper) LockedCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Co
 	if acc != nil {
 		vacc, ok := acc.(types.VestingAccount)
 		if ok {
-			return vacc.LockedCoins(ctx.BlockTime())
+			return vacc.LockedCoins(ctx)
 		}
 	}
 
diff --git a/x/bank/types/vesting.go b/x/bank/types/vesting.go
index a288d4ec81..c7981fbc40 100644
--- a/x/bank/types/vesting.go
+++ b/x/bank/types/vesting.go
@@ -14,7 +14,7 @@ type VestingAccount interface {
 	// To get spendable coins of a vesting account, first the total balance must
 	// be retrieved and the locked tokens can be subtracted from the total balance.
 	// Note, the spendable balance can be negative.
-	LockedCoins(blockTime time.Time) sdk.Coins
+	LockedCoins(ctx sdk.Context) sdk.Coins
 
 	// TrackDelegation performs internal vesting accounting necessary when
 	// delegating from a vesting account. It accepts the current block time, the
diff --git a/x/distribution/keeper/delegation.go b/x/distribution/keeper/delegation.go
index f94e1a73b4..f4ea52275e 100644
--- a/x/distribution/keeper/delegation.go
+++ b/x/distribution/keeper/delegation.go
@@ -136,6 +136,16 @@ func (k Keeper) CalculateDelegationRewards(ctx sdk.Context, val stakingtypes.Val
 	return rewards
 }
 
+// SmartRewardAccount is an account with a post-reward processing function.
+// Such an account ignores a non-default withdrawal address, as this can
+// be implemented in the post-reward processing if desired.
+type SmartRewardAccount interface {
+	// PostReward is called after reward has been transferred to the account.
+	// The named keepers should be provided. They are given the trivial type
+	// here to handle the mismatch in expected methods with the callee.
+	PostReward(ctx sdk.Context, reward sdk.Coins, authKeeper, bankKeeper, stakingKeeper interface{})
+}
+
 func (k Keeper) withdrawDelegationRewards(ctx sdk.Context, val stakingtypes.ValidatorI, del stakingtypes.DelegationI) (sdk.Coins, error) {
 	// check existence of delegator starting info
 	if !k.HasDelegatorStartingInfo(ctx, del.GetValidatorAddr(), del.GetDelegatorAddr()) {
@@ -166,11 +176,15 @@ func (k Keeper) withdrawDelegationRewards(ctx sdk.Context, val stakingtypes.Vali
 
 	// add coins to user account
 	if !finalRewards.IsZero() {
-		withdrawAddr := k.GetDelegatorWithdrawAddr(ctx, del.GetDelegatorAddr())
+		addr := del.GetDelegatorAddr()
+		withdrawAddr := k.GetDelegatorWithdrawAddr(ctx, addr)
 		err := k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, withdrawAddr, finalRewards)
 		if err != nil {
 			return nil, err
 		}
+		for _, h := range k.hooks {
+			h.AfterDelegationReward(ctx, addr, withdrawAddr, finalRewards)
+		}
 	}
 
 	// update the outstanding rewards and the community pool only if the
diff --git a/x/distribution/keeper/hooks.go b/x/distribution/keeper/hooks.go
index bfae8482da..13c49b7fcf 100644
--- a/x/distribution/keeper/hooks.go
+++ b/x/distribution/keeper/hooks.go
@@ -50,6 +50,9 @@ func (h Hooks) AfterValidatorRemoved(ctx sdk.Context, _ sdk.ConsAddress, valAddr
 			if err := h.k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, withdrawAddr, coins); err != nil {
 				return err
 			}
+			for _, distHook := range h.k.hooks {
+				distHook.AfterDelegationReward(ctx, accAddr, withdrawAddr, coins)
+			}
 		}
 	}
 
diff --git a/x/distribution/keeper/keeper.go b/x/distribution/keeper/keeper.go
index f050087dba..b6553f3c63 100644
--- a/x/distribution/keeper/keeper.go
+++ b/x/distribution/keeper/keeper.go
@@ -22,6 +22,8 @@ type Keeper struct {
 	bankKeeper    types.BankKeeper
 	stakingKeeper types.StakingKeeper
 
+	hooks []types.DistributionHooks
+
 	feeCollectorName string // name of the FeeCollector ModuleAccount
 }
 
@@ -48,6 +50,7 @@ func NewKeeper(
 		authKeeper:       ak,
 		bankKeeper:       bk,
 		stakingKeeper:    sk,
+		hooks:            []types.DistributionHooks{},
 		feeCollectorName: feeCollectorName,
 	}
 }
@@ -57,6 +60,14 @@ func (k Keeper) Logger(ctx sdk.Context) log.Logger {
 	return ctx.Logger().With("module", "x/"+types.ModuleName)
 }
 
+// AddHooks adds a hooks object to be called upon certain events.
+func (k *Keeper) AddHooks(h types.DistributionHooks) *Keeper {
+	if h != nil {
+		k.hooks = append(k.hooks, h)
+	}
+	return k
+}
+
 // SetWithdrawAddr sets a new address that will receive the rewards upon withdrawal
 func (k Keeper) SetWithdrawAddr(ctx sdk.Context, delegatorAddr sdk.AccAddress, withdrawAddr sdk.AccAddress) error {
 	if k.bankKeeper.BlockedAddr(withdrawAddr) {
@@ -129,6 +140,9 @@ func (k Keeper) WithdrawValidatorCommission(ctx sdk.Context, valAddr sdk.ValAddr
 		withdrawAddr := k.GetDelegatorWithdrawAddr(ctx, accAddr)
 		err := k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, withdrawAddr, commission)
 		if err != nil {
+			for _, h := range k.hooks {
+				h.AfterDelegationReward(ctx, accAddr, withdrawAddr, commission)
+			}
 			return nil, err
 		}
 	}
diff --git a/x/distribution/keeper/store.go b/x/distribution/keeper/store.go
index 3def35163f..fef05da8d8 100644
--- a/x/distribution/keeper/store.go
+++ b/x/distribution/keeper/store.go
@@ -9,6 +9,11 @@ import (
 
 // get the delegator withdraw address, defaulting to the delegator address
 func (k Keeper) GetDelegatorWithdrawAddr(ctx sdk.Context, delAddr sdk.AccAddress) sdk.AccAddress {
+	for _, h := range k.hooks {
+		if !h.AllowWithdrawAddr(ctx, delAddr) {
+			return delAddr
+		}
+	}
 	store := ctx.KVStore(k.storeKey)
 	b := store.Get(types.GetDelegatorWithdrawAddrKey(delAddr))
 	if b == nil {
diff --git a/x/distribution/spec/05_hooks.md b/x/distribution/spec/05_hooks.md
index a1702ef73b..a58264603e 100644
--- a/x/distribution/spec/05_hooks.md
+++ b/x/distribution/spec/05_hooks.md
@@ -6,6 +6,26 @@ order: 5
 
 Available hooks that can be called by and from this module.
 
+## DistributionHooks
+
+### Setting Hooks
+
+Other modules may call the `AddHooks()` method of the distribution keeper
+to register an object implementing the `DistributionHooks` interface.
+All registered hooks will be called for the following events.
+
+### Before Reward Withdrawal
+
+Before a reward is transferred, the distribution keeper will call the
+`AllowWithdrawAddr()` method of each hooks object. If any hooks object
+returns `false`, the alternative withdrawal address is not honored and
+the reward will be sent to the withdrawing account.
+
+### After Reward Withdrawal
+
+After a delegation reward has been transferred, the distribution keeper will call the
+`AfterDelegationReward()` method of each hooks object.
+
 ## Create or modify delegation distribution
 
 * triggered-by: `staking.MsgDelegate`, `staking.MsgBeginRedelegate`, `staking.MsgUndelegate`
diff --git a/x/distribution/types/expected_keepers.go b/x/distribution/types/expected_keepers.go
index 82eee3eabe..628ca34339 100644
--- a/x/distribution/types/expected_keepers.go
+++ b/x/distribution/types/expected_keepers.go
@@ -30,6 +30,19 @@ type BankKeeper interface {
 	BlockedAddr(addr sdk.AccAddress) bool
 }
 
+// DistributionHooks allows other keepers to register to be called for certain events.
+type DistributionHooks interface {
+	// AllowWithdrawAddr tells whether to honor the delegation withdraw
+	// address associated with the address (if any). The distribution
+	// keeper will call this before each reward withdrawal.
+	// If multiple distribution hooks are set, then any of them may
+	// disallow the withdraw address.
+	AllowWithdrawAddr(ctx sdk.Context, delAddr sdk.AccAddress) bool
+
+	// AfterDelegationReward is called after the reward has been transferred the address.
+	AfterDelegationReward(ctx sdk.Context, delAddr, withdrawAddr sdk.AccAddress, reward sdk.Coins)
+}
+
 // StakingKeeper expected staking keeper (noalias)
 type StakingKeeper interface {
 	// iterate through validators by operator address, execute func for each validator
diff --git a/x/gov/client/cli/tx.go b/x/gov/client/cli/tx.go
index f18c148749..eb8edd5dc0 100644
--- a/x/gov/client/cli/tx.go
+++ b/x/gov/client/cli/tx.go
@@ -59,32 +59,34 @@ func NewTxCmd(legacyPropCmds []*cobra.Command) *cobra.Command {
 		RunE:                       client.ValidateCmd,
 	}
 
-	cmdSubmitLegacyProp := NewCmdSubmitLegacyProposal()
+	cmdSubmitProp := NewCmdSubmitProposal()
 	for _, propCmd := range legacyPropCmds {
 		flags.AddTxFlagsToCmd(propCmd)
-		cmdSubmitLegacyProp.AddCommand(propCmd)
+		cmdSubmitProp.AddCommand(propCmd)
 	}
 
 	govTxCmd.AddCommand(
 		NewCmdDeposit(),
 		NewCmdVote(),
 		NewCmdWeightedVote(),
-		NewCmdSubmitProposal(),
+		cmdSubmitProp,
 		NewCmdDraftProposal(),
-
-		// Deprecated
-		cmdSubmitLegacyProp,
 	)
 
 	return govTxCmd
 }
 
 // NewCmdSubmitProposal implements submitting a proposal transaction command.
+// NOTE: This command has been modified from its original to subsume both
+// the "legacy" and the new (as of v0.46) invocation patterns. This modification
+// will be dropped once all legacy call sites have been updated to either
+// use the new pattern or call the legacy command explicitly.
 func NewCmdSubmitProposal() *cobra.Command {
 	cmd := &cobra.Command{
-		Use:   "submit-proposal [path/to/proposal.json]",
-		Short: "Submit a proposal along with some messages, metadata and deposit",
-		Args:  cobra.ExactArgs(1),
+		Use:     "submit-proposal [path/to/proposal.json]",
+		Short:   "Submit a proposal along with some messages, metadata and deposit",
+		Aliases: []string{"submit-legacy-proposal"},
+		Args:    cobra.MaximumNArgs(1),
 		Long: strings.TrimSpace(
 			fmt.Sprintf(`Submit a proposal along with some messages, metadata and deposit.
 They should be defined in a JSON file.
@@ -107,43 +109,9 @@ Where proposal.json contains:
   "metadata: "4pIMOgIGx1vZGU=", // base64-encoded metadata
   "deposit": "10stake"
 }
-`,
-				version.AppName,
-			),
-		),
-		RunE: func(cmd *cobra.Command, args []string) error {
-			clientCtx, err := client.GetClientTxContext(cmd)
-			if err != nil {
-				return err
-			}
-
-			msgs, metadata, deposit, err := parseSubmitProposal(clientCtx.Codec, args[0])
-			if err != nil {
-				return err
-			}
-
-			msg, err := v1.NewMsgSubmitProposal(msgs, deposit, clientCtx.GetFromAddress().String(), metadata)
-			if err != nil {
-				return fmt.Errorf("invalid message: %w", err)
-			}
-
-			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
-		},
-	}
-
-	flags.AddTxFlagsToCmd(cmd)
-
-	return cmd
-}
 
-// NewCmdSubmitLegacyProposal implements submitting a proposal transaction command.
-// Deprecated: please use NewCmdSubmitProposal instead.
-func NewCmdSubmitLegacyProposal() *cobra.Command {
-	cmd := &cobra.Command{
-		Use:   "submit-legacy-proposal",
-		Short: "Submit a legacy proposal along with an initial deposit",
-		Long: strings.TrimSpace(
-			fmt.Sprintf(`Submit a legacy proposal along with an initial deposit.
+Legacy Syntax:
+Submit a legacy proposal along with an initial deposit.
 Proposal title, description, type and deposit can be given directly or through a proposal JSON file.
 
 Example:
@@ -162,7 +130,7 @@ Which is equivalent to:
 
 $ %s tx gov submit-legacy-proposal --title="Test Proposal" --description="My awesome proposal" --type="Text" --deposit="10test" --from mykey
 `,
-				version.AppName, version.AppName,
+				version.AppName, version.AppName, version.AppName,
 			),
 		),
 		RunE: func(cmd *cobra.Command, args []string) error {
@@ -171,22 +139,39 @@ $ %s tx gov submit-legacy-proposal --title="Test Proposal" --description="My awe
 				return err
 			}
 
+			// try to interpret as a legacy submit-proposal call
 			proposal, err := parseSubmitLegacyProposalFlags(cmd.Flags())
-			if err != nil {
-				return fmt.Errorf("failed to parse proposal: %w", err)
+			if err == nil {
+				amount, err := sdk.ParseCoinsNormalized(proposal.Deposit)
+				if err != nil {
+					return err
+				}
+
+				content, ok := v1beta1.ContentFromProposalType(proposal.Title, proposal.Description, proposal.Type)
+				if !ok {
+					return fmt.Errorf("failed to create proposal content: unknown proposal type %s", proposal.Type)
+				}
+
+				msg, err := v1beta1.NewMsgSubmitProposal(content, amount, clientCtx.GetFromAddress())
+				if err != nil {
+					return fmt.Errorf("invalid message: %w", err)
+				}
+
+				return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
 			}
 
-			amount, err := sdk.ParseCoinsNormalized(proposal.Deposit)
+			// otherwise try to interpret as a new (0.46) submit-proposal
+			err = cobra.ExactArgs(1)(cmd, args)
 			if err != nil {
 				return err
 			}
 
-			content, ok := v1beta1.ContentFromProposalType(proposal.Title, proposal.Description, proposal.Type)
-			if !ok {
-				return fmt.Errorf("failed to create proposal content: unknown proposal type %s", proposal.Type)
+			msgs, metadata, deposit, err := parseSubmitProposal(clientCtx.Codec, args[0])
+			if err != nil {
+				return err
 			}
 
-			msg, err := v1beta1.NewMsgSubmitProposal(content, amount, clientCtx.GetFromAddress())
+			msg, err := v1.NewMsgSubmitProposal(msgs, deposit, clientCtx.GetFromAddress().String(), metadata)
 			if err != nil {
 				return fmt.Errorf("invalid message: %w", err)
 			}
@@ -205,6 +190,13 @@ $ %s tx gov submit-legacy-proposal --title="Test Proposal" --description="My awe
 	return cmd
 }
 
+// NewCmdSubmitLegacyProposal implements submitting a proposal transaction command.
+// Deprecated: please use NewCmdSubmitProposal instead.
+// Preserved for tests.
+func NewCmdSubmitLegacyProposal() *cobra.Command {
+	return NewCmdSubmitProposal()
+}
+
 // NewCmdDeposit implements depositing tokens for an active proposal.
 func NewCmdDeposit() *cobra.Command {
 	cmd := &cobra.Command{
diff --git a/x/params/types/table.go b/x/params/types/table.go
index ef09c39d88..3472a493aa 100644
--- a/x/params/types/table.go
+++ b/x/params/types/table.go
@@ -33,8 +33,8 @@ func (t KeyTable) RegisterType(psp ParamSetPair) KeyTable {
 	if len(psp.Key) == 0 {
 		panic("cannot register ParamSetPair with an parameter empty key")
 	}
-	if !sdk.IsAlphaNumeric(string(psp.Key)) {
-		panic("cannot register ParamSetPair with a non-alphanumeric parameter key")
+	if !sdk.IsAlphaNumericOrUnderscore(string(psp.Key)) {
+		panic("cannot register ParamSetPair with a non-alphanumeric or underscore parameter key")
 	}
 	if psp.ValidatorFn == nil {
 		panic("cannot register ParamSetPair without a value validation function")
diff --git a/x/staking/keeper/delegation.go b/x/staking/keeper/delegation.go
index 2c6de7a59d..f0b3169633 100644
--- a/x/staking/keeper/delegation.go
+++ b/x/staking/keeper/delegation.go
@@ -3,6 +3,7 @@ package keeper
 import (
 	"bytes"
 	"fmt"
+	stdmath "math"
 	"time"
 
 	"cosmossdk.io/math"
@@ -73,19 +74,15 @@ func (k Keeper) GetValidatorDelegations(ctx sdk.Context, valAddr sdk.ValAddress)
 // delegator.
 func (k Keeper) GetDelegatorDelegations(ctx sdk.Context, delegator sdk.AccAddress, maxRetrieve uint16) (delegations []types.Delegation) {
 	delegations = make([]types.Delegation, maxRetrieve)
-	store := ctx.KVStore(k.storeKey)
-	delegatorPrefixKey := types.GetDelegationsKey(delegator)
-
-	iterator := sdk.KVStorePrefixIterator(store, delegatorPrefixKey)
-	defer iterator.Close()
 
 	i := 0
-	for ; iterator.Valid() && i < int(maxRetrieve); iterator.Next() {
-		delegation := types.MustUnmarshalDelegation(k.cdc, iterator.Value())
-		delegations[i] = delegation
-		i++
+	if i < int(maxRetrieve) {
+		k.IterateDelegatorDelegations(ctx, delegator, func(delegation types.Delegation) bool {
+			delegations[i] = delegation
+			i++
+			return i >= int(maxRetrieve)
+		})
 	}
-
 	return delegations[:i] // trim if the array length < maxRetrieve
 }
 
@@ -696,6 +693,157 @@ func (k Keeper) Delegate(
 	return newShares, nil
 }
 
+// TransferDelegation changes the ownership of at most the desired number of shares.
+// Returns the actual number of shares transferred. Will also transfer redelegation
+// entries to ensure that all redelegations are matched by sufficient shares.
+// Note that no tokens are transferred to or from any pool or account, since no
+// delegation is actually changing state.
+func (k Keeper) TransferDelegation(ctx sdk.Context, fromAddr, toAddr sdk.AccAddress, valAddr sdk.ValAddress, wantShares sdk.Dec) sdk.Dec {
+	transferred := sdk.ZeroDec()
+
+	// sanity checks
+	if !wantShares.IsPositive() {
+		return transferred
+	}
+	validator, found := k.GetValidator(ctx, valAddr)
+	if !found {
+		return transferred
+	}
+	delFrom, found := k.GetDelegation(ctx, fromAddr, valAddr)
+	if !found {
+		return transferred
+	}
+
+	// Check redelegation entry limits while we can still return early.
+	// Assume the worst case that we need to transfer all redelegation entries
+	mightExceedLimit := false
+	k.IterateDelegatorRedelegations(ctx, fromAddr, func(toRedelegation types.Redelegation) (stop bool) {
+		// There's no redelegation index by delegator and dstVal or vice-versa.
+		// The minimum cardinality is to look up by delegator, so scan and skip.
+		if toRedelegation.ValidatorDstAddress != valAddr.String() {
+			return false
+		}
+		fromRedelegation, found := k.GetRedelegation(ctx, fromAddr, sdk.ValAddress(toRedelegation.ValidatorSrcAddress), sdk.ValAddress(toRedelegation.ValidatorDstAddress))
+		if found && len(toRedelegation.Entries)+len(fromRedelegation.Entries) >= int(k.MaxEntries(ctx)) {
+			mightExceedLimit = true
+			return true
+		}
+		return false
+	})
+	if mightExceedLimit {
+		// avoid types.ErrMaxRedelegationEntries
+		return transferred
+	}
+
+	// compute shares to transfer, amount left behind
+	transferred = delFrom.Shares
+	if transferred.GT(wantShares) {
+		transferred = wantShares
+	}
+	remaining := delFrom.Shares.Sub(transferred)
+
+	// Update or create the delTo object, calling appropriate hooks
+	delTo, found := k.GetDelegation(ctx, toAddr, validator.GetOperator())
+	if !found {
+		delTo = types.NewDelegation(toAddr, validator.GetOperator(), sdk.ZeroDec())
+	}
+	if found {
+		k.BeforeDelegationSharesModified(ctx, toAddr, validator.GetOperator())
+	} else {
+		k.BeforeDelegationCreated(ctx, toAddr, validator.GetOperator())
+	}
+	delTo.Shares = delTo.Shares.Add(transferred)
+	k.SetDelegation(ctx, delTo)
+	k.AfterDelegationModified(ctx, toAddr, valAddr)
+
+	// Update source delegation
+	if remaining.IsZero() {
+		k.BeforeDelegationRemoved(ctx, fromAddr, valAddr)
+		k.RemoveDelegation(ctx, delFrom)
+	} else {
+		k.BeforeDelegationSharesModified(ctx, fromAddr, valAddr)
+		delFrom.Shares = remaining
+		k.SetDelegation(ctx, delFrom)
+		k.AfterDelegationModified(ctx, fromAddr, valAddr)
+	}
+
+	// If there are not enough remaining shares to be responsible for
+	// the redelegations, transfer some redelegations.
+	// For instance, if the original delegation of 300 shares to validator A
+	// had redelegations for 100 shares each from validators B, C, and D,
+	// and if we're transferring 175 shares, then we might keep the redelegation
+	// from B, transfer the one from D, and split the redelegation from C
+	// keeping a liability for 25 shares and transferring one for 75 shares.
+	// Of course, the redelegations themselves can have multiple entries for
+	// different timestamps, so we're actually working at a finer granularity.
+	redelegations := k.GetRedelegations(ctx, fromAddr, stdmath.MaxUint16)
+	for _, redelegation := range redelegations {
+		// There's no redelegation index by delegator and dstVal or vice-versa.
+		// The minimum cardinality is to look up by delegator, so scan and skip.
+		if redelegation.ValidatorDstAddress != valAddr.String() {
+			continue
+		}
+		redelegationModified := false
+		entriesRemaining := false
+		for i := 0; i < len(redelegation.Entries); i++ {
+			entry := redelegation.Entries[i]
+
+			// Partition SharesDst between keeping and sending
+			sharesToKeep := entry.SharesDst
+			sharesToSend := sdk.ZeroDec()
+			if entry.SharesDst.GT(remaining) {
+				sharesToKeep = remaining
+				sharesToSend = entry.SharesDst.Sub(sharesToKeep)
+			}
+			remaining = remaining.Sub(sharesToKeep) // fewer local shares available to cover liability
+
+			if sharesToSend.IsZero() {
+				// Leave the entry here
+				entriesRemaining = true
+				continue
+			}
+			if sharesToKeep.IsZero() {
+				// Transfer the whole entry, delete locally
+				toRed := k.SetRedelegationEntry(
+					ctx, toAddr, sdk.ValAddress(redelegation.ValidatorSrcAddress),
+					sdk.ValAddress(redelegation.ValidatorDstAddress),
+					entry.CreationHeight, entry.CompletionTime, entry.InitialBalance, sdk.ZeroDec(), sharesToSend,
+				)
+				k.InsertRedelegationQueue(ctx, toRed, entry.CompletionTime)
+				redelegation.RemoveEntry(int64(i))
+				i--
+				// okay to leave an obsolete entry in the queue for the removed entry
+				redelegationModified = true
+			} else {
+				// Proportionally divide the entry
+				fracSending := sharesToSend.Quo(entry.SharesDst)
+				balanceToSend := fracSending.MulInt(entry.InitialBalance).TruncateInt()
+				balanceToKeep := entry.InitialBalance.Sub(balanceToSend)
+				toRed := k.SetRedelegationEntry(
+					ctx, toAddr, sdk.ValAddress(redelegation.ValidatorSrcAddress),
+					sdk.ValAddress(redelegation.ValidatorDstAddress),
+					entry.CreationHeight, entry.CompletionTime, balanceToSend, sdk.ZeroDec(), sharesToSend,
+				)
+				k.InsertRedelegationQueue(ctx, toRed, entry.CompletionTime)
+				entry.InitialBalance = balanceToKeep
+				entry.SharesDst = sharesToKeep
+				redelegation.Entries[i] = entry
+				// not modifying the completion time, so no need to change the queue
+				redelegationModified = true
+				entriesRemaining = true
+			}
+		}
+		if redelegationModified {
+			if entriesRemaining {
+				k.SetRedelegation(ctx, redelegation)
+			} else {
+				k.RemoveRedelegation(ctx, redelegation)
+			}
+		}
+	}
+	return transferred
+}
+
 // Unbond unbonds a particular delegation and perform associated store operations.
 func (k Keeper) Unbond(
 	ctx sdk.Context, delAddr sdk.AccAddress, valAddr sdk.ValAddress, shares sdk.Dec,
@@ -825,6 +973,57 @@ func (k Keeper) Undelegate(
 	return completionTime, nil
 }
 
+// TransferUnbonding changes the ownership of UnbondingDelegation entries
+// until the desired number of tokens have changed hands. Returns the actual
+// number of tokens transferred.
+func (k Keeper) TransferUnbonding(ctx sdk.Context, fromAddr, toAddr sdk.AccAddress, valAddr sdk.ValAddress, wantAmt sdk.Int) sdk.Int {
+	transferred := sdk.ZeroInt()
+	ubdFrom, found := k.GetUnbondingDelegation(ctx, fromAddr, valAddr)
+	if !found {
+		return transferred
+	}
+	ubdFromModified := false
+
+	for i := 0; i < len(ubdFrom.Entries) && wantAmt.IsPositive(); i++ {
+		entry := ubdFrom.Entries[i]
+		toXfer := entry.Balance
+		if toXfer.GT(wantAmt) {
+			toXfer = wantAmt
+		}
+		if !toXfer.IsPositive() {
+			continue
+		}
+
+		if k.HasMaxUnbondingDelegationEntries(ctx, toAddr, valAddr) {
+			// TODO pre-compute the maximum entries we can add rather than checking each time
+			break
+		}
+		ubdTo := k.SetUnbondingDelegationEntry(ctx, toAddr, valAddr, entry.CreationHeight, entry.CompletionTime, toXfer)
+		k.InsertUBDQueue(ctx, ubdTo, entry.CompletionTime)
+		transferred = transferred.Add(toXfer)
+		wantAmt = wantAmt.Sub(toXfer)
+
+		ubdFromModified = true
+		remaining := entry.Balance.Sub(toXfer)
+		if remaining.IsZero() {
+			ubdFrom.RemoveEntry(int64(i))
+			i--
+			continue
+		}
+		entry.Balance = remaining
+		ubdFrom.Entries[i] = entry
+	}
+
+	if ubdFromModified {
+		if len(ubdFrom.Entries) == 0 {
+			k.RemoveUnbondingDelegation(ctx, ubdFrom)
+		} else {
+			k.SetUnbondingDelegation(ctx, ubdFrom)
+		}
+	}
+	return transferred
+}
+
 // CompleteUnbonding completes the unbonding of all mature entries in the
 // retrieved unbonding delegation object and returns the total unbonding balance
 // or an error upon failure.
diff --git a/x/staking/keeper/delegation_test.go b/x/staking/keeper/delegation_test.go
index 6190df425c..a156861135 100644
--- a/x/staking/keeper/delegation_test.go
+++ b/x/staking/keeper/delegation_test.go
@@ -145,6 +145,100 @@ func TestDelegation(t *testing.T) {
 	require.Equal(t, 0, len(resBonds))
 }
 
+func TestTransferDelegation(t *testing.T) {
+	_, app, ctx := createTestInput(t)
+
+	addrDels := simapp.AddTestAddrsIncremental(app, ctx, 3, sdk.NewInt(10000))
+	valAddrs := simapp.ConvertAddrsToValAddrs(addrDels)
+
+	// construct the validators
+	amts := []sdk.Int{sdk.NewInt(9), sdk.NewInt(8), sdk.NewInt(7)}
+	var validators [3]types.Validator
+	for i, amt := range amts {
+		validators[i] = teststaking.NewValidator(t, valAddrs[i], PKs[i])
+		validators[i], _ = validators[i].AddTokensFromDel(amt)
+	}
+	validators[0] = keeper.TestingUpdateValidator(app.StakingKeeper, ctx, validators[0], true)
+	validators[1] = keeper.TestingUpdateValidator(app.StakingKeeper, ctx, validators[1], true)
+	validators[2] = keeper.TestingUpdateValidator(app.StakingKeeper, ctx, validators[2], true)
+
+	// try a transfer when there's nothing
+	transferred := app.StakingKeeper.TransferDelegation(ctx, addrDels[0], addrDels[1], valAddrs[0], sdk.NewDec(1000))
+	require.Equal(t, sdk.ZeroDec(), transferred)
+
+	// stake some tokens
+	bond1to1 := types.NewDelegation(addrDels[0], valAddrs[0], sdk.NewDec(99))
+	app.StakingKeeper.SetDelegation(ctx, bond1to1)
+	// stake to an unrelated validator so implementation has to skip it
+	bond1to3 := types.NewDelegation(addrDels[0], valAddrs[2], sdk.NewDec(9))
+	app.StakingKeeper.SetDelegation(ctx, bond1to3)
+
+	// transfer nothing
+	transferred = app.StakingKeeper.TransferDelegation(ctx, addrDels[0], addrDels[1], valAddrs[0], sdk.ZeroDec())
+	require.Equal(t, sdk.ZeroDec(), transferred)
+
+	// partial transfer, empty recipient
+	transferred = app.StakingKeeper.TransferDelegation(ctx, addrDels[0], addrDels[1], valAddrs[0], sdk.NewDec(10))
+	require.Equal(t, sdk.NewDec(10), transferred)
+	resBond, found := app.StakingKeeper.GetDelegation(ctx, addrDels[0], valAddrs[0])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(89), resBond.Shares)
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[1], valAddrs[0])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(10), resBond.Shares)
+
+	// partial transfer, existing recipient
+	transferred = app.StakingKeeper.TransferDelegation(ctx, addrDels[0], addrDels[1], valAddrs[0], sdk.NewDec(11))
+	require.Equal(t, transferred, sdk.NewDec(11))
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[0], valAddrs[0])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(78), resBond.Shares)
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[1], valAddrs[0])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(21), resBond.Shares)
+
+	// full transfer
+	transferred = app.StakingKeeper.TransferDelegation(ctx, addrDels[0], addrDels[1], valAddrs[0], sdk.NewDec(9999))
+	require.Equal(t, transferred, sdk.NewDec(78))
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[0], valAddrs[0])
+	require.False(t, found)
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[1], valAddrs[0])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(99), resBond.Shares)
+
+	// simulate redelegate to another validator
+	bond1to2 := types.NewDelegation(addrDels[0], valAddrs[1], sdk.NewDec(20))
+	app.StakingKeeper.SetDelegation(ctx, bond1to2)
+	rd := types.NewRedelegation(addrDels[0], valAddrs[0], valAddrs[1], 0, time.Unix(0, 0).UTC(), sdk.NewInt(20), sdk.NewDec(20))
+	app.StakingKeeper.SetRedelegation(ctx, rd)
+
+	// partial transfer from redelegation
+	transferred = app.StakingKeeper.TransferDelegation(ctx, addrDels[0], addrDels[1], valAddrs[1], sdk.NewDec(7))
+	require.Equal(t, sdk.NewDec(7), transferred)
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[0], valAddrs[1])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(13), resBond.Shares)
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[1], valAddrs[1])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(7), resBond.Shares)
+
+	// stake more alongside redelegation
+	bond1to2, found = app.StakingKeeper.GetDelegation(ctx, addrDels[0], valAddrs[1])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(13), bond1to2.Shares)
+	bond1to2.Shares = sdk.NewDec(47) // add 34 shares
+	app.StakingKeeper.SetDelegation(ctx, bond1to2)
+
+	// full transfer from partial redelegation
+	transferred = app.StakingKeeper.TransferDelegation(ctx, addrDels[0], addrDels[1], valAddrs[1], sdk.NewDec(9999))
+	require.Equal(t, sdk.NewDec(47), transferred)
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[0], valAddrs[1])
+	require.False(t, found)
+	resBond, found = app.StakingKeeper.GetDelegation(ctx, addrDels[1], valAddrs[1])
+	require.True(t, found)
+	require.Equal(t, sdk.NewDec(54), resBond.Shares)
+}
+
 // tests Get/Set/Remove UnbondingDelegation
 func TestUnbondingDelegation(t *testing.T) {
 	_, app, ctx := createTestInput(t)
@@ -196,6 +290,68 @@ func TestUnbondingDelegation(t *testing.T) {
 	require.Equal(t, 0, len(resUnbonds))
 }
 
+func TestTransferUnbonding(t *testing.T) {
+	_, app, ctx := createTestInput(t)
+
+	delAddrs := simapp.AddTestAddrsIncremental(app, ctx, 2, sdk.NewInt(10000))
+	valAddrs := simapp.ConvertAddrsToValAddrs(delAddrs)
+
+	// try to transfer when there's nothing
+	transferred := app.StakingKeeper.TransferUnbonding(ctx, delAddrs[0], delAddrs[1], valAddrs[0], sdk.NewInt(30))
+	require.Equal(t, sdk.ZeroInt(), transferred)
+	_, found := app.StakingKeeper.GetUnbondingDelegation(ctx, delAddrs[1], valAddrs[0])
+	require.False(t, found)
+
+	// set an UnbondingDelegation with one entry
+	ubd := types.NewUnbondingDelegation(
+		delAddrs[0],
+		valAddrs[0],
+		0,
+		time.Unix(0, 0).UTC(),
+		sdk.NewInt(5),
+	)
+	app.StakingKeeper.SetUnbondingDelegation(ctx, ubd)
+
+	// transfer nothing
+	transferred = app.StakingKeeper.TransferUnbonding(ctx, delAddrs[0], delAddrs[1], valAddrs[0], sdk.ZeroInt())
+	require.Equal(t, sdk.ZeroInt(), transferred)
+
+	// partial transfer
+	transferred = app.StakingKeeper.TransferUnbonding(ctx, delAddrs[0], delAddrs[1], valAddrs[0], sdk.NewInt(3))
+	require.Equal(t, sdk.NewInt(3), transferred)
+	ubd.Entries[0].Balance = sdk.NewInt(2)
+	resUnbond, found := app.StakingKeeper.GetUnbondingDelegation(ctx, delAddrs[0], valAddrs[0])
+	require.True(t, found)
+	require.Equal(t, ubd, resUnbond)
+	resUnbond, found = app.StakingKeeper.GetUnbondingDelegation(ctx, delAddrs[1], valAddrs[0])
+	require.True(t, found)
+	wantDestUnbond := types.NewUnbondingDelegation(
+		delAddrs[1],
+		valAddrs[0],
+		0,
+		time.Unix(0, 0).UTC(),
+		sdk.NewInt(3),
+	)
+	require.Equal(t, wantDestUnbond, resUnbond)
+
+	// add another entry
+	completionTime := time.Unix(3600, 0).UTC()
+	ubdTo := app.StakingKeeper.SetUnbondingDelegationEntry(ctx, delAddrs[0], valAddrs[0], 1, completionTime, sdk.NewInt(57))
+	app.StakingKeeper.InsertUBDQueue(ctx, ubdTo, completionTime)
+
+	// full transfer
+	transferred = app.StakingKeeper.TransferUnbonding(ctx, delAddrs[0], delAddrs[1], valAddrs[0], sdk.NewInt(999))
+	require.Equal(t, sdk.NewInt(59), transferred)
+	_, found = app.StakingKeeper.GetUnbondingDelegation(ctx, delAddrs[0], valAddrs[0])
+	require.False(t, found)
+	resUnbond, found = app.StakingKeeper.GetUnbondingDelegation(ctx, delAddrs[1], valAddrs[0])
+	require.True(t, found)
+	require.Equal(t, 3, len(resUnbond.Entries))
+	require.Equal(t, sdk.NewInt(3), resUnbond.Entries[0].Balance)
+	require.Equal(t, sdk.NewInt(2), resUnbond.Entries[1].Balance)
+	require.Equal(t, sdk.NewInt(57), resUnbond.Entries[2].Balance)
+}
+
 func TestUnbondDelegation(t *testing.T) {
 	_, app, ctx := createTestInput(t)
 
